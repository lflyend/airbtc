<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
        <title>BTC — Offline Signer</title>
        <!--
        Notice of Copyrights and Licenses:
        ***********************************
        The BTC — Offline Signer project, software, and embedded resources are copyright BTC — Offline Signer.
        The project name and logo are not part of the open source license.

        This all-in-one HTML document includes JavaScript code from various open source libraries.
        All included libraries retain their original copyright and license notices.
        Each library is loaded via separate HTML script tags where applicable.

        Summary of JavaScript functions / global variables with redistributable licenses:

        JavaScript function / global variable         License
        ******************************************     ***************
        Buffer                                         MIT License
        bs58check                                      MIT License
        valibot                                        MIT License
        wif                                            MIT License
        bitcoin (bitcoinjs-lib)                        MIT License
        ECPairFactory                                  MIT License
        sha256 (noble-hashes)                          MIT License
        sha512 (noble-hashes)                          MIT License
        ecc (noble-secp256k1)                          MIT License
        bip39                                          MIT License
        bip32                                          MIT License

        The BTC — Offline Signer software is available under The MIT License (MIT)
        Copyright (c) 2026 BTC — Offline Signer

        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
        associated documentation files (the "Software"), to deal in the Software without restriction, including
        without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
        sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject
        to the following conditions:

        The above copyright notice and this permission notice shall be included in all copies or substantial
        portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
        LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

        -->
        <script type="text/javascript">
            var Buffer = (() => {
                /*!
                 * The buffer module from node.js, for the browser.
                 *
                 * @author   Feross Aboukhadijeh <https://feross.org>
                 * @license  MIT
                 */
                /* eslint-disable no-proto */

                'use strict'
                var lookup = []
                var revLookup = []
                var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

                var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
                for (var i = 0, len = code.length; i < len; ++i) {
                  lookup[i] = code[i]
                  revLookup[code.charCodeAt(i)] = i
                }

                // Support decoding URL-safe base64 strings, as Node.js does.
                // See: https://en.wikipedia.org/wiki/Base64#URL_applications
                revLookup['-'.charCodeAt(0)] = 62
                revLookup['_'.charCodeAt(0)] = 63

                function getLens (b64) {
                  var len = b64.length

                  if (len % 4 > 0) {
                    throw new Error('Invalid string. Length must be a multiple of 4')
                  }

                  // Trim off extra bytes after placeholder bytes are found
                  // See: https://github.com/beatgammit/base64-js/issues/42
                  var validLen = b64.indexOf('=')
                  if (validLen === -1) validLen = len

                  var placeHoldersLen = validLen === len
                    ? 0
                    : 4 - (validLen % 4)

                  return [validLen, placeHoldersLen]
                }

                // base64 is 4/3 + up to two characters of the original data
                function byteLength2 (b64) {
                  var lens = getLens(b64)
                  var validLen = lens[0]
                  var placeHoldersLen = lens[1]
                  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
                }

                function _byteLength (b64, validLen, placeHoldersLen) {
                  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
                }

                function toByteArray (b64) {
                  var tmp
                  var lens = getLens(b64)
                  var validLen = lens[0]
                  var placeHoldersLen = lens[1]

                  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

                  var curByte = 0

                  // if there are placeholders, only get up to the last complete 4 chars
                  var len = placeHoldersLen > 0
                    ? validLen - 4
                    : validLen

                  var i
                  for (i = 0; i < len; i += 4) {
                    tmp =
                      (revLookup[b64.charCodeAt(i)] << 18) |
                      (revLookup[b64.charCodeAt(i + 1)] << 12) |
                      (revLookup[b64.charCodeAt(i + 2)] << 6) |
                      revLookup[b64.charCodeAt(i + 3)]
                    arr[curByte++] = (tmp >> 16) & 0xFF
                    arr[curByte++] = (tmp >> 8) & 0xFF
                    arr[curByte++] = tmp & 0xFF
                  }

                  if (placeHoldersLen === 2) {
                    tmp =
                      (revLookup[b64.charCodeAt(i)] << 2) |
                      (revLookup[b64.charCodeAt(i + 1)] >> 4)
                    arr[curByte++] = tmp & 0xFF
                  }

                  if (placeHoldersLen === 1) {
                    tmp =
                      (revLookup[b64.charCodeAt(i)] << 10) |
                      (revLookup[b64.charCodeAt(i + 1)] << 4) |
                      (revLookup[b64.charCodeAt(i + 2)] >> 2)
                    arr[curByte++] = (tmp >> 8) & 0xFF
                    arr[curByte++] = tmp & 0xFF
                  }

                  return arr
                }

                function tripletToBase64 (num) {
                  return lookup[num >> 18 & 0x3F] +
                    lookup[num >> 12 & 0x3F] +
                    lookup[num >> 6 & 0x3F] +
                    lookup[num & 0x3F]
                }

                function encodeChunk (uint8, start, end) {
                  var tmp
                  var output = []
                  for (var i = start; i < end; i += 3) {
                    tmp =
                      ((uint8[i] << 16) & 0xFF0000) +
                      ((uint8[i + 1] << 8) & 0xFF00) +
                      (uint8[i + 2] & 0xFF)
                    output.push(tripletToBase64(tmp))
                  }
                  return output.join('')
                }

                function fromByteArray (uint8) {
                  var tmp
                  var len = uint8.length
                  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
                  var parts = []
                  var maxChunkLength = 16383 // must be multiple of 3

                  // go through the array every three bytes, we'll deal with trailing stuff later
                  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
                  }

                  // pad the end with zeros, but make sure to not forget the extra bytes
                  if (extraBytes === 1) {
                    tmp = uint8[len - 1]
                    parts.push(
                      lookup[tmp >> 2] +
                      lookup[(tmp << 4) & 0x3F] +
                      '=='
                    )
                  } else if (extraBytes === 2) {
                    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
                    parts.push(
                      lookup[tmp >> 10] +
                      lookup[(tmp >> 4) & 0x3F] +
                      lookup[(tmp << 2) & 0x3F] +
                      '='
                    )
                  }

                  return parts.join('')
                }

                const base64 = {
                  byteLength: byteLength2,
                  toByteArray,
                  fromByteArray
                };

                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                const ieee754 = {
                  read: function (buffer, offset, isLE, mLen, nBytes) {
                    var e, m
                    var eLen = (nBytes * 8) - mLen - 1
                    var eMax = (1 << eLen) - 1
                    var eBias = eMax >> 1
                    var nBits = -7
                    var i = isLE ? (nBytes - 1) : 0
                    var d = isLE ? -1 : 1
                    var s = buffer[offset + i]

                    i += d

                    e = s & ((1 << (-nBits)) - 1)
                    s >>= (-nBits)
                    nBits += eLen
                    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

                    m = e & ((1 << (-nBits)) - 1)
                    e >>= (-nBits)
                    nBits += mLen
                    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

                    if (e === 0) {
                      e = 1 - eBias
                    } else if (e === eMax) {
                      return m ? NaN : ((s ? -1 : 1) * Infinity)
                    } else {
                      m = m + Math.pow(2, mLen)
                      e = e - eBias
                    }
                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
                  },
                  write: function (buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m, c
                    var eLen = (nBytes * 8) - mLen - 1
                    var eMax = (1 << eLen) - 1
                    var eBias = eMax >> 1
                    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
                    var i = isLE ? 0 : (nBytes - 1)
                    var d = isLE ? 1 : -1
                    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

                    value = Math.abs(value)

                    if (isNaN(value) || value === Infinity) {
                      m = isNaN(value) ? 1 : 0
                      e = eMax
                    } else {
                      e = Math.floor(Math.log(value) / Math.LN2)
                      if (value * (c = Math.pow(2, -e)) < 1) {
                        e--
                        c *= 2
                      }
                      if (e + eBias >= 1) {
                        value += rt / c
                      } else {
                        value += rt * Math.pow(2, 1 - eBias)
                      }
                      if (value * c >= 2) {
                        e++
                        c /= 2
                      }

                      if (e + eBias >= eMax) {
                        m = 0
                        e = eMax
                      } else if (e + eBias >= 1) {
                        m = ((value * c) - 1) * Math.pow(2, mLen)
                        e = e + eBias
                      } else {
                        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                        e = 0
                      }
                    }

                    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

                    e = (e << mLen) | m
                    eLen += mLen
                    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

                    buffer[offset + i - d] |= s * 128
                  }
                };

                const customInspectSymbol =
                  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
                    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
                    : null

                const exports = {};
                exports.Buffer = Buffer
                exports.SlowBuffer = SlowBuffer
                exports.INSPECT_MAX_BYTES = 50

                const K_MAX_LENGTH = 0x7fffffff
                exports.kMaxLength = K_MAX_LENGTH

                /**
                 * Not used internally, but exported to maintain api compatability
                 * Uses 32-bit implementation value from Node defined in String:kMaxLength
                 *
                 * @see https://github.com/nodejs/node/blob/main/deps/v8/include/v8-primitive.h#L126
                 * @see https://github.com/nodejs/node/blob/main/src/node_buffer.cc#L1298
                 * @see https://github.com/nodejs/node/blob/main/lib/buffer.js#L142
                 */
                const K_STRING_MAX_LENGTH = (1 << 28) - 16
                exports.kStringMaxLength = K_STRING_MAX_LENGTH

                exports.constants = {
                  MAX_LENGTH: K_MAX_LENGTH,
                  MAX_STRING_LENGTH: K_STRING_MAX_LENGTH
                }

                exports.Blob = typeof Blob !== 'undefined' ? Blob : undefined
                exports.File = typeof File !== 'undefined' ? File : undefined
                exports.atob = typeof atob !== 'undefined' ? atob : undefined
                exports.btoa = typeof btoa !== 'undefined' ? btoa : undefined

                /**
                 * If `Buffer.TYPED_ARRAY_SUPPORT`:
                 *   === true    Use Uint8Array implementation (fastest)
                 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
                 *               implementation (most compatible, even IE6)
                 *
                 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
                 * Opera 11.6+, iOS 4.2+.
                 *
                 * We report that the browser does not support typed arrays if the are not subclassable
                 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
                 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
                 * for __proto__ and has a buggy typed array implementation.
                 */
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
                    typeof console.error === 'function') {
                  console.error(
                    'This browser lacks typed array (Uint8Array) support which is required by ' +
                    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
                  )
                }

                function typedArraySupport () {
                  // Can typed array instances be augmented?
                  try {
                    const arr = new Uint8Array(1)
                    const proto = { foo: function () { return 42 } }
                    Object.setPrototypeOf(proto, Uint8Array.prototype)
                    Object.setPrototypeOf(arr, proto)
                    return arr.foo() === 42
                  } catch (e) {
                    return false
                  }
                }

                Object.defineProperty(Buffer.prototype, 'parent', {
                  enumerable: true,
                  get: function () {
                    if (!Buffer.isBuffer(this)) return undefined
                    return this.buffer
                  }
                })

                Object.defineProperty(Buffer.prototype, 'offset', {
                  enumerable: true,
                  get: function () {
                    if (!Buffer.isBuffer(this)) return undefined
                    return this.byteOffset
                  }
                })

                function createBuffer (length) {
                  if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"')
                  }
                  // Return an augmented `Uint8Array` instance
                  const buf = new Uint8Array(length)
                  Object.setPrototypeOf(buf, Buffer.prototype)
                  return buf
                }

                /**
                 * The Buffer constructor returns instances of `Uint8Array` that have their
                 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
                 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
                 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
                 * returns a single octet.
                 *
                 * The `Uint8Array` prototype remains unmodified.
                 */

                function Buffer (arg, encodingOrOffset, length) {
                  // Common case.
                  if (typeof arg === 'number') {
                    if (typeof encodingOrOffset === 'string') {
                      throw new TypeError(
                        'The "string" argument must be of type string. Received type number'
                      )
                    }
                    return allocUnsafe(arg)
                  }
                  return from(arg, encodingOrOffset, length)
                }

                Buffer.poolSize = 8192 // not used by this implementation

                function from (value, encodingOrOffset, length) {
                  if (typeof value === 'string') {
                    return fromString(value, encodingOrOffset)
                  }

                  if (ArrayBuffer.isView(value)) {
                    return fromArrayView(value)
                  }

                  if (value == null) {
                    throw new TypeError(
                      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                      'or Array-like Object. Received type ' + (typeof value)
                    )
                  }

                  if (isInstance(value, ArrayBuffer) ||
                      (value && isInstance(value.buffer, ArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length)
                  }

                  if (typeof SharedArrayBuffer !== 'undefined' &&
                      (isInstance(value, SharedArrayBuffer) ||
                      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
                    return fromArrayBuffer(value, encodingOrOffset, length)
                  }

                  if (typeof value === 'number') {
                    throw new TypeError(
                      'The "value" argument must not be of type number. Received type number'
                    )
                  }

                  const valueOf = value.valueOf && value.valueOf()
                  if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length)
                  }

                  const b = fromObject(value)
                  if (b) return b

                  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
                      typeof value[Symbol.toPrimitive] === 'function') {
                    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
                  }

                  throw new TypeError(
                    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
                    'or Array-like Object. Received type ' + (typeof value)
                  )
                }

                /**
                 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
                 * if value is a number.
                 * Buffer.from(str[, encoding])
                 * Buffer.from(array)
                 * Buffer.from(buffer)
                 * Buffer.from(arrayBuffer[, byteOffset[, length]])
                 **/
                Buffer.from = function (value, encodingOrOffset, length) {
                  return from(value, encodingOrOffset, length)
                }

                // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
                // https://github.com/feross/buffer/pull/148
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
                Object.setPrototypeOf(Buffer, Uint8Array)

                function assertSize (size) {
                  if (typeof size !== 'number') {
                    throw new TypeError('"size" argument must be of type number')
                  } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"')
                  }
                }

                function alloc (size, fill, encoding) {
                  assertSize(size)
                  if (size <= 0) {
                    return createBuffer(size)
                  }
                  if (fill !== undefined) {
                    // Only pay attention to encoding if it's a string. This
                    // prevents accidentally sending in a number that would
                    // be interpreted as a start offset.
                    return typeof encoding === 'string'
                      ? createBuffer(size).fill(fill, encoding)
                      : createBuffer(size).fill(fill)
                  }
                  return createBuffer(size)
                }

                /**
                 * Creates a new filled Buffer instance.
                 * alloc(size[, fill[, encoding]])
                 **/
                Buffer.alloc = function (size, fill, encoding) {
                  return alloc(size, fill, encoding)
                }

                function allocUnsafe (size) {
                  assertSize(size)
                  return createBuffer(size < 0 ? 0 : checked(size) | 0)
                }

                /**
                 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
                 * */
                Buffer.allocUnsafe = function (size) {
                  return allocUnsafe(size)
                }
                /**
                 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
                 */
                Buffer.allocUnsafeSlow = function (size) {
                  return allocUnsafe(size)
                }

                function fromString (string, encoding) {
                  if (typeof encoding !== 'string' || encoding === '') {
                    encoding = 'utf8'
                  }

                  if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError('Unknown encoding: ' + encoding)
                  }

                  const length = byteLength(string, encoding) | 0
                  let buf = createBuffer(length)

                  const actual = buf.write(string, encoding)

                  if (actual !== length) {
                    // Writing a hex string, for example, that contains invalid characters will
                    // cause everything after the first invalid character to be ignored. (e.g.
                    // 'abxxcd' will be treated as 'ab')
                    buf = buf.slice(0, actual)
                  }

                  return buf
                }

                function fromArrayLike (array) {
                  const length = array.length < 0 ? 0 : checked(array.length) | 0
                  const buf = createBuffer(length)
                  for (let i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255
                  }
                  return buf
                }

                function fromArrayView (arrayView) {
                  if (isInstance(arrayView, Uint8Array)) {
                    const copy = new Uint8Array(arrayView)
                    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
                  }
                  return fromArrayLike(arrayView)
                }

                function fromArrayBuffer (array, byteOffset, length) {
                  if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds')
                  }

                  if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds')
                  }

                  let buf
                  if (byteOffset === undefined && length === undefined) {
                    buf = new Uint8Array(array)
                  } else if (length === undefined) {
                    buf = new Uint8Array(array, byteOffset)
                  } else {
                    buf = new Uint8Array(array, byteOffset, length)
                  }

                  // Return an augmented `Uint8Array` instance
                  Object.setPrototypeOf(buf, Buffer.prototype)

                  return buf
                }

                function fromObject (obj) {
                  if (Buffer.isBuffer(obj)) {
                    // Note: Probably not necessary anymore.
                    const len = checked(obj.length) | 0
                    const buf = createBuffer(len)

                    if (buf.length === 0) {
                      return buf
                    }

                    obj.copy(buf, 0, 0, len)
                    return buf
                  }

                  if (obj.length !== undefined) {
                    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                      return createBuffer(0)
                    }
                    return fromArrayLike(obj)
                  }

                  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data)
                  }
                }

                function checked (length) {
                  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
                  // length is NaN (which is otherwise coerced to zero.)
                  if (length >= K_MAX_LENGTH) {
                    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
                  }
                  return length | 0
                }

                function SlowBuffer (length) {
                  if (+length != length) { // eslint-disable-line eqeqeq
                    length = 0
                  }
                  return Buffer.alloc(+length)
                }

                Buffer.isBuffer = function isBuffer (b) {
                  return b != null && b._isBuffer === true &&
                    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
                }

                Buffer.compare = function compare (a, b) {
                  if (!isInstance(a, Uint8Array) || !isInstance(b, Uint8Array)) {
                    throw new TypeError(
                      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                    )
                  }

                  if (a === b) return 0

                  let x = a.length
                  let y = b.length

                  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                      x = a[i]
                      y = b[i]
                      break
                    }
                  }

                  if (x < y) return -1
                  if (y < x) return 1
                  return 0
                }

                Buffer.isEncoding = function isEncoding (encoding) {
                  switch (String(encoding).toLowerCase()) {
                    case 'hex':
                    case 'utf8':
                    case 'utf-8':
                    case 'ascii':
                    case 'latin1':
                    case 'binary':
                    case 'base64':
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                      return true
                    default:
                      return false
                  }
                }

                Buffer.concat = function concat (list, length) {
                  if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers')
                  }

                  if (list.length === 0) {
                    return Buffer.alloc(0)
                  }

                  let i
                  if (length === undefined) {
                    length = 0
                    for (i = 0; i < list.length; ++i) {
                      length += list[i].length
                    }
                  }

                  const buffer = Buffer.allocUnsafe(length)
                  let pos = 0
                  for (i = 0; i < list.length; ++i) {
                    const buf = list[i]
                    if (!isInstance(buf, Uint8Array)) {
                      throw new TypeError('"list" argument must be an Array of Buffers')
                    }
                    if (pos + buf.length > buffer.length) {
                      buffer.set(buf.subarray(0, buffer.length - pos), pos)
                      break
                    }
                    buffer.set(buf, pos)
                    pos += buf.length
                  }
                  return buffer
                }

                function byteLength (string, encoding) {
                  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength
                  }
                  if (typeof SharedArrayBuffer !== 'undefined' &&
                      isInstance(string, SharedArrayBuffer)) {
                    return string.byteLength
                  }
                  if (typeof string !== 'string') {
                    throw new TypeError(
                      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
                      'Received type ' + typeof string
                    )
                  }

                  const len = string.length
                  const mustMatch = (arguments.length > 2 && arguments[2] === true)
                  if (!mustMatch && len === 0) return 0

                  // Use a for loop to avoid recursion
                  let loweredCase = false
                  for (;;) {
                    switch (encoding) {
                      case 'ascii':
                      case 'latin1':
                      case 'binary':
                        return len
                      case 'utf8':
                      case 'utf-8':
                        return utf8ToBytes(string).length
                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return len * 2
                      case 'hex':
                        return len >>> 1
                      case 'base64':
                        return base64ToBytes(string).length
                      default:
                        if (loweredCase) {
                          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                        }
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                    }
                  }
                }
                Buffer.byteLength = byteLength

                function slowToString (encoding, start, end) {
                  let loweredCase = false

                  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
                  // property of a typed array.

                  // This behaves neither like String nor Uint8Array in that we set start/end
                  // to their upper/lower bounds if the value passed is out of range.
                  // undefined is handled specially as per ECMA-262 6th Edition,
                  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
                  if (start === undefined || start < 0) {
                    start = 0
                  }
                  // Return early if start > this.length. Done here to prevent potential uint32
                  // coercion fail below.
                  if (start > this.length) {
                    return ''
                  }

                  if (end === undefined || end > this.length) {
                    end = this.length
                  }

                  if (end <= 0) {
                    return ''
                  }

                  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
                  end >>>= 0
                  start >>>= 0

                  if (end <= start) {
                    return ''
                  }

                  if (!encoding) encoding = 'utf8'

                  while (true) {
                    switch (encoding) {
                      case 'hex':
                        return hexSlice(this, start, end)

                      case 'utf8':
                      case 'utf-8':
                        return utf8Slice(this, start, end)

                      case 'ascii':
                        return asciiSlice(this, start, end)

                      case 'latin1':
                      case 'binary':
                        return latin1Slice(this, start, end)

                      case 'base64':
                        return base64Slice(this, start, end)

                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return utf16leSlice(this, start, end)

                      default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                    }
                  }
                }

                // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
                // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
                // reliably in a browserify context because there could be multiple different
                // copies of the 'buffer' package in use. This method works even for Buffer
                // instances that were created from another copy of the `buffer` package.
                // See: https://github.com/feross/buffer/issues/154
                Buffer.prototype._isBuffer = true

                function swap (b, n, m) {
                  const i = b[n]
                  b[n] = b[m]
                  b[m] = i
                }

                Buffer.prototype.swap16 = function swap16 () {
                  const len = this.length
                  if (len % 2 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 16-bits')
                  }
                  for (let i = 0; i < len; i += 2) {
                    swap(this, i, i + 1)
                  }
                  return this
                }

                Buffer.prototype.swap32 = function swap32 () {
                  const len = this.length
                  if (len % 4 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 32-bits')
                  }
                  for (let i = 0; i < len; i += 4) {
                    swap(this, i, i + 3)
                    swap(this, i + 1, i + 2)
                  }
                  return this
                }

                Buffer.prototype.swap64 = function swap64 () {
                  const len = this.length
                  if (len % 8 !== 0) {
                    throw new RangeError('Buffer size must be a multiple of 64-bits')
                  }
                  for (let i = 0; i < len; i += 8) {
                    swap(this, i, i + 7)
                    swap(this, i + 1, i + 6)
                    swap(this, i + 2, i + 5)
                    swap(this, i + 3, i + 4)
                  }
                  return this
                }

                Buffer.prototype.toString = function toString () {
                  const length = this.length
                  if (length === 0) return ''
                  if (arguments.length === 0) return utf8Slice(this, 0, length)
                  return slowToString.apply(this, arguments)
                }

                Buffer.prototype.toLocaleString = Buffer.prototype.toString

                Buffer.prototype.equals = function equals (b) {
                  if (this === b) return true
                  return Buffer.compare(this, b) === 0
                }

                Buffer.prototype.inspect = function inspect () {
                  let str = ''
                  const max = exports.INSPECT_MAX_BYTES
                  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
                  if (this.length > max) str += ' ... '
                  return '<Buffer ' + str + '>'
                }
                if (customInspectSymbol) {
                  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
                }

                Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
                  if (!isInstance(target, Uint8Array)) {
                    throw new TypeError(
                      'The "target" argument must be one of type Buffer or Uint8Array. ' +
                      'Received type ' + (typeof target)
                    )
                  }

                  if (start === undefined) {
                    start = 0
                  }
                  if (end === undefined) {
                    end = target ? target.length : 0
                  }
                  if (thisStart === undefined) {
                    thisStart = 0
                  }
                  if (thisEnd === undefined) {
                    thisEnd = this.length
                  }

                  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError('out of range index')
                  }

                  if (thisStart >= thisEnd && start >= end) {
                    return 0
                  }
                  if (thisStart >= thisEnd) {
                    return -1
                  }
                  if (start >= end) {
                    return 1
                  }

                  start >>>= 0
                  end >>>= 0
                  thisStart >>>= 0
                  thisEnd >>>= 0

                  if (this === target) return 0

                  let x = thisEnd - thisStart
                  let y = end - start
                  const len = Math.min(x, y)

                  for (let i = 0; i < len; ++i) {
                    if (this[thisStart + i] !== target[start + i]) {
                      x = this[thisStart + i]
                      y = target[start + i]
                      break
                    }
                  }

                  if (x < y) return -1
                  if (y < x) return 1
                  return 0
                }

                // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
                // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
                //
                // Arguments:
                // - buffer - a Buffer to search
                // - val - a string, Buffer, or number
                // - byteOffset - an index into `buffer`; will be clamped to an int32
                // - encoding - an optional encoding, relevant is val is a string
                // - dir - true for indexOf, false for lastIndexOf
                function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
                  // Empty buffer means no match
                  if (buffer.length === 0) return -1

                  // Normalize byteOffset
                  if (typeof byteOffset === 'string') {
                    encoding = byteOffset
                    byteOffset = 0
                  } else if (byteOffset > 0x7fffffff) {
                    byteOffset = 0x7fffffff
                  } else if (byteOffset < -0x80000000) {
                    byteOffset = -0x80000000
                  }
                  byteOffset = +byteOffset // Coerce to Number.
                  if (numberIsNaN(byteOffset)) {
                    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
                    byteOffset = dir ? 0 : (buffer.length - 1)
                  }

                  // Normalize byteOffset: negative offsets start from the end of the buffer
                  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
                  if (byteOffset >= buffer.length) {
                    if (dir) return -1
                    else byteOffset = buffer.length - 1
                  } else if (byteOffset < 0) {
                    if (dir) byteOffset = 0
                    else return -1
                  }

                  // Normalize val
                  if (typeof val === 'string') {
                    val = Buffer.from(val, encoding)
                  }

                  // Finally, search either indexOf (if dir is true) or lastIndexOf
                  if (Buffer.isBuffer(val)) {
                    // Special case: looking for empty string/buffer always fails
                    if (val.length === 0) {
                      return -1
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
                  } else if (typeof val === 'number') {
                    val = val & 0xFF // Search for a byte value [0-255]
                    if (typeof Uint8Array.prototype.indexOf === 'function') {
                      if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                      } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                      }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
                  }

                  throw new TypeError('val must be string, number or Buffer')
                }

                function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
                  let indexSize = 1
                  let arrLength = arr.length
                  let valLength = val.length

                  if (encoding !== undefined) {
                    encoding = String(encoding).toLowerCase()
                    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                        encoding === 'utf16le' || encoding === 'utf-16le') {
                      if (arr.length < 2 || val.length < 2) {
                        return -1
                      }
                      indexSize = 2
                      arrLength /= 2
                      valLength /= 2
                      byteOffset /= 2
                    }
                  }

                  function read (buf, i) {
                    if (indexSize === 1) {
                      return buf[i]
                    } else {
                      return buf.readUInt16BE(i * indexSize)
                    }
                  }

                  let i
                  if (dir) {
                    let foundIndex = -1
                    for (i = byteOffset; i < arrLength; i++) {
                      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1) foundIndex = i
                        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                      } else {
                        if (foundIndex !== -1) i -= i - foundIndex
                        foundIndex = -1
                      }
                    }
                  } else {
                    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
                    for (i = byteOffset; i >= 0; i--) {
                      let found = true
                      for (let j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                          found = false
                          break
                        }
                      }
                      if (found) return i
                    }
                  }

                  return -1
                }

                Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
                  return this.indexOf(val, byteOffset, encoding) !== -1
                }

                Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
                }

                Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
                }

                function hexWrite (buf, string, offset, length) {
                  offset = Number(offset) || 0
                  const remaining = buf.length - offset
                  if (!length) {
                    length = remaining
                  } else {
                    length = Number(length)
                    if (length > remaining) {
                      length = remaining
                    }
                  }

                  const strLen = string.length

                  if (length > (strLen >>> 1)) {
                    length = strLen >>> 1
                  }

                  for (let i = 0; i < length; ++i) {
                    const a = string.charCodeAt(i * 2 + 0)
                    const b = string.charCodeAt(i * 2 + 1)
                    const hi = hexCharValueTable[a & 0x7f]
                    const lo = hexCharValueTable[b & 0x7f]

                    if ((a | b | hi | lo) & ~0x7f) {
                      return i
                    }

                    buf[offset + i] = (hi << 4) | lo
                  }

                  return length
                }

                function utf8Write (buf, string, offset, length) {
                  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
                }

                function asciiWrite (buf, string, offset, length) {
                  return blitBuffer(asciiToBytes(string), buf, offset, length)
                }

                function base64Write (buf, string, offset, length) {
                  return blitBuffer(base64ToBytes(string), buf, offset, length)
                }

                function ucs2Write (buf, string, offset, length) {
                  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
                }

                Buffer.prototype.write = function write (string, offset, length, encoding) {
                  // Buffer#write(string)
                  if (offset === undefined) {
                    encoding = 'utf8'
                    length = this.length
                    offset = 0
                  // Buffer#write(string, encoding)
                  } else if (length === undefined && typeof offset === 'string') {
                    encoding = offset
                    length = this.length
                    offset = 0
                  // Buffer#write(string, offset[, length][, encoding])
                  } else if (isFinite(offset)) {
                    offset = offset >>> 0
                    if (isFinite(length)) {
                      length = length >>> 0
                      if (encoding === undefined) encoding = 'utf8'
                    } else {
                      encoding = length
                      length = undefined
                    }
                  } else {
                    throw new Error(
                      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
                    )
                  }

                  const remaining = this.length - offset
                  if (length === undefined || length > remaining) length = remaining

                  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                    throw new RangeError('Attempt to write outside buffer bounds')
                  }

                  if (!encoding) encoding = 'utf8'

                  let loweredCase = false
                  for (;;) {
                    switch (encoding) {
                      case 'hex':
                        return hexWrite(this, string, offset, length)

                      case 'utf8':
                      case 'utf-8':
                        return utf8Write(this, string, offset, length)

                      case 'ascii':
                      case 'latin1':
                      case 'binary':
                        return asciiWrite(this, string, offset, length)

                      case 'base64':
                        // Warning: maxLength not taken into account in base64Write
                        return base64Write(this, string, offset, length)

                      case 'ucs2':
                      case 'ucs-2':
                      case 'utf16le':
                      case 'utf-16le':
                        return ucs2Write(this, string, offset, length)

                      default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                    }
                  }
                }

                Buffer.prototype.toJSON = function toJSON () {
                  return {
                    type: 'Buffer',
                    data: Array.prototype.slice.call(this, 0)
                  }
                }

                function base64Slice (buf, start, end) {
                  if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf)
                  } else {
                    return base64.fromByteArray(buf.slice(start, end))
                  }
                }

                function utf8Slice (buf, start, end) {
                  end = Math.min(buf.length, end)
                  const res = []

                  let i = start
                  while (i < end) {
                    const firstByte = buf[i]
                    let codePoint = null
                    let bytesPerSequence = (firstByte > 0xEF)
                      ? 4
                      : (firstByte > 0xDF)
                          ? 3
                          : (firstByte > 0xBF)
                              ? 2
                              : 1

                    if (i + bytesPerSequence <= end) {
                      let secondByte, thirdByte, fourthByte, tempCodePoint

                      switch (bytesPerSequence) {
                        case 1:
                          if (firstByte < 0x80) {
                            codePoint = firstByte
                          }
                          break
                        case 2:
                          secondByte = buf[i + 1]
                          if ((secondByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                            if (tempCodePoint > 0x7F) {
                              codePoint = tempCodePoint
                            }
                          }
                          break
                        case 3:
                          secondByte = buf[i + 1]
                          thirdByte = buf[i + 2]
                          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                              codePoint = tempCodePoint
                            }
                          }
                          break
                        case 4:
                          secondByte = buf[i + 1]
                          thirdByte = buf[i + 2]
                          fourthByte = buf[i + 3]
                          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                              codePoint = tempCodePoint
                            }
                          }
                      }
                    }

                    if (codePoint === null) {
                      // we did not generate a valid codePoint so insert a
                      // replacement char (U+FFFD) and advance only 1 byte
                      codePoint = 0xFFFD
                      bytesPerSequence = 1
                    } else if (codePoint > 0xFFFF) {
                      // encode to utf16 (surrogate pair dance)
                      codePoint -= 0x10000
                      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                      codePoint = 0xDC00 | codePoint & 0x3FF
                    }

                    res.push(codePoint)
                    i += bytesPerSequence
                  }

                  return decodeCodePointsArray(res)
                }

                // Based on http://stackoverflow.com/a/22747272/680742, the browser with
                // the lowest limit is Chrome, with 0x10000 args.
                // We go 1 magnitude less, for safety
                const MAX_ARGUMENTS_LENGTH = 0x1000

                function decodeCodePointsArray (codePoints) {
                  const len = codePoints.length
                  if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
                  }

                  // Decode in chunks to avoid "call stack size exceeded".
                  let res = ''
                  let i = 0
                  while (i < len) {
                    res += String.fromCharCode.apply(
                      String,
                      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                    )
                  }
                  return res
                }

                function asciiSlice (buf, start, end) {
                  let ret = ''
                  end = Math.min(buf.length, end)

                  for (let i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 0x7F)
                  }
                  return ret
                }

                function latin1Slice (buf, start, end) {
                  let ret = ''
                  end = Math.min(buf.length, end)

                  for (let i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i])
                  }
                  return ret
                }

                function hexSlice (buf, start, end) {
                  const len = buf.length

                  if (!start || start < 0) start = 0
                  if (!end || end < 0 || end > len) end = len

                  let out = ''
                  for (let i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]]
                  }
                  return out
                }

                function utf16leSlice (buf, start, end) {
                  const bytes = buf.slice(start, end)
                  let res = ''
                  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
                  for (let i = 0; i < bytes.length - 1; i += 2) {
                    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
                  }
                  return res
                }

                Buffer.prototype.slice = function slice (start, end) {
                  const len = this.length
                  start = ~~start
                  end = end === undefined ? len : ~~end

                  if (start < 0) {
                    start += len
                    if (start < 0) start = 0
                  } else if (start > len) {
                    start = len
                  }

                  if (end < 0) {
                    end += len
                    if (end < 0) end = 0
                  } else if (end > len) {
                    end = len
                  }

                  if (end < start) end = start

                  const newBuf = this.subarray(start, end)
                  // Return an augmented `Uint8Array` instance
                  Object.setPrototypeOf(newBuf, Buffer.prototype)

                  return newBuf
                }

                /*
                 * Need to make sure that buffer isn't trying to write out of bounds.
                 */
                function checkOffset (offset, ext, length) {
                  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
                  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
                }

                Buffer.prototype.readUintLE =
                Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) checkOffset(offset, byteLength, this.length)

                  let val = this[offset]
                  let mul = 1
                  let i = 0
                  while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                  }

                  return val
                }

                Buffer.prototype.readUintBE =
                Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) {
                    checkOffset(offset, byteLength, this.length)
                  }

                  let val = this[offset + --byteLength]
                  let mul = 1
                  while (byteLength > 0 && (mul *= 0x100)) {
                    val += this[offset + --byteLength] * mul
                  }

                  return val
                }

                Buffer.prototype.readUint8 =
                Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 1, this.length)
                  return this[offset]
                }

                Buffer.prototype.readUint16LE =
                Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 2, this.length)
                  return this[offset] | (this[offset + 1] << 8)
                }

                Buffer.prototype.readUint16BE =
                Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 2, this.length)
                  return (this[offset] << 8) | this[offset + 1]
                }

                Buffer.prototype.readUint32LE =
                Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)

                  return ((this[offset]) |
                      (this[offset + 1] << 8) |
                      (this[offset + 2] << 16)) +
                      (this[offset + 3] * 0x1000000)
                }

                Buffer.prototype.readUint32BE =
                Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)

                  return (this[offset] * 0x1000000) +
                    ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
                }

                Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
                  offset = offset >>> 0
                  validateNumber(offset, 'offset')
                  const first = this[offset]
                  const last = this[offset + 7]
                  if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8)
                  }

                  const lo = first +
                    this[++offset] * 2 ** 8 +
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 24

                  const hi = this[++offset] +
                    this[++offset] * 2 ** 8 +
                    this[++offset] * 2 ** 16 +
                    last * 2 ** 24

                  return BigInt(lo) + (BigInt(hi) << BigInt(32))
                })

                Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
                  offset = offset >>> 0
                  validateNumber(offset, 'offset')
                  const first = this[offset]
                  const last = this[offset + 7]
                  if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8)
                  }

                  const hi = first * 2 ** 24 +
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 8 +
                    this[++offset]

                  const lo = this[++offset] * 2 ** 24 +
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 8 +
                    last

                  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
                })

                Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) checkOffset(offset, byteLength, this.length)

                  let val = this[offset]
                  let mul = 1
                  let i = 0
                  while (++i < byteLength && (mul *= 0x100)) {
                    val += this[offset + i] * mul
                  }
                  mul *= 0x80

                  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                  return val
                }

                Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) checkOffset(offset, byteLength, this.length)

                  let i = byteLength
                  let mul = 1
                  let val = this[offset + --i]
                  while (i > 0 && (mul *= 0x100)) {
                    val += this[offset + --i] * mul
                  }
                  mul *= 0x80

                  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

                  return val
                }

                Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 1, this.length)
                  if (!(this[offset] & 0x80)) return (this[offset])
                  return ((0xff - this[offset] + 1) * -1)
                }

                Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 2, this.length)
                  const val = this[offset] | (this[offset + 1] << 8)
                  return (val & 0x8000) ? val | 0xFFFF0000 : val
                }

                Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 2, this.length)
                  const val = this[offset + 1] | (this[offset] << 8)
                  return (val & 0x8000) ? val | 0xFFFF0000 : val
                }

                Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)

                  return (this[offset]) |
                    (this[offset + 1] << 8) |
                    (this[offset + 2] << 16) |
                    (this[offset + 3] << 24)
                }

                Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)

                  return (this[offset] << 24) |
                    (this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    (this[offset + 3])
                }

                Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
                  offset = offset >>> 0
                  validateNumber(offset, 'offset')
                  const first = this[offset]
                  const last = this[offset + 7]
                  if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8)
                  }

                  const val = this[offset + 4] +
                    this[offset + 5] * 2 ** 8 +
                    this[offset + 6] * 2 ** 16 +
                    (last << 24) // Overflow

                  return (BigInt(val) << BigInt(32)) +
                    BigInt(first +
                    this[++offset] * 2 ** 8 +
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 24)
                })

                Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
                  offset = offset >>> 0
                  validateNumber(offset, 'offset')
                  const first = this[offset]
                  const last = this[offset + 7]
                  if (first === undefined || last === undefined) {
                    boundsError(offset, this.length - 8)
                  }

                  const val = (first << 24) + // Overflow
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 8 +
                    this[++offset]

                  return (BigInt(val) << BigInt(32)) +
                    BigInt(this[++offset] * 2 ** 24 +
                    this[++offset] * 2 ** 16 +
                    this[++offset] * 2 ** 8 +
                    last)
                })

                Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)
                  return ieee754.read(this, offset, true, 23, 4)
                }

                Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 4, this.length)
                  return ieee754.read(this, offset, false, 23, 4)
                }

                Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 8, this.length)
                  return ieee754.read(this, offset, true, 52, 8)
                }

                Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
                  offset = offset >>> 0
                  if (!noAssert) checkOffset(offset, 8, this.length)
                  return ieee754.read(this, offset, false, 52, 8)
                }

                function checkInt (buf, value, offset, ext, max, min) {
                  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
                  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
                  if (offset + ext > buf.length) throw new RangeError('Index out of range')
                }

                Buffer.prototype.writeUintLE =
                Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                  }

                  let mul = 1
                  let i = 0
                  this[offset] = value & 0xFF
                  while (++i < byteLength && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                  }

                  return offset + byteLength
                }

                Buffer.prototype.writeUintBE =
                Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  byteLength = byteLength >>> 0
                  if (!noAssert) {
                    const maxBytes = Math.pow(2, 8 * byteLength) - 1
                    checkInt(this, value, offset, byteLength, maxBytes, 0)
                  }

                  let i = byteLength - 1
                  let mul = 1
                  this[offset + i] = value & 0xFF
                  while (--i >= 0 && (mul *= 0x100)) {
                    this[offset + i] = (value / mul) & 0xFF
                  }

                  return offset + byteLength
                }

                Buffer.prototype.writeUint8 =
                Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
                  this[offset] = (value & 0xff)
                  return offset + 1
                }

                Buffer.prototype.writeUint16LE =
                Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                  this[offset] = (value & 0xff)
                  this[offset + 1] = (value >>> 8)
                  return offset + 2
                }

                Buffer.prototype.writeUint16BE =
                Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
                  this[offset] = (value >>> 8)
                  this[offset + 1] = (value & 0xff)
                  return offset + 2
                }

                Buffer.prototype.writeUint32LE =
                Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                  this[offset + 3] = (value >>> 24)
                  this[offset + 2] = (value >>> 16)
                  this[offset + 1] = (value >>> 8)
                  this[offset] = (value & 0xff)
                  return offset + 4
                }

                Buffer.prototype.writeUint32BE =
                Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
                  this[offset] = (value >>> 24)
                  this[offset + 1] = (value >>> 16)
                  this[offset + 2] = (value >>> 8)
                  this[offset + 3] = (value & 0xff)
                  return offset + 4
                }

                function wrtBigUInt64LE (buf, value, offset, min, max) {
                  checkIntBI(value, min, max, buf, offset, 7)

                  let lo = Number(value & BigInt(0xffffffff))
                  buf[offset++] = lo
                  lo = lo >> 8
                  buf[offset++] = lo
                  lo = lo >> 8
                  buf[offset++] = lo
                  lo = lo >> 8
                  buf[offset++] = lo
                  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
                  buf[offset++] = hi
                  hi = hi >> 8
                  buf[offset++] = hi
                  hi = hi >> 8
                  buf[offset++] = hi
                  hi = hi >> 8
                  buf[offset++] = hi
                  return offset
                }

                function wrtBigUInt64BE (buf, value, offset, min, max) {
                  checkIntBI(value, min, max, buf, offset, 7)

                  let lo = Number(value & BigInt(0xffffffff))
                  buf[offset + 7] = lo
                  lo = lo >> 8
                  buf[offset + 6] = lo
                  lo = lo >> 8
                  buf[offset + 5] = lo
                  lo = lo >> 8
                  buf[offset + 4] = lo
                  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
                  buf[offset + 3] = hi
                  hi = hi >> 8
                  buf[offset + 2] = hi
                  hi = hi >> 8
                  buf[offset + 1] = hi
                  hi = hi >> 8
                  buf[offset] = hi
                  return offset + 8
                }

                Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
                  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
                })

                Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
                  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
                })

                Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) {
                    const limit = Math.pow(2, (8 * byteLength) - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                  }

                  let i = 0
                  let mul = 1
                  let sub = 0
                  this[offset] = value & 0xFF
                  while (++i < byteLength && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                      sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                  }

                  return offset + byteLength
                }

                Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) {
                    const limit = Math.pow(2, (8 * byteLength) - 1)

                    checkInt(this, value, offset, byteLength, limit - 1, -limit)
                  }

                  let i = byteLength - 1
                  let mul = 1
                  let sub = 0
                  this[offset + i] = value & 0xFF
                  while (--i >= 0 && (mul *= 0x100)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                      sub = 1
                    }
                    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
                  }

                  return offset + byteLength
                }

                Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
                  if (value < 0) value = 0xff + value + 1
                  this[offset] = (value & 0xff)
                  return offset + 1
                }

                Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                  this[offset] = (value & 0xff)
                  this[offset + 1] = (value >>> 8)
                  return offset + 2
                }

                Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
                  this[offset] = (value >>> 8)
                  this[offset + 1] = (value & 0xff)
                  return offset + 2
                }

                Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                  this[offset] = (value & 0xff)
                  this[offset + 1] = (value >>> 8)
                  this[offset + 2] = (value >>> 16)
                  this[offset + 3] = (value >>> 24)
                  return offset + 4
                }

                Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
                  if (value < 0) value = 0xffffffff + value + 1
                  this[offset] = (value >>> 24)
                  this[offset + 1] = (value >>> 16)
                  this[offset + 2] = (value >>> 8)
                  this[offset + 3] = (value & 0xff)
                  return offset + 4
                }

                Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
                  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
                })

                Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
                  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
                })

                function checkIEEE754 (buf, value, offset, ext, max, min) {
                  if (offset + ext > buf.length) throw new RangeError('Index out of range')
                  if (offset < 0) throw new RangeError('Index out of range')
                }

                function writeFloat (buf, value, offset, littleEndian, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
                  }
                  ieee754.write(buf, value, offset, littleEndian, 23, 4)
                  return offset + 4
                }

                Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
                  return writeFloat(this, value, offset, true, noAssert)
                }

                Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
                  return writeFloat(this, value, offset, false, noAssert)
                }

                function writeDouble (buf, value, offset, littleEndian, noAssert) {
                  value = +value
                  offset = offset >>> 0
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
                  }
                  ieee754.write(buf, value, offset, littleEndian, 52, 8)
                  return offset + 8
                }

                Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
                  return writeDouble(this, value, offset, true, noAssert)
                }

                Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
                  return writeDouble(this, value, offset, false, noAssert)
                }

                // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
                Buffer.prototype.copy = function copy (target, targetStart, start, end) {
                  if (!isInstance(target, Uint8Array)) throw new TypeError('argument should be a Buffer')
                  if (!start) start = 0
                  if (!end && end !== 0) end = this.length
                  if (targetStart >= target.length) targetStart = target.length
                  if (!targetStart) targetStart = 0
                  if (end > 0 && end < start) end = start

                  // Copy 0 bytes; we're done
                  if (end === start) return 0
                  if (target.length === 0 || this.length === 0) return 0

                  // Fatal error conditions
                  if (targetStart < 0) {
                    throw new RangeError('targetStart out of bounds')
                  }
                  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
                  if (end < 0) throw new RangeError('sourceEnd out of bounds')

                  // Are we oob?
                  if (end > this.length) end = this.length
                  if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start
                  }

                  const len = end - start

                  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
                    // Use built-in when available, missing from IE11
                    this.copyWithin(targetStart, start, end)
                  } else {
                    Uint8Array.prototype.set.call(
                      target,
                      this.subarray(start, end),
                      targetStart
                    )
                  }

                  return len
                }

                // Usage:
                //    buffer.fill(number[, offset[, end]])
                //    buffer.fill(buffer[, offset[, end]])
                //    buffer.fill(string[, offset[, end]][, encoding])
                Buffer.prototype.fill = function fill (val, start, end, encoding) {
                  // Handle string cases:
                  if (typeof val === 'string') {
                    if (typeof start === 'string') {
                      encoding = start
                      start = 0
                      end = this.length
                    } else if (typeof end === 'string') {
                      encoding = end
                      end = this.length
                    }
                    if (encoding !== undefined && typeof encoding !== 'string') {
                      throw new TypeError('encoding must be a string')
                    }
                    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                      throw new TypeError('Unknown encoding: ' + encoding)
                    }
                    if (val.length === 1) {
                      const code = val.charCodeAt(0)
                      if ((encoding === 'utf8' && code < 128) ||
                          encoding === 'latin1') {
                        // Fast path: If `val` fits into a single byte, use that numeric value.
                        val = code
                      }
                    }
                  } else if (typeof val === 'number') {
                    val = val & 255
                  } else if (typeof val === 'boolean') {
                    val = Number(val)
                  }

                  // Invalid ranges are not set to a default, so can range check early.
                  if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError('Out of range index')
                  }

                  if (end <= start) {
                    return this
                  }

                  start = start >>> 0
                  end = end === undefined ? this.length : end >>> 0

                  if (!val) val = 0

                  let i
                  if (typeof val === 'number') {
                    for (i = start; i < end; ++i) {
                      this[i] = val
                    }
                  } else {
                    const bytes = isInstance(val, Uint8Array)
                      ? val
                      : Buffer.from(val, encoding)
                    const len = bytes.length
                    if (len === 0) {
                      throw new TypeError('The value "' + val +
                        '" is invalid for argument "value"')
                    }
                    for (i = 0; i < end - start; ++i) {
                      this[i + start] = bytes[i % len]
                    }
                  }

                  return this
                }

                // CUSTOM ERRORS
                // =============

                // Simplified versions from Node, changed for Buffer-only usage
                const errors = {}
                function E (sym, getMessage, Base) {
                  function NodeError () {
                    const err = new Base(getMessage.apply(null, arguments))

                    Object.setPrototypeOf(err, NodeError.prototype)

                    // Node.js `err.code` properties are own/enumerable properties.
                    err.code = sym
                    // Add the error code to the name to include it in the stack trace.
                    err.name = `${err.name} [${sym}]`
                    // Remove NodeError from the stack trace.
                    if (Error.captureStackTrace) {
                      Error.captureStackTrace(err, NodeError)
                    }
                    // Access the stack to generate the error message including the error code
                    // from the name.
                    err.stack // eslint-disable-line no-unused-expressions
                    // Reset the name to the actual name.
                    delete err.name

                    return err
                  }

                  Object.setPrototypeOf(NodeError.prototype, Base.prototype)
                  Object.setPrototypeOf(NodeError, Base)

                  NodeError.prototype.toString = function toString () {
                    return `${this.name} [${sym}]: ${this.message}`
                  }

                  errors[sym] = NodeError
                }

                E('ERR_BUFFER_OUT_OF_BOUNDS',
                  function (name) {
                    if (name) {
                      return `${name} is outside of buffer bounds`
                    }

                    return 'Attempt to access memory outside buffer bounds'
                  }, RangeError)
                E('ERR_INVALID_ARG_TYPE',
                  function (name, actual) {
                    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
                  }, TypeError)
                E('ERR_OUT_OF_RANGE',
                  function (str, range, input) {
                    let msg = `The value of "${str}" is out of range.`
                    let received = input
                    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
                      received = addNumericalSeparator(String(input))
                    } else if (typeof input === 'bigint') {
                      received = String(input)
                      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
                        received = addNumericalSeparator(received)
                      }
                      received += 'n'
                    }
                    msg += ` It must be ${range}. Received ${received}`
                    return msg
                  }, RangeError)

                function addNumericalSeparator (val) {
                  let res = ''
                  let i = val.length
                  const start = val[0] === '-' ? 1 : 0
                  for (; i >= start + 4; i -= 3) {
                    res = `_${val.slice(i - 3, i)}${res}`
                  }
                  return `${val.slice(0, i)}${res}`
                }

                // CHECK FUNCTIONS
                // ===============

                function checkBounds (buf, offset, byteLength) {
                  validateNumber(offset, 'offset')
                  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
                    boundsError(offset, buf.length - (byteLength + 1))
                  }
                }

                function checkIntBI (value, min, max, buf, offset, byteLength) {
                  if (value > max || value < min) {
                    const n = typeof min === 'bigint' ? 'n' : ''
                    let range
                    if (byteLength > 3) {
                      if (min === 0 || min === BigInt(0)) {
                        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
                      } else {
                        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                                `${(byteLength + 1) * 8 - 1}${n}`
                      }
                    } else {
                      range = `>= ${min}${n} and <= ${max}${n}`
                    }
                    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
                  }
                  checkBounds(buf, offset, byteLength)
                }

                function validateNumber (value, name) {
                  if (typeof value !== 'number') {
                    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
                  }
                }

                function boundsError (value, length, type) {
                  if (Math.floor(value) !== value) {
                    validateNumber(value, type)
                    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
                  }

                  if (length < 0) {
                    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
                  }

                  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                                    value)
                }

                // HELPER FUNCTIONS
                // ================

                const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

                function base64clean (str) {
                  // Node takes equal signs as end of the Base64 encoding
                  str = str.split('=')[0]
                  // Node strips out invalid characters like \n and \t from the string, base64-js does not
                  str = str.trim().replace(INVALID_BASE64_RE, '')
                  // Node converts strings with length < 2 to ''
                  if (str.length < 2) return ''
                  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
                  while (str.length % 4 !== 0) {
                    str = str + '='
                  }
                  return str
                }

                function utf8ToBytes (string, units) {
                  units = units || Infinity
                  let codePoint
                  const length = string.length
                  let leadSurrogate = null
                  const bytes = []

                  for (let i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i)

                    // is surrogate component
                    if (codePoint > 0xD7FF && codePoint < 0xE000) {
                      // last char was a lead
                      if (!leadSurrogate) {
                        // no lead yet
                        if (codePoint > 0xDBFF) {
                          // unexpected trail
                          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                          continue
                        } else if (i + 1 === length) {
                          // unpaired lead
                          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                          continue
                        }

                        // valid lead
                        leadSurrogate = codePoint

                        continue
                      }

                      // 2 leads in a row
                      if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = codePoint
                        continue
                      }

                      // valid surrogate pair
                      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                    } else if (leadSurrogate) {
                      // valid bmp char, but last char was a lead
                      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    }

                    leadSurrogate = null

                    // encode utf8
                    if (codePoint < 0x80) {
                      if ((units -= 1) < 0) break
                      bytes.push(codePoint)
                    } else if (codePoint < 0x800) {
                      if ((units -= 2) < 0) break
                      bytes.push(
                        codePoint >> 0x6 | 0xC0,
                        codePoint & 0x3F | 0x80
                      )
                    } else if (codePoint < 0x10000) {
                      if ((units -= 3) < 0) break
                      bytes.push(
                        codePoint >> 0xC | 0xE0,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                      )
                    } else if (codePoint < 0x110000) {
                      if ((units -= 4) < 0) break
                      bytes.push(
                        codePoint >> 0x12 | 0xF0,
                        codePoint >> 0xC & 0x3F | 0x80,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                      )
                    } else {
                      throw new Error('Invalid code point')
                    }
                  }

                  return bytes
                }

                function asciiToBytes (str) {
                  const byteArray = []
                  for (let i = 0; i < str.length; ++i) {
                    // Node's code seems to be doing this and not & 0x7F..
                    byteArray.push(str.charCodeAt(i) & 0xFF)
                  }
                  return byteArray
                }

                function utf16leToBytes (str, units) {
                  let c, hi, lo
                  const byteArray = []
                  for (let i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0) break

                    c = str.charCodeAt(i)
                    hi = c >> 8
                    lo = c % 256
                    byteArray.push(lo)
                    byteArray.push(hi)
                  }

                  return byteArray
                }

                function base64ToBytes (str) {
                  return base64.toByteArray(base64clean(str))
                }

                function blitBuffer (src, dst, offset, length) {
                  let i
                  for (i = 0; i < length; ++i) {
                    if ((i + offset >= dst.length) || (i >= src.length)) break
                    dst[i + offset] = src[i]
                  }
                  return i
                }

                // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
                // the `instanceof` check but they should be treated as of that type.
                // See: https://github.com/feross/buffer/issues/166
                function isInstance (obj, type) {
                  return obj instanceof type ||
                    (obj != null && obj.constructor != null && obj.constructor.name != null &&
                      obj.constructor.name === type.name) ||
                    (type === Uint8Array && Buffer.isBuffer(obj))
                }
                function numberIsNaN (obj) {
                  // For IE11 support
                  return obj !== obj // eslint-disable-line no-self-compare
                }

                // Create lookup table for `toString('hex')`
                // See: https://github.com/feross/buffer/issues/219
                const hexSliceLookupTable = (function () {
                  const alphabet = '0123456789abcdef'
                  const table = new Array(256)
                  for (let i = 0; i < 16; ++i) {
                    const i16 = i * 16
                    for (let j = 0; j < 16; ++j) {
                      table[i16 + j] = alphabet[i] + alphabet[j]
                    }
                  }
                  return table
                })()

                // hex lookup table for Buffer.from(x, 'hex')
                /* eslint-disable no-multi-spaces, indent */
                const hexCharValueTable = [
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                   0,  1,  2,  3,  4,  5,  6,  7,
                   8,  9, -1, -1, -1, -1, -1, -1,
                  -1, 10, 11, 12, 13, 14, 15, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, 10, 11, 12, 13, 14, 15, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1,
                  -1, -1, -1, -1, -1, -1, -1, -1
                ]
                /* eslint-enable no-multi-spaces, indent */

                // Return not function with Error if BigInt not supported
                function defineBigIntMethod (fn) {
                  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
                }

                function BufferBigIntNotDefined () {
                  throw new Error('BigInt not supported')
                }

                return Buffer;
            })();
        </script>
        <script type="text/javascript">
            /**
             * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
             * Original file: /npm/bs58check@3.0.1/index.js
             *
             * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
             */
            var bs58check = (() => {
                function anumber(n) {
                    if (!Number.isSafeInteger(n) || n < 0)
                        throw new Error('positive integer expected, got ' + n);
                }
                // copied from utils
                function isBytes(a) {
                    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
                }
                function abytes(b, ...lengths) {
                    if (!isBytes(b))
                        throw new Error('Uint8Array expected');
                    if (lengths.length > 0 && !lengths.includes(b.length))
                        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
                }
                function ahash(h) {
                    if (typeof h !== 'function' || typeof h.create !== 'function')
                        throw new Error('Hash should be wrapped by utils.wrapConstructor');
                    anumber(h.outputLen);
                    anumber(h.blockLen);
                }
                function aexists(instance, checkFinished = true) {
                    if (instance.destroyed)
                        throw new Error('Hash instance has been destroyed');
                    if (checkFinished && instance.finished)
                        throw new Error('Hash#digest() has already been called');
                }
                function aoutput(out, instance) {
                    abytes(out);
                    const min = instance.outputLen;
                    if (out.length < min) {
                        throw new Error('digestInto() expects output buffer of length at least ' + min);
                    }
                }
                //export { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };
                const assert = {
                    number: anumber,
                    bytes: abytes,
                    hash: ahash,
                    exists: aexists,
                    output: aoutput,
                };

                //# sourceMappingURL=_assert.js.map
                /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
                // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
                // node.js versions earlier than v19 don't declare it in global scope.
                // For node.js, package.json#exports field mapping rewrites import
                // from `crypto` to `cryptoNode`, which imports native module.
                // Makes the utils un-importable in browsers without a bundler.
                // Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
                // export { isBytes } from './_assert.js';
                // We can't reuse isBytes from _assert, because somehow this causes huge perf issues
                // Cast array to different type
                const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
                const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
                // Cast array to view
                const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
                // The rotate right (circular right shift) operation for uint32
                const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
                // The rotate left (circular left shift) operation for uint32
                const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
                const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
                // The byte swap operation for uint32
                const byteSwap = (word) => ((word << 24) & 0xff000000) |
                    ((word << 8) & 0xff0000) |
                    ((word >>> 8) & 0xff00) |
                    ((word >>> 24) & 0xff);
                // Conditionally byte swap if on a big-endian platform
                const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);
                // In place byte swap for Uint32Array
                function byteSwap32(arr) {
                    for (let i = 0; i < arr.length; i++) {
                        arr[i] = byteSwap(arr[i]);
                    }
                }
                // Array where index 0xf0 (240) is mapped to string 'f0'
                const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
                /**
                 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
                 */
                function bytesToHex(bytes) {
                    abytes(bytes);
                    // pre-caching improves the speed 6x
                    let hex = '';
                    for (let i = 0; i < bytes.length; i++) {
                        hex += hexes[bytes[i]];
                    }
                    return hex;
                }
                // We use optimized technique to convert hex string to byte array
                const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
                function asciiToBase16(ch) {
                    if (ch >= asciis._0 && ch <= asciis._9)
                        return ch - asciis._0; // '2' => 50-48
                    if (ch >= asciis.A && ch <= asciis.F)
                        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
                    if (ch >= asciis.a && ch <= asciis.f)
                        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
                    return;
                }
                /**
                 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
                 */
                function hexToBytes(hex) {
                    if (typeof hex !== 'string')
                        throw new Error('hex string expected, got ' + typeof hex);
                    const hl = hex.length;
                    const al = hl / 2;
                    if (hl % 2)
                        throw new Error('hex string expected, got unpadded hex of length ' + hl);
                    const array = new Uint8Array(al);
                    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
                        const n1 = asciiToBase16(hex.charCodeAt(hi));
                        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
                        if (n1 === undefined || n2 === undefined) {
                            const char = hex[hi] + hex[hi + 1];
                            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
                        }
                        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
                    }
                    return array;
                }
                // There is no setImmediate in browser and setTimeout is slow.
                // call of async fn will return Promise, which will be fullfiled only on
                // next scheduler queue processing step and this is exactly what we need.
                const nextTick = async () => { };
                // Returns control to thread each 'tick' ms to avoid blocking
                async function asyncLoop(iters, tick, cb) {
                    let ts = Date.now();
                    for (let i = 0; i < iters; i++) {
                        cb(i);
                        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
                        const diff = Date.now() - ts;
                        if (diff >= 0 && diff < tick)
                            continue;
                        await nextTick();
                        ts += diff;
                    }
                }
                /**
                 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
                 */
                function utf8ToBytes(str) {
                    if (typeof str !== 'string')
                        throw new Error('utf8ToBytes expected string, got ' + typeof str);
                    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
                }
                /**
                 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
                 * Warning: when Uint8Array is passed, it would NOT get copied.
                 * Keep in mind for future mutable operations.
                 */
                function toBytes(data) {
                    if (typeof data === 'string')
                        data = utf8ToBytes(data);
                    abytes(data);
                    return data;
                }
                /**
                 * Copies several Uint8Arrays into one.
                 */
                function concatBytes(...arrays) {
                    let sum = 0;
                    for (let i = 0; i < arrays.length; i++) {
                        const a = arrays[i];
                        abytes(a);
                        sum += a.length;
                    }
                    const res = new Uint8Array(sum);
                    for (let i = 0, pad = 0; i < arrays.length; i++) {
                        const a = arrays[i];
                        res.set(a, pad);
                        pad += a.length;
                    }
                    return res;
                }
                // For runtime check if class implements interface
                class Hash {
                    // Safe version that clones internal state
                    clone() {
                        return this._cloneInto();
                    }
                }
                function checkOpts(defaults, opts) {
                    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
                        throw new Error('Options should be object or undefined');
                    const merged = Object.assign(defaults, opts);
                    return merged;
                }
                function wrapConstructor(hashCons) {
                    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
                    const tmp = hashCons();
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = () => hashCons();
                    return hashC;
                }
                function wrapConstructorWithOpts(hashCons) {
                    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
                    const tmp = hashCons({});
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = (opts) => hashCons(opts);
                    return hashC;
                }
                function wrapXOFConstructorWithOpts(hashCons) {
                    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
                    const tmp = hashCons({});
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = (opts) => hashCons(opts);
                    return hashC;
                }
                /**
                 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
                 */
                function randomBytes(bytesLength = 32) {
                    if (crypto && typeof crypto.getRandomValues === 'function') {
                        return crypto.getRandomValues(new Uint8Array(bytesLength));
                    }
                    // Legacy Node.js compatibility
                    if (crypto && typeof crypto.randomBytes === 'function') {
                        return crypto.randomBytes(bytesLength);
                    }
                    throw new Error('crypto.getRandomValues must be defined');
                }
                //# sourceMappingURL=utils.js.map

                /**
                 * Polyfill for Safari 14
                 */
                function setBigUint64(view, byteOffset, value, isLE) {
                    if (typeof view.setBigUint64 === 'function')
                        return view.setBigUint64(byteOffset, value, isLE);
                    const _32n = BigInt(32);
                    const _u32_max = BigInt(0xffffffff);
                    const wh = Number((value >> _32n) & _u32_max);
                    const wl = Number(value & _u32_max);
                    const h = isLE ? 4 : 0;
                    const l = isLE ? 0 : 4;
                    view.setUint32(byteOffset + h, wh, isLE);
                    view.setUint32(byteOffset + l, wl, isLE);
                }
                /**
                 * Choice: a ? b : c
                 */
                const Chi = (a, b, c) => (a & b) ^ (~a & c);
                /**
                 * Majority function, true if any two inputs is true
                 */
                const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);

                /**
                 * Merkle-Damgard hash construction base class.
                 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
                 */
                class HashMD extends Hash {
                    constructor(blockLen, outputLen, padOffset, isLE) {
                        super();
                        this.blockLen = blockLen;
                        this.outputLen = outputLen;
                        this.padOffset = padOffset;
                        this.isLE = isLE;
                        this.finished = false;
                        this.length = 0;
                        this.pos = 0;
                        this.destroyed = false;
                        this.buffer = new Uint8Array(blockLen);
                        this.view = createView(this.buffer);
                    }
                    update(data) {
                        aexists(this);
                        const { view, buffer, blockLen } = this;
                        data = toBytes(data);
                        const len = data.length;
                        for (let pos = 0; pos < len;) {
                            const take = Math.min(blockLen - this.pos, len - pos);
                            // Fast path: we have at least one block in input, cast it to view and process
                            if (take === blockLen) {
                                const dataView = createView(data);
                                for (; blockLen <= len - pos; pos += blockLen)
                                    this.process(dataView, pos);
                                continue;
                            }
                            buffer.set(data.subarray(pos, pos + take), this.pos);
                            this.pos += take;
                            pos += take;
                            if (this.pos === blockLen) {
                                this.process(view, 0);
                                this.pos = 0;
                            }
                        }
                        this.length += data.length;
                        this.roundClean();
                        return this;
                    }
                    digestInto(out) {
                        aexists(this);
                        aoutput(out, this);
                        this.finished = true;
                        // Padding
                        // We can avoid allocation of buffer for padding completely if it
                        // was previously not allocated here. But it won't change performance.
                        const { buffer, view, blockLen, isLE } = this;
                        let { pos } = this;
                        // append the bit '1' to the message
                        buffer[pos++] = 0b10000000;
                        this.buffer.subarray(pos).fill(0);
                        // we have less than padOffset left in buffer, so we cannot put length in
                        // current block, need process it and pad again
                        if (this.padOffset > blockLen - pos) {
                            this.process(view, 0);
                            pos = 0;
                        }
                        // Pad until full block byte with zeros
                        for (let i = pos; i < blockLen; i++)
                            buffer[i] = 0;
                        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
                        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
                        // So we just write lowest 64 bits of that value.
                        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
                        this.process(view, 0);
                        const oview = createView(out);
                        const len = this.outputLen;
                        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
                        if (len % 4)
                            throw new Error('_sha2: outputLen should be aligned to 32bit');
                        const outLen = len / 4;
                        const state = this.get();
                        if (outLen > state.length)
                            throw new Error('_sha2: outputLen bigger than state');
                        for (let i = 0; i < outLen; i++)
                            oview.setUint32(4 * i, state[i], isLE);
                    }
                    digest() {
                        const { buffer, outputLen } = this;
                        this.digestInto(buffer);
                        const res = buffer.slice(0, outputLen);
                        this.destroy();
                        return res;
                    }
                    _cloneInto(to) {
                        to || (to = new this.constructor());
                        to.set(...this.get());
                        const { blockLen, buffer, length, finished, destroyed, pos } = this;
                        to.length = length;
                        to.pos = pos;
                        to.finished = finished;
                        to.destroyed = destroyed;
                        if (length % blockLen)
                            to.buffer.set(buffer);
                        return to;
                    }
                }
                //# sourceMappingURL=_md.js.map
                // import { rotl, wrapConstructor } from './utils.js';
                // SHA1 (RFC 3174). It was cryptographically broken: prefer newer algorithms.
                // Initial state
                const SHA1_IV = /* @__PURE__ */ new Uint32Array([
                    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
                ]);
                // Temporary buffer, not used to store anything between runs
                // Named this way because it matches specification.
                const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
                class SHA1 extends HashMD {
                    constructor() {
                        super(64, 20, 8, false);
                        this.A = SHA1_IV[0] | 0;
                        this.B = SHA1_IV[1] | 0;
                        this.C = SHA1_IV[2] | 0;
                        this.D = SHA1_IV[3] | 0;
                        this.E = SHA1_IV[4] | 0;
                    }
                    get() {
                        const { A, B, C, D, E } = this;
                        return [A, B, C, D, E];
                    }
                    set(A, B, C, D, E) {
                        this.A = A | 0;
                        this.B = B | 0;
                        this.C = C | 0;
                        this.D = D | 0;
                        this.E = E | 0;
                    }
                    process(view, offset) {
                        for (let i = 0; i < 16; i++, offset += 4)
                            SHA1_W[i] = view.getUint32(offset, false);
                        for (let i = 16; i < 80; i++)
                            SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
                        // Compression function main loop, 80 rounds
                        let { A, B, C, D, E } = this;
                        for (let i = 0; i < 80; i++) {
                            let F, K;
                            if (i < 20) {
                                F = Chi(B, C, D);
                                K = 0x5a827999;
                            }
                            else if (i < 40) {
                                F = B ^ C ^ D;
                                K = 0x6ed9eba1;
                            }
                            else if (i < 60) {
                                F = Maj(B, C, D);
                                K = 0x8f1bbcdc;
                            }
                            else {
                                F = B ^ C ^ D;
                                K = 0xca62c1d6;
                            }
                            const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;
                            E = D;
                            D = C;
                            C = rotl(B, 30);
                            B = A;
                            A = T;
                        }
                        // Add the compressed chunk to the current hash value
                        A = (A + this.A) | 0;
                        B = (B + this.B) | 0;
                        C = (C + this.C) | 0;
                        D = (D + this.D) | 0;
                        E = (E + this.E) | 0;
                        this.set(A, B, C, D, E);
                    }
                    roundClean() {
                        SHA1_W.fill(0);
                    }
                    destroy() {
                        this.set(0, 0, 0, 0, 0);
                        this.buffer.fill(0);
                    }
                }
                /**
                 * SHA1 (RFC 3174) hash function.
                 * It was cryptographically broken: prefer newer algorithms.
                 * @param message - data that would be hashed
                 */
                const sha1 = /* @__PURE__ */ wrapConstructor(() => new SHA1());

                // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
                // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
                const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
                const Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
                const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
                let idxL = [Id];
                let idxR = [Pi];
                for (let i = 0; i < 4; i++)
                    for (let j of [idxL, idxR])
                        j.push(j[i].map((k) => Rho[k]));
                const shifts = /* @__PURE__ */ [
                    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
                    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
                    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
                    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
                    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
                ].map((i) => new Uint8Array(i));
                const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
                const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
                const Kl = /* @__PURE__ */ new Uint32Array([
                    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
                ]);
                const Kr = /* @__PURE__ */ new Uint32Array([
                    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
                ]);
                // It's called f() in spec.
                function f(group, x, y, z) {
                    if (group === 0)
                        return x ^ y ^ z;
                    else if (group === 1)
                        return (x & y) | (~x & z);
                    else if (group === 2)
                        return (x | ~y) ^ z;
                    else if (group === 3)
                        return (x & z) | (y & ~z);
                    else
                        return x ^ (y | ~z);
                }
                // Temporary buffer, not used to store anything between runs
                const R_BUF = /* @__PURE__ */ new Uint32Array(16);
                class RIPEMD160 extends HashMD {
                    constructor() {
                        super(64, 20, 8, true);
                        this.h0 = 0x67452301 | 0;
                        this.h1 = 0xefcdab89 | 0;
                        this.h2 = 0x98badcfe | 0;
                        this.h3 = 0x10325476 | 0;
                        this.h4 = 0xc3d2e1f0 | 0;
                    }
                    get() {
                        const { h0, h1, h2, h3, h4 } = this;
                        return [h0, h1, h2, h3, h4];
                    }
                    set(h0, h1, h2, h3, h4) {
                        this.h0 = h0 | 0;
                        this.h1 = h1 | 0;
                        this.h2 = h2 | 0;
                        this.h3 = h3 | 0;
                        this.h4 = h4 | 0;
                    }
                    process(view, offset) {
                        for (let i = 0; i < 16; i++, offset += 4)
                            R_BUF[i] = view.getUint32(offset, true);
                        // prettier-ignore
                        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
                        // Instead of iterating 0 to 80, we split it into 5 groups
                        // And use the groups in constants, functions, etc. Much simpler
                        for (let group = 0; group < 5; group++) {
                            const rGroup = 4 - group;
                            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
                            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
                            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
                            for (let i = 0; i < 16; i++) {
                                const tl = (rotl(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
                            }
                            // 2 loops are 10% faster
                            for (let i = 0; i < 16; i++) {
                                const tr = (rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
                            }
                        }
                        // Add the compressed chunk to the current hash value
                        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
                    }
                    roundClean() {
                        R_BUF.fill(0);
                    }
                    destroy() {
                        this.destroyed = true;
                        this.buffer.fill(0);
                        this.set(0, 0, 0, 0, 0);
                    }
                }
                /**
                 * RIPEMD-160 - a hash function from 1990s.
                 * @param message - msg that would be hashed
                 */
                const ripemd160 = /* @__PURE__ */ wrapConstructor(() => new RIPEMD160());
                //# sourceMappingURL=ripemd160.js.map

                // SHA2-256 need to try 2^128 hashes to execute birthday attack.
                // BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.
                // Round constants:
                // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
                // prettier-ignore
                const SHA256_K = /* @__PURE__ */ new Uint32Array([
                    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                ]);
                // Initial state:
                // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
                // prettier-ignore
                const SHA256_IV = /* @__PURE__ */ new Uint32Array([
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                ]);
                // Temporary buffer, not used to store anything between runs
                // Named this way because it matches specification.
                const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
                class SHA256 extends HashMD {
                    constructor() {
                        super(64, 32, 8, false);
                        // We cannot use array here since array allows indexing by variable
                        // which means optimizer/compiler cannot use registers.
                        this.A = SHA256_IV[0] | 0;
                        this.B = SHA256_IV[1] | 0;
                        this.C = SHA256_IV[2] | 0;
                        this.D = SHA256_IV[3] | 0;
                        this.E = SHA256_IV[4] | 0;
                        this.F = SHA256_IV[5] | 0;
                        this.G = SHA256_IV[6] | 0;
                        this.H = SHA256_IV[7] | 0;
                    }
                    get() {
                        const { A, B, C, D, E, F, G, H } = this;
                        return [A, B, C, D, E, F, G, H];
                    }
                    // prettier-ignore
                    set(A, B, C, D, E, F, G, H) {
                        this.A = A | 0;
                        this.B = B | 0;
                        this.C = C | 0;
                        this.D = D | 0;
                        this.E = E | 0;
                        this.F = F | 0;
                        this.G = G | 0;
                        this.H = H | 0;
                    }
                    process(view, offset) {
                        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
                        for (let i = 0; i < 16; i++, offset += 4)
                            SHA256_W[i] = view.getUint32(offset, false);
                        for (let i = 16; i < 64; i++) {
                            const W15 = SHA256_W[i - 15];
                            const W2 = SHA256_W[i - 2];
                            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
                            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
                            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
                        }
                        // Compression function main loop, 64 rounds
                        let { A, B, C, D, E, F, G, H } = this;
                        for (let i = 0; i < 64; i++) {
                            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
                            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
                            const T2 = (sigma0 + Maj(A, B, C)) | 0;
                            H = G;
                            G = F;
                            F = E;
                            E = (D + T1) | 0;
                            D = C;
                            C = B;
                            B = A;
                            A = (T1 + T2) | 0;
                        }
                        // Add the compressed chunk to the current hash value
                        A = (A + this.A) | 0;
                        B = (B + this.B) | 0;
                        C = (C + this.C) | 0;
                        D = (D + this.D) | 0;
                        E = (E + this.E) | 0;
                        F = (F + this.F) | 0;
                        G = (G + this.G) | 0;
                        H = (H + this.H) | 0;
                        this.set(A, B, C, D, E, F, G, H);
                    }
                    roundClean() {
                        SHA256_W.fill(0);
                    }
                    destroy() {
                        this.set(0, 0, 0, 0, 0, 0, 0, 0);
                        this.buffer.fill(0);
                    }
                }
                // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
                class SHA224 extends SHA256 {
                    constructor() {
                        super();
                        this.A = 0xc1059ed8 | 0;
                        this.B = 0x367cd507 | 0;
                        this.C = 0x3070dd17 | 0;
                        this.D = 0xf70e5939 | 0;
                        this.E = 0xffc00b31 | 0;
                        this.F = 0x68581511 | 0;
                        this.G = 0x64f98fa7 | 0;
                        this.H = 0xbefa4fa4 | 0;
                        this.outputLen = 28;
                    }
                }
                /**
                 * SHA2-256 hash function
                 * @param message - data that would be hashed
                 */
                const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
                /**
                 * SHA2-224 hash function
                 */
                const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());
                //# sourceMappingURL=sha256.js.map

                // base-x encoding / decoding
                // Copyright (c) 2018 base-x contributors
                // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
                // Distributed under the MIT software license, see the accompanying
                // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
                function base (ALPHABET) {
                  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
                  var BASE_MAP = new Uint8Array(256)
                  for (var j = 0; j < BASE_MAP.length; j++) {
                    BASE_MAP[j] = 255
                  }
                  for (var i = 0; i < ALPHABET.length; i++) {
                    var x = ALPHABET.charAt(i)
                    var xc = x.charCodeAt(0)
                    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
                    BASE_MAP[xc] = i
                  }
                  var BASE = ALPHABET.length
                  var LEADER = ALPHABET.charAt(0)
                  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
                  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
                  function encode (source) {
                    if (source instanceof Uint8Array) {
                    } else if (ArrayBuffer.isView(source)) {
                      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
                    } else if (Array.isArray(source)) {
                      source = Uint8Array.from(source)
                    }
                    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
                    if (source.length === 0) { return '' }
                        // Skip & count leading zeroes.
                    var zeroes = 0
                    var length = 0
                    var pbegin = 0
                    var pend = source.length
                    while (pbegin !== pend && source[pbegin] === 0) {
                      pbegin++
                      zeroes++
                    }
                        // Allocate enough space in big-endian base58 representation.
                    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
                    var b58 = new Uint8Array(size)
                        // Process the bytes.
                    while (pbegin !== pend) {
                      var carry = source[pbegin]
                            // Apply "b58 = b58 * 256 + ch".
                      var i = 0
                      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
                        carry += (256 * b58[it1]) >>> 0
                        b58[it1] = (carry % BASE) >>> 0
                        carry = (carry / BASE) >>> 0
                      }
                      if (carry !== 0) { throw new Error('Non-zero carry') }
                      length = i
                      pbegin++
                    }
                        // Skip leading zeroes in base58 result.
                    var it2 = size - length
                    while (it2 !== size && b58[it2] === 0) {
                      it2++
                    }
                        // Translate the result into a string.
                    var str = LEADER.repeat(zeroes)
                    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
                    return str
                  }
                  function decodeUnsafe (source) {
                    if (typeof source !== 'string') { throw new TypeError('Expected String') }
                    if (source.length === 0) { return new Uint8Array() }
                    var psz = 0
                        // Skip and count leading '1's.
                    var zeroes = 0
                    var length = 0
                    while (source[psz] === LEADER) {
                      zeroes++
                      psz++
                    }
                        // Allocate enough space in big-endian base256 representation.
                    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
                    var b256 = new Uint8Array(size)
                        // Process the characters.
                    while (source[psz]) {
                            // Decode character
                      var carry = BASE_MAP[source.charCodeAt(psz)]
                            // Invalid character
                      if (carry === 255) { return }
                      var i = 0
                      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
                        carry += (BASE * b256[it3]) >>> 0
                        b256[it3] = (carry % 256) >>> 0
                        carry = (carry / 256) >>> 0
                      }
                      if (carry !== 0) { throw new Error('Non-zero carry') }
                      length = i
                      psz++
                    }
                        // Skip leading zeroes in b256.
                    var it4 = size - length
                    while (it4 !== size && b256[it4] === 0) {
                      it4++
                    }
                    var vch = new Uint8Array(zeroes + (size - it4))
                    var j = zeroes
                    while (it4 !== size) {
                      vch[j++] = b256[it4++]
                    }
                    return vch
                  }
                  function decode (string) {
                    var buffer = decodeUnsafe(string)
                    if (buffer) { return buffer }
                    throw new Error('Non-base' + BASE + ' character')
                  }
                  return {
                    encode: encode,
                    decodeUnsafe: decodeUnsafe,
                    decode: decode
                  }
                }

                var ee = base("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

                var e = sha256;
                var n=ee,t=e;

                const bs58check = function(e){
                    function r(r){
                        var n=r.slice(0,-4),t=r.slice(-4),o=e(n);if(!(t[0]^o[0]|t[1]^o[1]|t[2]^o[2]|t[3]^o[3]))return n
                    }
                    return{
                        encode:function(r){
                            var t=Uint8Array.from(r),o=e(t),a=t.length+4,c=new Uint8Array(a);
                            c.set(t,0);
                            c.set(o.subarray(0,4),t.length);
                            return n.encode(c,a);
                        },
                        decode:function(e){
                            var t = Buffer.from(r(n.decode(e)));
                            if(!t)throw new Error("Invalid checksum");
                            return t;
                        },
                        decodeUnsafe:function(e){
                            var t=n.decodeUnsafe(e);if(t)return r(t)}
                        }
                }((function(e){return t(t(e))}));

                return bs58check;
            })();
        </script>
        <script type="text/javascript">
            /**
             * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
             * Original file: /npm/valibot@0.37.0/dist/index.js
             *
             * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
             */
            var valibot = (() => {
                function awaitAsync() {
                  return {
                    kind: "transformation",
                    type: "await",
                    reference: awaitAsync,
                    async: true,
                    async _run(dataset) {
                      dataset.value = await dataset.value;
                      return dataset;
                    }
                  };
                }

                // src/regex.ts
                var BASE64_REGEX = /^(?:[\da-z+/]{4})*(?:[\da-z+/]{2}==|[\da-z+/]{3}=)?$/iu;
                var BIC_REGEX = /^[A-Z]{6}(?!00)[\dA-Z]{2}(?:[\dA-Z]{3})?$/u;
                var CUID2_REGEX = /^[a-z][\da-z]*$/u;
                var DECIMAL_REGEX = /^\d+$/u;
                var EMAIL_REGEX = /^[\w+-]+(?:\.[\w+-]+)*@[\da-z]+(?:[.-][\da-z]+)*\.[a-z]{2,}$/iu;
                var EMOJI_REGEX = (
                  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives
                  /^(?:[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}))*)+$/u
                );
                var HEXADECIMAL_REGEX = /^(?:0[hx])?[\da-f]+$/iu;
                var HEX_COLOR_REGEX = /^#(?:[\da-f]{3,4}|[\da-f]{6}|[\da-f]{8})$/iu;
                var IMEI_REGEX = /^\d{15}$|^\d{2}-\d{6}-\d{6}-\d$/u;
                var IPV4_REGEX = (
                  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive
                  /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$/u
                );
                var IPV6_REGEX = /^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
                var IP_REGEX = /^(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])(?:\.(?:(?:[1-9]|1\d|2[0-4])?\d|25[0-5])){3}$|^(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:|(?:[\da-f]{1,4}:){1,6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,5}(?::[\da-f]{1,4}){1,2}|(?:[\da-f]{1,4}:){1,4}(?::[\da-f]{1,4}){1,3}|(?:[\da-f]{1,4}:){1,3}(?::[\da-f]{1,4}){1,4}|(?:[\da-f]{1,4}:){1,2}(?::[\da-f]{1,4}){1,5}|[\da-f]{1,4}:(?::[\da-f]{1,4}){1,6}|:(?:(?::[\da-f]{1,4}){1,7}|:)|fe80:(?::[\da-f]{0,4}){0,4}%[\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d)|(?:[\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\d)?\d)\.){3}(?:25[0-5]|(?:2[0-4]|1?\d)?\d))$/iu;
                var ISO_DATE_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])$/u;
                var ISO_DATE_TIME_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
                var ISO_TIME_REGEX = /^(?:0\d|1\d|2[0-3]):[0-5]\d$/u;
                var ISO_TIME_SECOND_REGEX = /^(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}$/u;
                var ISO_TIMESTAMP_REGEX = /^\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\d|0[1-9]|3[01])T(?:0\d|1\d|2[0-3])(?::[0-5]\d){2}(?:\.\d{1,9})?(?:Z|[+-](?:0\d|1\d|2[0-3])(?::?[0-5]\d)?)$/u;
                var ISO_WEEK_REGEX = /^\d{4}-W(?:0[1-9]|[1-4]\d|5[0-3])$/u;
                var MAC48_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$/iu;
                var MAC64_REGEX = /^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
                var MAC_REGEX = /^(?:[\da-f]{2}:){5}[\da-f]{2}$|^(?:[\da-f]{2}-){5}[\da-f]{2}$|^(?:[\da-f]{4}\.){2}[\da-f]{4}$|^(?:[\da-f]{2}:){7}[\da-f]{2}$|^(?:[\da-f]{2}-){7}[\da-f]{2}$|^(?:[\da-f]{4}\.){3}[\da-f]{4}$|^(?:[\da-f]{4}:){3}[\da-f]{4}$/iu;
                var OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;
                var ULID_REGEX = /^[\da-hjkmnp-tv-z]{26}$/iu;
                var UUID_REGEX = /^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu;

                // src/storages/globalConfig/globalConfig.ts
                var store;
                function setGlobalConfig(config2) {
                  store = { ...store, ...config2 };
                }
                function getGlobalConfig(config2) {
                  return {
                    lang: config2?.lang ?? store?.lang,
                    message: config2?.message,
                    abortEarly: config2?.abortEarly ?? store?.abortEarly,
                    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
                  };
                }
                function deleteGlobalConfig() {
                  store = void 0;
                }

                // src/storages/globalMessage/globalMessage.ts
                var store2;
                function setGlobalMessage(message, lang) {
                  if (!store2) store2 = /* @__PURE__ */ new Map();
                  store2.set(lang, message);
                }
                function getGlobalMessage(lang) {
                  return store2?.get(lang);
                }
                function deleteGlobalMessage(lang) {
                  store2?.delete(lang);
                }

                // src/storages/schemaMessage/schemaMessage.ts
                var store3;
                function setSchemaMessage(message, lang) {
                  if (!store3) store3 = /* @__PURE__ */ new Map();
                  store3.set(lang, message);
                }
                function getSchemaMessage(lang) {
                  return store3?.get(lang);
                }
                function deleteSchemaMessage(lang) {
                  store3?.delete(lang);
                }

                // src/storages/specificMessage/specificMessage.ts
                var store4;
                function setSpecificMessage(reference, message, lang) {
                  if (!store4) store4 = /* @__PURE__ */ new Map();
                  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());
                  store4.get(reference).set(lang, message);
                }
                function getSpecificMessage(reference, lang) {
                  return store4?.get(reference)?.get(lang);
                }
                function deleteSpecificMessage(reference, lang) {
                  store4?.get(reference)?.delete(lang);
                }

                // src/utils/_stringify/_stringify.ts
                function _stringify(input) {
                  const type = typeof input;
                  if (type === "string") {
                    return `"${input}"`;
                  }
                  if (type === "number" || type === "bigint" || type === "boolean") {
                    return `${input}`;
                  }
                  if (type === "object" || type === "function") {
                    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
                  }
                  return type;
                }

                // src/utils/_addIssue/_addIssue.ts
                function _addIssue(context, label, dataset, config2, other) {
                  const input = other && "input" in other ? other.input : dataset.value;
                  const expected = other?.expected ?? context.expects ?? null;
                  const received = other?.received ?? _stringify(input);
                  const issue = {
                    kind: context.kind,
                    type: context.type,
                    input,
                    expected,
                    received,
                    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
                    // @ts-expect-error
                    requirement: context.requirement,
                    path: other?.path,
                    issues: other?.issues,
                    lang: config2.lang,
                    abortEarly: config2.abortEarly,
                    abortPipeEarly: config2.abortPipeEarly
                  };
                  const isSchema = context.kind === "schema";
                  const message = other?.message ?? // @ts-expect-error
                  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
                  if (message) {
                    issue.message = typeof message === "function" ? message(issue) : message;
                  }
                  if (isSchema) {
                    dataset.typed = false;
                  }
                  if (dataset.issues) {
                    dataset.issues.push(issue);
                  } else {
                    dataset.issues = [issue];
                  }
                }

                // src/utils/_isLuhnAlgo/_isLuhnAlgo.ts
                var NON_DIGIT_REGEX = /\D/gu;
                function _isLuhnAlgo(input) {
                  const number2 = input.replace(NON_DIGIT_REGEX, "");
                  let length2 = number2.length;
                  let bit = 1;
                  let sum = 0;
                  while (length2) {
                    const value2 = +number2[--length2];
                    bit ^= 1;
                    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;
                  }
                  return sum % 10 === 0;
                }

                // src/utils/_isValidObjectKey/_isValidObjectKey.ts
                function _isValidObjectKey(object2, key) {
                  return Object.hasOwn(object2, key) && key !== "__proto__" && key !== "prototype" && key !== "constructor";
                }

                // src/utils/entriesFromList/entriesFromList.ts
                function entriesFromList(list, schema) {
                  const entries = {};
                  for (const key of list) {
                    entries[key] = schema;
                  }
                  return entries;
                }

                // src/utils/getDotPath/getDotPath.ts
                function getDotPath(issue) {
                  if (issue.path) {
                    let key = "";
                    for (const item of issue.path) {
                      if (typeof item.key === "string" || typeof item.key === "number") {
                        if (key) {
                          key += `.${item.key}`;
                        } else {
                          key += item.key;
                        }
                      } else {
                        return null;
                      }
                    }
                    return key;
                  }
                  return null;
                }

                // src/utils/isOfKind/isOfKind.ts
                function isOfKind(kind, object2) {
                  return object2.kind === kind;
                }

                // src/utils/isOfType/isOfType.ts
                function isOfType(type, object2) {
                  return object2.type === type;
                }

                // src/utils/isValiError/isValiError.ts
                function isValiError(error) {
                  return error instanceof ValiError;
                }

                // src/utils/ValiError/ValiError.ts
                var ValiError = class extends Error {
                  /**
                   * The error issues.
                   */
                  issues;
                  /**
                   * Creates a Valibot error with useful information.
                   *
                   * @param issues The error issues.
                   */
                  constructor(issues) {
                    super(issues[0].message);
                    this.name = "ValiError";
                    this.issues = issues;
                  }
                };

                // src/actions/base64/base64.ts
                function base64(message) {
                  return {
                    kind: "validation",
                    type: "base64",
                    reference: base64,
                    async: false,
                    expects: null,
                    requirement: BASE64_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "Base64", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/bic/bic.ts
                function bic(message) {
                  return {
                    kind: "validation",
                    type: "bic",
                    reference: bic,
                    async: false,
                    expects: null,
                    requirement: BIC_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "BIC", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/brand/brand.ts
                function brand(name) {
                  return {
                    kind: "transformation",
                    type: "brand",
                    reference: brand,
                    async: false,
                    name,
                    _run(dataset) {
                      return dataset;
                    }
                  };
                }

                // src/actions/bytes/bytes.ts
                function bytes(requirement, message) {
                  return {
                    kind: "validation",
                    type: "bytes",
                    reference: bytes,
                    async: false,
                    expects: `${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed) {
                        const length2 = new TextEncoder().encode(dataset.value).length;
                        if (length2 !== this.requirement) {
                          _addIssue(this, "bytes", dataset, config2, {
                            received: `${length2}`
                          });
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/check/check.ts
                function check(requirement, message) {
                  return {
                    kind: "validation",
                    type: "check",
                    reference: check,
                    async: false,
                    expects: null,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "input", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/check/checkAsync.ts
                function checkAsync(requirement, message) {
                  return {
                    kind: "validation",
                    type: "check",
                    reference: checkAsync,
                    async: true,
                    expects: null,
                    requirement,
                    message,
                    async _run(dataset, config2) {
                      if (dataset.typed && !await this.requirement(dataset.value)) {
                        _addIssue(this, "input", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/checkItems/checkItems.ts
                function checkItems(requirement, message) {
                  return {
                    kind: "validation",
                    type: "check_items",
                    reference: checkItems,
                    async: false,
                    expects: null,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed) {
                        for (let index = 0; index < dataset.value.length; index++) {
                          const item = dataset.value[index];
                          if (!this.requirement(item, index, dataset.value)) {
                            _addIssue(this, "item", dataset, config2, {
                              input: item,
                              path: [
                                {
                                  type: "array",
                                  origin: "value",
                                  input: dataset.value,
                                  key: index,
                                  value: item
                                }
                              ]
                            });
                          }
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/creditCard/creditCard.ts
                var CREDIT_CARD_REGEX = /^(?:\d{14,19}|\d{4}(?: \d{3,6}){2,4}|\d{4}(?:-\d{3,6}){2,4})$/u;
                var SANITIZE_REGEX = /[- ]/gu;
                var PROVIDER_REGEX_LIST = [
                  // American Express
                  /^3[47]\d{13}$/u,
                  // Diners Club
                  /^3(?:0[0-5]|[68]\d)\d{11,13}$/u,
                  // Discover
                  /^6(?:011|5\d{2})\d{12,15}$/u,
                  // JCB
                  /^(?:2131|1800|35\d{3})\d{11}$/u,
                  // Mastercard
                  /^5[1-5]\d{2}|(?:222\d|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}$/u,
                  // UnionPay
                  /^(?:6[27]\d{14,17}|81\d{14,17})$/u,
                  // Visa
                  /^4\d{12}(?:\d{3,6})?$/u
                ];
                function creditCard(message) {
                  return {
                    kind: "validation",
                    type: "credit_card",
                    reference: creditCard,
                    async: false,
                    expects: null,
                    requirement(input) {
                      let sanitized;
                      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks
                      (sanitized = input.replace(SANITIZE_REGEX, "")) && // Check if it matches a provider
                      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm
                      _isLuhnAlgo(sanitized);
                    },
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "credit card", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/cuid2/cuid2.ts
                function cuid2(message) {
                  return {
                    kind: "validation",
                    type: "cuid2",
                    reference: cuid2,
                    async: false,
                    expects: null,
                    requirement: CUID2_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "Cuid2", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/decimal/decimal.ts
                function decimal(message) {
                  return {
                    kind: "validation",
                    type: "decimal",
                    reference: decimal,
                    async: false,
                    expects: null,
                    requirement: DECIMAL_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "decimal", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/description/description.ts
                function description(description_) {
                  return {
                    kind: "metadata",
                    type: "description",
                    reference: description,
                    description: description_
                  };
                }

                // src/actions/email/email.ts
                function email(message) {
                  return {
                    kind: "validation",
                    type: "email",
                    reference: email,
                    expects: null,
                    async: false,
                    requirement: EMAIL_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "email", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/emoji/emoji.ts
                function emoji(message) {
                  return {
                    kind: "validation",
                    type: "emoji",
                    reference: emoji,
                    async: false,
                    expects: null,
                    requirement: EMOJI_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "emoji", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/empty/empty.ts
                function empty(message) {
                  return {
                    kind: "validation",
                    type: "empty",
                    reference: empty,
                    async: false,
                    expects: "0",
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length > 0) {
                        _addIssue(this, "length", dataset, config2, {
                          received: `${dataset.value.length}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/endsWith/endsWith.ts
                function endsWith(requirement, message) {
                  return {
                    kind: "validation",
                    type: "ends_with",
                    reference: endsWith,
                    async: false,
                    expects: `"${requirement}"`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {
                        _addIssue(this, "end", dataset, config2, {
                          received: `"${dataset.value.slice(-this.requirement.length)}"`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/everyItem/everyItem.ts
                function everyItem(requirement, message) {
                  return {
                    kind: "validation",
                    type: "every_item",
                    reference: everyItem,
                    async: false,
                    expects: null,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !dataset.value.every(this.requirement)) {
                        _addIssue(this, "item", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/excludes/excludes.ts
                function excludes(requirement, message) {
                  const received = _stringify(requirement);
                  return {
                    kind: "validation",
                    type: "excludes",
                    reference: excludes,
                    async: false,
                    expects: `!${received}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.includes(this.requirement)) {
                        _addIssue(this, "content", dataset, config2, { received });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/filterItems/filterItems.ts
                function filterItems(operation) {
                  return {
                    kind: "transformation",
                    type: "filter_items",
                    reference: filterItems,
                    async: false,
                    operation,
                    _run(dataset) {
                      dataset.value = dataset.value.filter(this.operation);
                      return dataset;
                    }
                  };
                }

                // src/actions/findItem/findItem.ts
                function findItem(operation) {
                  return {
                    kind: "transformation",
                    type: "find_item",
                    reference: findItem,
                    async: false,
                    operation,
                    _run(dataset) {
                      dataset.value = dataset.value.find(this.operation);
                      return dataset;
                    }
                  };
                }

                // src/actions/finite/finite.ts
                function finite(message) {
                  return {
                    kind: "validation",
                    type: "finite",
                    reference: finite,
                    async: false,
                    expects: null,
                    requirement: Number.isFinite,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "finite", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/hash/hash.ts
                var HASH_LENGTHS = {
                  md4: 32,
                  md5: 32,
                  sha1: 40,
                  sha256: 64,
                  sha384: 96,
                  sha512: 128,
                  ripemd128: 32,
                  ripemd160: 40,
                  tiger128: 32,
                  tiger160: 40,
                  tiger192: 48,
                  crc32: 8,
                  crc32b: 8,
                  adler32: 8
                };
                function hash(types, message) {
                  return {
                    kind: "validation",
                    type: "hash",
                    reference: hash,
                    expects: null,
                    async: false,
                    requirement: RegExp(
                      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join("|"),
                      "iu"
                    ),
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "hash", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/hexadecimal/hexadecimal.ts
                function hexadecimal(message) {
                  return {
                    kind: "validation",
                    type: "hexadecimal",
                    reference: hexadecimal,
                    async: false,
                    expects: null,
                    requirement: HEXADECIMAL_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "hexadecimal", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/hexColor/hexColor.ts
                function hexColor(message) {
                  return {
                    kind: "validation",
                    type: "hex_color",
                    reference: hexColor,
                    async: false,
                    expects: null,
                    requirement: HEX_COLOR_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "hex color", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/imei/imei.ts
                function imei(message) {
                  return {
                    kind: "validation",
                    type: "imei",
                    reference: imei,
                    async: false,
                    expects: null,
                    requirement(input) {
                      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);
                    },
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "IMEI", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/includes/includes.ts
                function includes(requirement, message) {
                  const expects = _stringify(requirement);
                  return {
                    kind: "validation",
                    type: "includes",
                    reference: includes,
                    async: false,
                    expects,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !dataset.value.includes(this.requirement)) {
                        _addIssue(this, "content", dataset, config2, {
                          received: `!${expects}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/integer/integer.ts
                function integer(message) {
                  return {
                    kind: "validation",
                    type: "integer",
                    reference: integer,
                    async: false,
                    expects: null,
                    requirement: Number.isInteger,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "integer", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/ip/ip.ts
                function ip(message) {
                  return {
                    kind: "validation",
                    type: "ip",
                    reference: ip,
                    async: false,
                    expects: null,
                    requirement: IP_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "IP", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/ipv4/ipv4.ts
                function ipv4(message) {
                  return {
                    kind: "validation",
                    type: "ipv4",
                    reference: ipv4,
                    async: false,
                    expects: null,
                    requirement: IPV4_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "IPv4", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/ipv6/ipv6.ts
                function ipv6(message) {
                  return {
                    kind: "validation",
                    type: "ipv6",
                    reference: ipv6,
                    async: false,
                    expects: null,
                    requirement: IPV6_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "IPv6", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoDate/isoDate.ts
                function isoDate(message) {
                  return {
                    kind: "validation",
                    type: "iso_date",
                    reference: isoDate,
                    async: false,
                    expects: null,
                    requirement: ISO_DATE_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "date", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoDateTime/isoDateTime.ts
                function isoDateTime(message) {
                  return {
                    kind: "validation",
                    type: "iso_date_time",
                    reference: isoDateTime,
                    async: false,
                    expects: null,
                    requirement: ISO_DATE_TIME_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "date-time", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoTime/isoTime.ts
                function isoTime(message) {
                  return {
                    kind: "validation",
                    type: "iso_time",
                    reference: isoTime,
                    async: false,
                    expects: null,
                    requirement: ISO_TIME_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "time", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoTimeSecond/isoTimeSecond.ts
                function isoTimeSecond(message) {
                  return {
                    kind: "validation",
                    type: "iso_time_second",
                    reference: isoTimeSecond,
                    async: false,
                    expects: null,
                    requirement: ISO_TIME_SECOND_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "time-second", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoTimestamp/isoTimestamp.ts
                function isoTimestamp(message) {
                  return {
                    kind: "validation",
                    type: "iso_timestamp",
                    reference: isoTimestamp,
                    async: false,
                    expects: null,
                    requirement: ISO_TIMESTAMP_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "timestamp", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/isoWeek/isoWeek.ts
                function isoWeek(message) {
                  return {
                    kind: "validation",
                    type: "iso_week",
                    reference: isoWeek,
                    async: false,
                    expects: null,
                    requirement: ISO_WEEK_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "week", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/length/length.ts
                function length(requirement, message) {
                  return {
                    kind: "validation",
                    type: "length",
                    reference: length,
                    async: false,
                    expects: `${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length !== this.requirement) {
                        _addIssue(this, "length", dataset, config2, {
                          received: `${dataset.value.length}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/mac/mac.ts
                function mac(message) {
                  return {
                    kind: "validation",
                    type: "mac",
                    reference: mac,
                    async: false,
                    expects: null,
                    requirement: MAC_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "MAC", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/mac48/mac48.ts
                function mac48(message) {
                  return {
                    kind: "validation",
                    type: "mac48",
                    reference: mac48,
                    async: false,
                    expects: null,
                    requirement: MAC48_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "48-bit MAC", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/mac64/mac64.ts
                function mac64(message) {
                  return {
                    kind: "validation",
                    type: "mac64",
                    reference: mac64,
                    async: false,
                    expects: null,
                    requirement: MAC64_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "64-bit MAC", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/mapItems/mapItems.ts
                function mapItems(operation) {
                  return {
                    kind: "transformation",
                    type: "map_items",
                    reference: mapItems,
                    async: false,
                    operation,
                    _run(dataset) {
                      dataset.value = dataset.value.map(this.operation);
                      return dataset;
                    }
                  };
                }

                // src/actions/maxBytes/maxBytes.ts
                function maxBytes(requirement, message) {
                  return {
                    kind: "validation",
                    type: "max_bytes",
                    reference: maxBytes,
                    async: false,
                    expects: `<=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed) {
                        const length2 = new TextEncoder().encode(dataset.value).length;
                        if (length2 > this.requirement) {
                          _addIssue(this, "bytes", dataset, config2, {
                            received: `${length2}`
                          });
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/maxLength/maxLength.ts
                function maxLength(requirement, message) {
                  return {
                    kind: "validation",
                    type: "max_length",
                    reference: maxLength,
                    async: false,
                    expects: `<=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length > this.requirement) {
                        _addIssue(this, "length", dataset, config2, {
                          received: `${dataset.value.length}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/maxSize/maxSize.ts
                function maxSize(requirement, message) {
                  return {
                    kind: "validation",
                    type: "max_size",
                    reference: maxSize,
                    async: false,
                    expects: `<=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.size > this.requirement) {
                        _addIssue(this, "size", dataset, config2, {
                          received: `${dataset.value.size}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/maxValue/maxValue.ts
                function maxValue(requirement, message) {
                  return {
                    kind: "validation",
                    type: "max_value",
                    reference: maxValue,
                    async: false,
                    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value > this.requirement) {
                        _addIssue(this, "value", dataset, config2, {
                          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/mimeType/mimeType.ts
                function mimeType(requirement, message) {
                  return {
                    kind: "validation",
                    type: "mime_type",
                    reference: mimeType,
                    async: false,
                    expects: requirement.map((option) => `"${option}"`).join(" | ") || "never",
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {
                        _addIssue(this, "MIME type", dataset, config2, {
                          received: `"${dataset.value.type}"`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/minBytes/minBytes.ts
                function minBytes(requirement, message) {
                  return {
                    kind: "validation",
                    type: "min_bytes",
                    reference: minBytes,
                    async: false,
                    expects: `>=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed) {
                        const length2 = new TextEncoder().encode(dataset.value).length;
                        if (length2 < this.requirement) {
                          _addIssue(this, "bytes", dataset, config2, {
                            received: `${length2}`
                          });
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/minLength/minLength.ts
                function minLength(requirement, message) {
                  return {
                    kind: "validation",
                    type: "min_length",
                    reference: minLength,
                    async: false,
                    expects: `>=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length < this.requirement) {
                        _addIssue(this, "length", dataset, config2, {
                          received: `${dataset.value.length}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/minSize/minSize.ts
                function minSize(requirement, message) {
                  return {
                    kind: "validation",
                    type: "min_size",
                    reference: minSize,
                    async: false,
                    expects: `>=${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.size < this.requirement) {
                        _addIssue(this, "size", dataset, config2, {
                          received: `${dataset.value.size}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/minValue/minValue.ts
                function minValue(requirement, message) {
                  return {
                    kind: "validation",
                    type: "min_value",
                    reference: minValue,
                    async: false,
                    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value < this.requirement) {
                        _addIssue(this, "value", dataset, config2, {
                          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/multipleOf/multipleOf.ts
                function multipleOf(requirement, message) {
                  return {
                    kind: "validation",
                    type: "multiple_of",
                    reference: multipleOf,
                    async: false,
                    expects: `%${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value % this.requirement !== 0) {
                        _addIssue(this, "multiple", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/nonEmpty/nonEmpty.ts
                function nonEmpty(message) {
                  return {
                    kind: "validation",
                    type: "non_empty",
                    reference: nonEmpty,
                    async: false,
                    expects: "!0",
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length === 0) {
                        _addIssue(this, "length", dataset, config2, {
                          received: "0"
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/normalize/normalize.ts
                function normalize(form) {
                  return {
                    kind: "transformation",
                    type: "normalize",
                    reference: normalize,
                    async: false,
                    form,
                    _run(dataset) {
                      dataset.value = dataset.value.normalize(this.form);
                      return dataset;
                    }
                  };
                }

                // src/actions/notBytes/notBytes.ts
                function notBytes(requirement, message) {
                  return {
                    kind: "validation",
                    type: "not_bytes",
                    reference: notBytes,
                    async: false,
                    expects: `!${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed) {
                        const length2 = new TextEncoder().encode(dataset.value).length;
                        if (length2 === this.requirement) {
                          _addIssue(this, "bytes", dataset, config2, {
                            received: `${length2}`
                          });
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/notLength/notLength.ts
                function notLength(requirement, message) {
                  return {
                    kind: "validation",
                    type: "not_length",
                    reference: notLength,
                    async: false,
                    expects: `!${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.length === this.requirement) {
                        _addIssue(this, "length", dataset, config2, {
                          received: `${dataset.value.length}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/notSize/notSize.ts
                function notSize(requirement, message) {
                  return {
                    kind: "validation",
                    type: "not_size",
                    reference: notSize,
                    async: false,
                    expects: `!${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.size === this.requirement) {
                        _addIssue(this, "size", dataset, config2, {
                          received: `${dataset.value.size}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/notValue/notValue.ts
                function notValue(requirement, message) {
                  return {
                    kind: "validation",
                    type: "not_value",
                    reference: notValue,
                    async: false,
                    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {
                        _addIssue(this, "value", dataset, config2, {
                          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/octal/octal.ts
                function octal(message) {
                  return {
                    kind: "validation",
                    type: "octal",
                    reference: octal,
                    async: false,
                    expects: null,
                    requirement: OCTAL_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "octal", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts
                function _isPartiallyTyped(dataset, pathList) {
                  if (dataset.issues) {
                    for (const path of pathList) {
                      for (const issue of dataset.issues) {
                        let typed = false;
                        const bound = Math.min(path.length, issue.path?.length ?? 0);
                        for (let index = 0; index < bound; index++) {
                          if (path[index] !== issue.path[index].key) {
                            typed = true;
                            break;
                          }
                        }
                        if (!typed) {
                          return false;
                        }
                      }
                    }
                  }
                  return true;
                }

                // src/actions/partialCheck/partialCheck.ts
                function partialCheck(pathList, requirement, message) {
                  return {
                    kind: "validation",
                    type: "partial_check",
                    reference: partialCheck,
                    async: false,
                    expects: null,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error
                      !this.requirement(dataset.value)) {
                        _addIssue(this, "input", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/partialCheck/partialCheckAsync.ts
                function partialCheckAsync(pathList, requirement, message) {
                  return {
                    kind: "validation",
                    type: "partial_check",
                    reference: partialCheckAsync,
                    async: true,
                    expects: null,
                    requirement,
                    message,
                    async _run(dataset, config2) {
                      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error
                      !await this.requirement(dataset.value)) {
                        _addIssue(this, "input", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/rawCheck/rawCheck.ts
                function rawCheck(action) {
                  return {
                    kind: "validation",
                    type: "raw_check",
                    reference: rawCheck,
                    async: false,
                    expects: null,
                    _run(dataset, config2) {
                      action({
                        dataset,
                        config: config2,
                        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config2, info)
                      });
                      return dataset;
                    }
                  };
                }

                // src/actions/rawCheck/rawCheckAsync.ts
                function rawCheckAsync(action) {
                  return {
                    kind: "validation",
                    type: "raw_check",
                    reference: rawCheckAsync,
                    async: true,
                    expects: null,
                    async _run(dataset, config2) {
                      await action({
                        dataset,
                        config: config2,
                        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config2, info)
                      });
                      return dataset;
                    }
                  };
                }

                // src/actions/rawTransform/rawTransform.ts
                function rawTransform(action) {
                  return {
                    kind: "transformation",
                    type: "raw_transform",
                    reference: rawTransform,
                    async: false,
                    _run(dataset, config2) {
                      const output = action({
                        dataset,
                        config: config2,
                        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config2, info),
                        NEVER: null
                      });
                      if (dataset.issues) {
                        dataset.typed = false;
                      } else {
                        dataset.value = output;
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/rawTransform/rawTransformAsync.ts
                function rawTransformAsync(action) {
                  return {
                    kind: "transformation",
                    type: "raw_transform",
                    reference: rawTransformAsync,
                    async: true,
                    async _run(dataset, config2) {
                      const output = await action({
                        dataset,
                        config: config2,
                        addIssue: (info) => _addIssue(this, info?.label ?? "input", dataset, config2, info),
                        NEVER: null
                      });
                      if (dataset.issues) {
                        dataset.typed = false;
                      } else {
                        dataset.value = output;
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/readonly/readonly.ts
                function readonly() {
                  return {
                    kind: "transformation",
                    type: "readonly",
                    reference: readonly,
                    async: false,
                    _run(dataset) {
                      return dataset;
                    }
                  };
                }

                // src/actions/reduceItems/reduceItems.ts
                function reduceItems(operation, initial) {
                  return {
                    kind: "transformation",
                    type: "reduce_items",
                    reference: reduceItems,
                    async: false,
                    operation,
                    initial,
                    _run(dataset) {
                      dataset.value = dataset.value.reduce(this.operation, this.initial);
                      return dataset;
                    }
                  };
                }

                // src/actions/regex/regex.ts
                function regex(requirement, message) {
                  return {
                    kind: "validation",
                    type: "regex",
                    reference: regex,
                    async: false,
                    expects: `${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "format", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/safeInteger/safeInteger.ts
                function safeInteger(message) {
                  return {
                    kind: "validation",
                    type: "safe_integer",
                    reference: safeInteger,
                    async: false,
                    expects: null,
                    requirement: Number.isSafeInteger,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "safe integer", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/size/size.ts
                function size(requirement, message) {
                  return {
                    kind: "validation",
                    type: "size",
                    reference: size,
                    async: false,
                    expects: `${requirement}`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && dataset.value.size !== this.requirement) {
                        _addIssue(this, "size", dataset, config2, {
                          received: `${dataset.value.size}`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/someItem/someItem.ts
                function someItem(requirement, message) {
                  return {
                    kind: "validation",
                    type: "some_item",
                    reference: someItem,
                    async: false,
                    expects: null,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !dataset.value.some(this.requirement)) {
                        _addIssue(this, "item", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/sortItems/sortItems.ts
                function sortItems(operation) {
                  return {
                    kind: "transformation",
                    type: "sort_items",
                    reference: sortItems,
                    async: false,
                    operation,
                    _run(dataset) {
                      dataset.value = dataset.value.sort(this.operation);
                      return dataset;
                    }
                  };
                }

                // src/actions/startsWith/startsWith.ts
                function startsWith(requirement, message) {
                  return {
                    kind: "validation",
                    type: "starts_with",
                    reference: startsWith,
                    async: false,
                    expects: `"${requirement}"`,
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {
                        _addIssue(this, "start", dataset, config2, {
                          received: `"${dataset.value.slice(0, this.requirement.length)}"`
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/toLowerCase/toLowerCase.ts
                function toLowerCase() {
                  return {
                    kind: "transformation",
                    type: "to_lower_case",
                    reference: toLowerCase,
                    async: false,
                    _run(dataset) {
                      dataset.value = dataset.value.toLowerCase();
                      return dataset;
                    }
                  };
                }

                // src/actions/toMaxValue/toMaxValue.ts
                function toMaxValue(requirement) {
                  return {
                    kind: "transformation",
                    type: "to_max_value",
                    reference: toMaxValue,
                    async: false,
                    requirement,
                    _run(dataset) {
                      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;
                      return dataset;
                    }
                  };
                }

                // src/actions/toMinValue/toMinValue.ts
                function toMinValue(requirement) {
                  return {
                    kind: "transformation",
                    type: "to_min_value",
                    reference: toMinValue,
                    async: false,
                    requirement,
                    _run(dataset) {
                      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;
                      return dataset;
                    }
                  };
                }

                // src/actions/toUpperCase/toUpperCase.ts
                function toUpperCase() {
                  return {
                    kind: "transformation",
                    type: "to_upper_case",
                    reference: toUpperCase,
                    async: false,
                    _run(dataset) {
                      dataset.value = dataset.value.toUpperCase();
                      return dataset;
                    }
                  };
                }

                // src/actions/transform/transform.ts
                function transform(operation) {
                  return {
                    kind: "transformation",
                    type: "transform",
                    reference: transform,
                    async: false,
                    operation,
                    _run(dataset) {
                      dataset.value = this.operation(dataset.value);
                      return dataset;
                    }
                  };
                }

                // src/actions/transform/transformAsync.ts
                function transformAsync(operation) {
                  return {
                    kind: "transformation",
                    type: "transform",
                    reference: transformAsync,
                    async: true,
                    operation,
                    async _run(dataset) {
                      dataset.value = await this.operation(dataset.value);
                      return dataset;
                    }
                  };
                }

                // src/actions/trim/trim.ts
                function trim() {
                  return {
                    kind: "transformation",
                    type: "trim",
                    reference: trim,
                    async: false,
                    _run(dataset) {
                      dataset.value = dataset.value.trim();
                      return dataset;
                    }
                  };
                }

                // src/actions/trimEnd/trimEnd.ts
                function trimEnd() {
                  return {
                    kind: "transformation",
                    type: "trim_end",
                    reference: trimEnd,
                    async: false,
                    _run(dataset) {
                      dataset.value = dataset.value.trimEnd();
                      return dataset;
                    }
                  };
                }

                // src/actions/trimStart/trimStart.ts
                function trimStart() {
                  return {
                    kind: "transformation",
                    type: "trim_start",
                    reference: trimStart,
                    async: false,
                    _run(dataset) {
                      dataset.value = dataset.value.trimStart();
                      return dataset;
                    }
                  };
                }

                // src/actions/ulid/ulid.ts
                function ulid(message) {
                  return {
                    kind: "validation",
                    type: "ulid",
                    reference: ulid,
                    async: false,
                    expects: null,
                    requirement: ULID_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "ULID", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/url/url.ts
                function url(message) {
                  return {
                    kind: "validation",
                    type: "url",
                    reference: url,
                    async: false,
                    expects: null,
                    requirement(input) {
                      try {
                        new URL(input);
                        return true;
                      } catch {
                        return false;
                      }
                    },
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement(dataset.value)) {
                        _addIssue(this, "URL", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/uuid/uuid.ts
                function uuid(message) {
                  return {
                    kind: "validation",
                    type: "uuid",
                    reference: uuid,
                    async: false,
                    expects: null,
                    requirement: UUID_REGEX,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !this.requirement.test(dataset.value)) {
                        _addIssue(this, "UUID", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/actions/value/value.ts
                function value(requirement, message) {
                  return {
                    kind: "validation",
                    type: "value",
                    reference: value,
                    async: false,
                    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),
                    requirement,
                    message,
                    _run(dataset, config2) {
                      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {
                        _addIssue(this, "value", dataset, config2, {
                          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/config/config.ts
                function config(schema, config2) {
                  return {
                    ...schema,
                    _run(dataset, config_) {
                      return schema._run(dataset, { ...config_, ...config2 });
                    }
                  };
                }

                // src/methods/getFallback/getFallback.ts
                function getFallback(schema, dataset, config2) {
                  return typeof schema.fallback === "function" ? (
                    // @ts-expect-error
                    schema.fallback(dataset, config2)
                  ) : (
                    // @ts-expect-error
                    schema.fallback
                  );
                }

                // src/methods/fallback/fallback.ts
                function fallback(schema, fallback2) {
                  return {
                    ...schema,
                    fallback: fallback2,
                    _run(dataset, config2) {
                      const outputDataset = schema._run(dataset, config2);
                      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;
                    }
                  };
                }

                // src/methods/fallback/fallbackAsync.ts
                function fallbackAsync(schema, fallback2) {
                  return {
                    ...schema,
                    fallback: fallback2,
                    async: true,
                    async _run(dataset, config2) {
                      const outputDataset = await schema._run(dataset, config2);
                      return outputDataset.issues ? (
                        // @ts-expect-error
                        { typed: true, value: await getFallback(this, outputDataset, config2) }
                      ) : outputDataset;
                    }
                  };
                }

                // src/methods/flatten/flatten.ts
                function flatten(issues) {
                  const flatErrors = {};
                  for (const issue of issues) {
                    if (issue.path) {
                      const dotPath = getDotPath(issue);
                      if (dotPath) {
                        if (!flatErrors.nested) {
                          flatErrors.nested = {};
                        }
                        if (flatErrors.nested[dotPath]) {
                          flatErrors.nested[dotPath].push(issue.message);
                        } else {
                          flatErrors.nested[dotPath] = [issue.message];
                        }
                      } else {
                        if (flatErrors.other) {
                          flatErrors.other.push(issue.message);
                        } else {
                          flatErrors.other = [issue.message];
                        }
                      }
                    } else {
                      if (flatErrors.root) {
                        flatErrors.root.push(issue.message);
                      } else {
                        flatErrors.root = [issue.message];
                      }
                    }
                  }
                  return flatErrors;
                }

                // src/methods/forward/forward.ts
                function forward(action, pathKeys) {
                  return {
                    ...action,
                    _run(dataset, config2) {
                      const prevIssues = dataset.issues && [...dataset.issues];
                      action._run(dataset, config2);
                      if (dataset.issues) {
                        for (const issue of dataset.issues) {
                          if (!prevIssues?.includes(issue)) {
                            let pathInput = dataset.value;
                            for (const key of pathKeys) {
                              const pathValue = pathInput[key];
                              const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                              };
                              if (issue.path) {
                                issue.path.push(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              if (!pathValue) {
                                break;
                              }
                              pathInput = pathValue;
                            }
                          }
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/forward/forwardAsync.ts
                function forwardAsync(action, pathKeys) {
                  return {
                    ...action,
                    async: true,
                    async _run(dataset, config2) {
                      const prevIssues = dataset.issues && [...dataset.issues];
                      await action._run(dataset, config2);
                      if (dataset.issues) {
                        for (const issue of dataset.issues) {
                          if (!prevIssues?.includes(issue)) {
                            let pathInput = dataset.value;
                            for (const key of pathKeys) {
                              const pathValue = pathInput[key];
                              const pathItem = {
                                type: "unknown",
                                origin: "value",
                                input: pathInput,
                                key,
                                value: pathValue
                              };
                              if (issue.path) {
                                issue.path.push(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              if (!pathValue) {
                                break;
                              }
                              pathInput = pathValue;
                            }
                          }
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/getDefault/getDefault.ts
                function getDefault(schema, dataset, config2) {
                  return typeof schema.default === "function" ? (
                    // @ts-expect-error
                    schema.default(dataset, config2)
                  ) : (
                    // @ts-expect-error
                    schema.default
                  );
                }

                // src/methods/getDefaults/getDefaults.ts
                function getDefaults(schema) {
                  if ("entries" in schema) {
                    const object2 = {};
                    for (const key in schema.entries) {
                      object2[key] = getDefaults(schema.entries[key]);
                    }
                    return object2;
                  }
                  if ("items" in schema) {
                    return schema.items.map(getDefaults);
                  }
                  return getDefault(schema);
                }

                // src/methods/getDefaults/getDefaultsAsync.ts
                async function getDefaultsAsync(schema) {
                  if ("entries" in schema) {
                    return Object.fromEntries(
                      await Promise.all(
                        Object.entries(schema.entries).map(async ([key, value2]) => [
                          key,
                          await getDefaultsAsync(value2)
                        ])
                      )
                    );
                  }
                  if ("items" in schema) {
                    return Promise.all(schema.items.map(getDefaultsAsync));
                  }
                  return getDefault(schema);
                }

                // src/methods/getFallbacks/getFallbacks.ts
                function getFallbacks(schema) {
                  if ("entries" in schema) {
                    const object2 = {};
                    for (const key in schema.entries) {
                      object2[key] = getFallbacks(schema.entries[key]);
                    }
                    return object2;
                  }
                  if ("items" in schema) {
                    return schema.items.map(getFallbacks);
                  }
                  return getFallback(schema);
                }

                // src/methods/getFallbacks/getFallbacksAsync.ts
                async function getFallbacksAsync(schema) {
                  if ("entries" in schema) {
                    return Object.fromEntries(
                      await Promise.all(
                        Object.entries(schema.entries).map(async ([key, value2]) => [
                          key,
                          await getFallbacksAsync(value2)
                        ])
                      )
                    );
                  }
                  if ("items" in schema) {
                    return Promise.all(schema.items.map(getFallbacksAsync));
                  }
                  return getFallback(schema);
                }

                // src/methods/is/is.ts
                function is(schema, input) {
                  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;
                }

                // src/schemas/any/any.ts
                function any() {
                  return {
                    kind: "schema",
                    type: "any",
                    reference: any,
                    expects: "any",
                    async: false,
                    _run(dataset) {
                      dataset.typed = true;
                      return dataset;
                    }
                  };
                }

                // src/schemas/array/array.ts
                function array(item, message) {
                  return {
                    kind: "schema",
                    type: "array",
                    reference: array,
                    expects: "Array",
                    async: false,
                    item,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        for (let key = 0; key < input.length; key++) {
                          const value2 = input[key];
                          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/array/arrayAsync.ts
                function arrayAsync(item, message) {
                  return {
                    kind: "schema",
                    type: "array",
                    reference: arrayAsync,
                    expects: "Array",
                    async: true,
                    item,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        const itemDatasets = await Promise.all(
                          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))
                        );
                        for (let key = 0; key < itemDatasets.length; key++) {
                          const itemDataset = itemDatasets[key];
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: input[key]
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/bigint/bigint.ts
                function bigint(message) {
                  return {
                    kind: "schema",
                    type: "bigint",
                    reference: bigint,
                    expects: "bigint",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "bigint") {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/blob/blob.ts
                function blob(message) {
                  return {
                    kind: "schema",
                    type: "blob",
                    reference: blob,
                    expects: "Blob",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value instanceof Blob) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/boolean/boolean.ts
                function boolean(message) {
                  return {
                    kind: "schema",
                    type: "boolean",
                    reference: boolean,
                    expects: "boolean",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "boolean") {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/custom/custom.ts
                function custom(check2, message) {
                  return {
                    kind: "schema",
                    type: "custom",
                    reference: custom,
                    expects: "unknown",
                    async: false,
                    check: check2,
                    message,
                    _run(dataset, config2) {
                      if (this.check(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/custom/customAsync.ts
                function customAsync(check2, message) {
                  return {
                    kind: "schema",
                    type: "custom",
                    reference: customAsync,
                    expects: "unknown",
                    async: true,
                    check: check2,
                    message,
                    async _run(dataset, config2) {
                      if (await this.check(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/date/date.ts
                function date(message) {
                  return {
                    kind: "schema",
                    type: "date",
                    reference: date,
                    expects: "Date",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value instanceof Date) {
                        if (!isNaN(dataset.value)) {
                          dataset.typed = true;
                        } else {
                          _addIssue(this, "type", dataset, config2, {
                            received: '"Invalid Date"'
                          });
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/enum/enum.ts
                function enum_(enum__, message) {
                  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);
                  return {
                    kind: "schema",
                    type: "enum",
                    reference: enum_,
                    expects: options.map(_stringify).join(" | ") || "never",
                    async: false,
                    enum: enum__,
                    options,
                    message,
                    _run(dataset, config2) {
                      if (this.options.includes(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/file/file.ts
                function file(message) {
                  return {
                    kind: "schema",
                    type: "file",
                    reference: file,
                    expects: "File",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value instanceof File) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/function/function.ts
                function function_(message) {
                  return {
                    kind: "schema",
                    type: "function",
                    reference: function_,
                    expects: "Function",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "function") {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/instance/instance.ts
                function instance(class_, message) {
                  return {
                    kind: "schema",
                    type: "instance",
                    reference: instance,
                    expects: class_.name,
                    async: false,
                    class: class_,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value instanceof this.class) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/intersect/utils/_merge/_merge.ts
                function _merge(value1, value2) {
                  if (typeof value1 === typeof value2) {
                    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {
                      return { value: value1 };
                    }
                    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {
                      for (const key in value2) {
                        if (key in value1) {
                          const dataset = _merge(value1[key], value2[key]);
                          if (dataset.issue) {
                            return dataset;
                          }
                          value1[key] = dataset.value;
                        } else {
                          value1[key] = value2[key];
                        }
                      }
                      return { value: value1 };
                    }
                    if (Array.isArray(value1) && Array.isArray(value2)) {
                      if (value1.length === value2.length) {
                        for (let index = 0; index < value1.length; index++) {
                          const dataset = _merge(value1[index], value2[index]);
                          if (dataset.issue) {
                            return dataset;
                          }
                          value1[index] = dataset.value;
                        }
                        return { value: value1 };
                      }
                    }
                  }
                  return { issue: true };
                }

                // src/schemas/intersect/intersect.ts
                function intersect(options, message) {
                  return {
                    kind: "schema",
                    type: "intersect",
                    reference: intersect,
                    expects: [...new Set(options.map((option) => option.expects))].join(" & ") || "never",
                    async: false,
                    options,
                    message,
                    _run(dataset, config2) {
                      if (this.options.length) {
                        const input = dataset.value;
                        let outputs;
                        dataset.typed = true;
                        for (const schema of this.options) {
                          const optionDataset = schema._run(
                            { typed: false, value: input },
                            config2
                          );
                          if (optionDataset.issues) {
                            if (dataset.issues) {
                              dataset.issues.push(...optionDataset.issues);
                            } else {
                              dataset.issues = optionDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!optionDataset.typed) {
                            dataset.typed = false;
                          }
                          if (dataset.typed) {
                            if (outputs) {
                              outputs.push(optionDataset.value);
                            } else {
                              outputs = [optionDataset.value];
                            }
                          }
                        }
                        if (dataset.typed) {
                          dataset.value = outputs[0];
                          for (let index = 1; index < outputs.length; index++) {
                            const mergeDataset = _merge(dataset.value, outputs[index]);
                            if (mergeDataset.issue) {
                              _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                              });
                              break;
                            }
                            dataset.value = mergeDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/intersect/intersectAsync.ts
                function intersectAsync(options, message) {
                  return {
                    kind: "schema",
                    type: "intersect",
                    reference: intersectAsync,
                    expects: [...new Set(options.map((option) => option.expects))].join(" & ") || "never",
                    async: true,
                    options,
                    message,
                    async _run(dataset, config2) {
                      if (this.options.length) {
                        const input = dataset.value;
                        let outputs;
                        dataset.typed = true;
                        const optionDatasets = await Promise.all(
                          this.options.map(
                            (schema) => schema._run({ typed: false, value: input }, config2)
                          )
                        );
                        for (const optionDataset of optionDatasets) {
                          if (optionDataset.issues) {
                            if (dataset.issues) {
                              dataset.issues.push(...optionDataset.issues);
                            } else {
                              dataset.issues = optionDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!optionDataset.typed) {
                            dataset.typed = false;
                          }
                          if (dataset.typed) {
                            if (outputs) {
                              outputs.push(optionDataset.value);
                            } else {
                              outputs = [optionDataset.value];
                            }
                          }
                        }
                        if (dataset.typed) {
                          dataset.value = outputs[0];
                          for (let index = 1; index < outputs.length; index++) {
                            const mergeDataset = _merge(dataset.value, outputs[index]);
                            if (mergeDataset.issue) {
                              _addIssue(this, "type", dataset, config2, {
                                received: "unknown"
                              });
                              break;
                            }
                            dataset.value = mergeDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/lazy/lazy.ts
                function lazy(getter) {
                  return {
                    kind: "schema",
                    type: "lazy",
                    reference: lazy,
                    expects: "unknown",
                    async: false,
                    getter,
                    _run(dataset, config2) {
                      return this.getter(dataset.value)._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/lazy/lazyAsync.ts
                function lazyAsync(getter) {
                  return {
                    kind: "schema",
                    type: "lazy",
                    reference: lazyAsync,
                    expects: "unknown",
                    async: true,
                    getter,
                    async _run(dataset, config2) {
                      return (await this.getter(dataset.value))._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/literal/literal.ts
                function literal(literal_, message) {
                  return {
                    kind: "schema",
                    type: "literal",
                    reference: literal,
                    expects: _stringify(literal_),
                    async: false,
                    literal: literal_,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === this.literal) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/looseObject/looseObject.ts
                function looseObject(entries, message) {
                  return {
                    kind: "schema",
                    type: "loose_object",
                    reference: looseObject,
                    expects: "Object",
                    async: false,
                    entries,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        for (const key in this.entries) {
                          const value2 = input[key];
                          const valueDataset = this.entries[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const key in input) {
                            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                              dataset.value[key] = input[key];
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/looseObject/looseObjectAsync.ts
                function looseObjectAsync(entries, message) {
                  return {
                    kind: "schema",
                    type: "loose_object",
                    reference: looseObjectAsync,
                    expects: "Object",
                    async: true,
                    entries,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        const valueDatasets = await Promise.all(
                          Object.entries(this.entries).map(async ([key, schema]) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await schema._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, valueDataset] of valueDatasets) {
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const key in input) {
                            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                              dataset.value[key] = input[key];
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/looseTuple/looseTuple.ts
                function looseTuple(items, message) {
                  return {
                    kind: "schema",
                    type: "loose_tuple",
                    reference: looseTuple,
                    expects: "Array",
                    async: false,
                    items,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        for (let key = 0; key < this.items.length; key++) {
                          const value2 = input[key];
                          const itemDataset = this.items[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (let key = this.items.length; key < input.length; key++) {
                            dataset.value.push(input[key]);
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/looseTuple/looseTupleAsync.ts
                function looseTupleAsync(items, message) {
                  return {
                    kind: "schema",
                    type: "loose_tuple",
                    reference: looseTupleAsync,
                    expects: "Array",
                    async: true,
                    items,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        const itemDatasets = await Promise.all(
                          this.items.map(async (item, key) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await item._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, itemDataset] of itemDatasets) {
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (let key = this.items.length; key < input.length; key++) {
                            dataset.value.push(input[key]);
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/map/map.ts
                function map(key, value2, message) {
                  return {
                    kind: "schema",
                    type: "map",
                    reference: map,
                    expects: "Map",
                    async: false,
                    key,
                    value: value2,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input instanceof Map) {
                        dataset.typed = true;
                        dataset.value = /* @__PURE__ */ new Map();
                        for (const [inputKey, inputValue] of input) {
                          const keyDataset = this.key._run(
                            { typed: false, value: inputKey },
                            config2
                          );
                          if (keyDataset.issues) {
                            const pathItem = {
                              type: "map",
                              origin: "key",
                              input,
                              key: inputKey,
                              value: inputValue
                            };
                            for (const issue of keyDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          const valueDataset = this.value._run(
                            { typed: false, value: inputValue },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "map",
                              origin: "value",
                              input,
                              key: inputKey,
                              value: inputValue
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.set(keyDataset.value, valueDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/map/mapAsync.ts
                function mapAsync(key, value2, message) {
                  return {
                    kind: "schema",
                    type: "map",
                    reference: mapAsync,
                    expects: "Map",
                    async: true,
                    key,
                    value: value2,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input instanceof Map) {
                        dataset.typed = true;
                        dataset.value = /* @__PURE__ */ new Map();
                        const datasets = await Promise.all(
                          [...input].map(
                            ([inputKey, inputValue]) => Promise.all([
                              inputKey,
                              inputValue,
                              this.key._run({ typed: false, value: inputKey }, config2),
                              this.value._run({ typed: false, value: inputValue }, config2)
                            ])
                          )
                        );
                        for (const [
                          inputKey,
                          inputValue,
                          keyDataset,
                          valueDataset
                        ] of datasets) {
                          if (keyDataset.issues) {
                            const pathItem = {
                              type: "map",
                              origin: "key",
                              input,
                              key: inputKey,
                              value: inputValue
                            };
                            for (const issue of keyDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "map",
                              origin: "value",
                              input,
                              key: inputKey,
                              value: inputValue
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.set(keyDataset.value, valueDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/nan/nan.ts
                function nan(message) {
                  return {
                    kind: "schema",
                    type: "nan",
                    reference: nan,
                    expects: "NaN",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (Number.isNaN(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/never/never.ts
                function never(message) {
                  return {
                    kind: "schema",
                    type: "never",
                    reference: never,
                    expects: "never",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      _addIssue(this, "type", dataset, config2);
                      return dataset;
                    }
                  };
                }

                // src/schemas/nonNullable/nonNullable.ts
                function nonNullable(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_nullable",
                    reference: nonNullable,
                    expects: "!null",
                    async: false,
                    wrapped,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === null) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/nonNullable/nonNullableAsync.ts
                function nonNullableAsync(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_nullable",
                    reference: nonNullableAsync,
                    expects: "!null",
                    async: true,
                    wrapped,
                    message,
                    async _run(dataset, config2) {
                      if (dataset.value === null) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/nonNullish/nonNullish.ts
                function nonNullish(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_nullish",
                    reference: nonNullish,
                    expects: "!null & !undefined",
                    async: false,
                    wrapped,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === null || dataset.value === void 0) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/nonNullish/nonNullishAsync.ts
                function nonNullishAsync(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_nullish",
                    reference: nonNullishAsync,
                    expects: "!null & !undefined",
                    async: true,
                    wrapped,
                    message,
                    async _run(dataset, config2) {
                      if (dataset.value === null || dataset.value === void 0) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/nonOptional/nonOptional.ts
                function nonOptional(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_optional",
                    reference: nonOptional,
                    expects: "!undefined",
                    async: false,
                    wrapped,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/nonOptional/nonOptionalAsync.ts
                function nonOptionalAsync(wrapped, message) {
                  return {
                    kind: "schema",
                    type: "non_optional",
                    reference: nonOptionalAsync,
                    expects: "!undefined",
                    async: true,
                    wrapped,
                    message,
                    async _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        _addIssue(this, "type", dataset, config2);
                        return dataset;
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                }

                // src/schemas/null/null.ts
                function null_(message) {
                  return {
                    kind: "schema",
                    type: "null",
                    reference: null_,
                    expects: "null",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === null) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/nullable/nullable.ts
                function nullable(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "nullable",
                    reference: nullable,
                    expects: `${wrapped.expects} | null`,
                    async: false,
                    wrapped,
                    _run(dataset, config2) {
                      if (dataset.value === null) {
                        if ("default" in this) {
                          dataset.value = getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === null) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/nullable/nullableAsync.ts
                function nullableAsync(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "nullable",
                    reference: nullableAsync,
                    expects: `${wrapped.expects} | null`,
                    async: true,
                    wrapped,
                    async _run(dataset, config2) {
                      if (dataset.value === null) {
                        if ("default" in this) {
                          dataset.value = await getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === null) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/nullish/nullish.ts
                function nullish(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "nullish",
                    reference: nullish,
                    expects: `${wrapped.expects} | null | undefined`,
                    async: false,
                    wrapped,
                    _run(dataset, config2) {
                      if (dataset.value === null || dataset.value === void 0) {
                        if ("default" in this) {
                          dataset.value = getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === null || dataset.value === void 0) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/nullish/nullishAsync.ts
                function nullishAsync(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "nullish",
                    reference: nullishAsync,
                    expects: `${wrapped.expects} | null | undefined`,
                    async: true,
                    wrapped,
                    async _run(dataset, config2) {
                      if (dataset.value === null || dataset.value === void 0) {
                        if ("default" in this) {
                          dataset.value = await getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === null || dataset.value === void 0) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/number/number.ts
                function number(message) {
                  return {
                    kind: "schema",
                    type: "number",
                    reference: number,
                    expects: "number",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "number" && !isNaN(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/object/object.ts
                function object(entries, message) {
                  return {
                    kind: "schema",
                    type: "object",
                    reference: object,
                    expects: "Object",
                    async: false,
                    entries,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        for (const key in this.entries) {
                          const value2 = input[key];
                          const valueDataset = this.entries[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/object/objectAsync.ts
                function objectAsync(entries, message) {
                  return {
                    kind: "schema",
                    type: "object",
                    reference: objectAsync,
                    expects: "Object",
                    async: true,
                    entries,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        const valueDatasets = await Promise.all(
                          Object.entries(this.entries).map(async ([key, schema]) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await schema._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, valueDataset] of valueDatasets) {
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/objectWithRest/objectWithRest.ts
                function objectWithRest(entries, rest, message) {
                  return {
                    kind: "schema",
                    type: "object_with_rest",
                    reference: objectWithRest,
                    expects: "Object",
                    async: false,
                    entries,
                    rest,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        for (const key in this.entries) {
                          const value2 = input[key];
                          const valueDataset = this.entries[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const key in input) {
                            if (_isValidObjectKey(input, key) && !(key in this.entries)) {
                              const value2 = input[key];
                              const valueDataset = this.rest._run(
                                { typed: false, value: value2 },
                                config2
                              );
                              if (valueDataset.issues) {
                                const pathItem = {
                                  type: "object",
                                  origin: "value",
                                  input,
                                  key,
                                  value: value2
                                };
                                for (const issue of valueDataset.issues) {
                                  if (issue.path) {
                                    issue.path.unshift(pathItem);
                                  } else {
                                    issue.path = [pathItem];
                                  }
                                  dataset.issues?.push(issue);
                                }
                                if (!dataset.issues) {
                                  dataset.issues = valueDataset.issues;
                                }
                                if (config2.abortEarly) {
                                  dataset.typed = false;
                                  break;
                                }
                              }
                              if (!valueDataset.typed) {
                                dataset.typed = false;
                              }
                              dataset.value[key] = valueDataset.value;
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/objectWithRest/objectWithRestAsync.ts
                function objectWithRestAsync(entries, rest, message) {
                  return {
                    kind: "schema",
                    type: "object_with_rest",
                    reference: objectWithRestAsync,
                    expects: "Object",
                    async: true,
                    entries,
                    rest,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        const [normalDatasets, restDatasets] = await Promise.all([
                          // Parse schema of each normal entry
                          // Hint: We do not distinguish between missing and `undefined` entries.
                          // The reason for this decision is that it reduces the bundle size, and
                          // we also expect that most users will expect this behavior.
                          Promise.all(
                            Object.entries(this.entries).map(async ([key, schema]) => {
                              const value2 = input[key];
                              return [
                                key,
                                value2,
                                await schema._run({ typed: false, value: value2 }, config2)
                              ];
                            })
                          ),
                          // Parse other entries with rest schema
                          // Hint: We exclude specific keys for security reasons
                          Promise.all(
                            Object.entries(input).filter(
                              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)
                            ).map(
                              async ([key, value2]) => [
                                key,
                                value2,
                                await this.rest._run({ typed: false, value: value2 }, config2)
                              ]
                            )
                          )
                        ]);
                        for (const [key, value2, valueDataset] of normalDatasets) {
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const [key, value2, valueDataset] of restDatasets) {
                            if (valueDataset.issues) {
                              const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key,
                                value: value2
                              };
                              for (const issue of valueDataset.issues) {
                                if (issue.path) {
                                  issue.path.unshift(pathItem);
                                } else {
                                  issue.path = [pathItem];
                                }
                                dataset.issues?.push(issue);
                              }
                              if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                              }
                              if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                              }
                            }
                            if (!valueDataset.typed) {
                              dataset.typed = false;
                            }
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/optional/optional.ts
                function optional(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "optional",
                    reference: optional,
                    expects: `${wrapped.expects} | undefined`,
                    async: false,
                    wrapped,
                    _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        if ("default" in this) {
                          dataset.value = getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === void 0) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/optional/optionalAsync.ts
                function optionalAsync(wrapped, ...args) {
                  const schema = {
                    kind: "schema",
                    type: "optional",
                    reference: optionalAsync,
                    expects: `${wrapped.expects} | undefined`,
                    async: true,
                    wrapped,
                    async _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        if ("default" in this) {
                          dataset.value = await getDefault(
                            this,
                            dataset,
                            config2
                          );
                        }
                        if (dataset.value === void 0) {
                          dataset.typed = true;
                          return dataset;
                        }
                      }
                      return this.wrapped._run(dataset, config2);
                    }
                  };
                  if (0 in args) {
                    schema.default = args[0];
                  }
                  return schema;
                }

                // src/schemas/picklist/picklist.ts
                function picklist(options, message) {
                  return {
                    kind: "schema",
                    type: "picklist",
                    reference: picklist,
                    expects: options.map(_stringify).join(" | ") || "never",
                    async: false,
                    options,
                    message,
                    _run(dataset, config2) {
                      if (this.options.includes(dataset.value)) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/promise/promise.ts
                function promise(message) {
                  return {
                    kind: "schema",
                    type: "promise",
                    reference: promise,
                    expects: "Promise",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value instanceof Promise) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/record/record.ts
                function record(key, value2, message) {
                  return {
                    kind: "schema",
                    type: "record",
                    reference: record,
                    expects: "Object",
                    async: false,
                    key,
                    value: value2,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        for (const entryKey in input) {
                          if (_isValidObjectKey(input, entryKey)) {
                            const entryValue = input[entryKey];
                            const keyDataset = this.key._run(
                              { typed: false, value: entryKey },
                              config2
                            );
                            if (keyDataset.issues) {
                              const pathItem = {
                                type: "object",
                                origin: "key",
                                input,
                                key: entryKey,
                                value: entryValue
                              };
                              for (const issue of keyDataset.issues) {
                                issue.path = [pathItem];
                                dataset.issues?.push(issue);
                              }
                              if (!dataset.issues) {
                                dataset.issues = keyDataset.issues;
                              }
                              if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                              }
                            }
                            const valueDataset = this.value._run(
                              { typed: false, value: entryValue },
                              config2
                            );
                            if (valueDataset.issues) {
                              const pathItem = {
                                type: "object",
                                origin: "value",
                                input,
                                key: entryKey,
                                value: entryValue
                              };
                              for (const issue of valueDataset.issues) {
                                if (issue.path) {
                                  issue.path.unshift(pathItem);
                                } else {
                                  issue.path = [pathItem];
                                }
                                dataset.issues?.push(issue);
                              }
                              if (!dataset.issues) {
                                dataset.issues = valueDataset.issues;
                              }
                              if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                              }
                            }
                            if (!keyDataset.typed || !valueDataset.typed) {
                              dataset.typed = false;
                            }
                            if (keyDataset.typed) {
                              dataset.value[keyDataset.value] = valueDataset.value;
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/record/recordAsync.ts
                function recordAsync(key, value2, message) {
                  return {
                    kind: "schema",
                    type: "record",
                    reference: recordAsync,
                    expects: "Object",
                    async: true,
                    key,
                    value: value2,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        const datasets = await Promise.all(
                          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(
                            ([entryKey, entryValue]) => Promise.all([
                              entryKey,
                              entryValue,
                              this.key._run({ typed: false, value: entryKey }, config2),
                              this.value._run({ typed: false, value: entryValue }, config2)
                            ])
                          )
                        );
                        for (const [
                          entryKey,
                          entryValue,
                          keyDataset,
                          valueDataset
                        ] of datasets) {
                          if (keyDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "key",
                              input,
                              key: entryKey,
                              value: entryValue
                            };
                            for (const issue of keyDataset.issues) {
                              issue.path = [pathItem];
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = keyDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key: entryKey,
                              value: entryValue
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!keyDataset.typed || !valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (keyDataset.typed) {
                            dataset.value[keyDataset.value] = valueDataset.value;
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/set/set.ts
                function set(value2, message) {
                  return {
                    kind: "schema",
                    type: "set",
                    reference: set,
                    expects: "Set",
                    async: false,
                    value: value2,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input instanceof Set) {
                        dataset.typed = true;
                        dataset.value = /* @__PURE__ */ new Set();
                        for (const inputValue of input) {
                          const valueDataset = this.value._run(
                            { typed: false, value: inputValue },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "set",
                              origin: "value",
                              input,
                              key: null,
                              value: inputValue
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.add(valueDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/set/setAsync.ts
                function setAsync(value2, message) {
                  return {
                    kind: "schema",
                    type: "set",
                    reference: setAsync,
                    expects: "Set",
                    async: true,
                    value: value2,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input instanceof Set) {
                        dataset.typed = true;
                        dataset.value = /* @__PURE__ */ new Set();
                        const valueDatasets = await Promise.all(
                          [...input].map(
                            async (inputValue) => [
                              inputValue,
                              await this.value._run(
                                { typed: false, value: inputValue },
                                config2
                              )
                            ]
                          )
                        );
                        for (const [inputValue, valueDataset] of valueDatasets) {
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "set",
                              origin: "value",
                              input,
                              key: null,
                              value: inputValue
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.add(valueDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/strictObject/strictObject.ts
                function strictObject(entries, message) {
                  return {
                    kind: "schema",
                    type: "strict_object",
                    reference: strictObject,
                    expects: "Object",
                    async: false,
                    entries,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        for (const key in this.entries) {
                          const value2 = input[key];
                          const valueDataset = this.entries[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const key in input) {
                            if (!(key in this.entries)) {
                              const value2 = input[key];
                              _addIssue(this, "type", dataset, config2, {
                                input: value2,
                                expected: "never",
                                path: [
                                  {
                                    type: "object",
                                    origin: "value",
                                    input,
                                    key,
                                    value: value2
                                  }
                                ]
                              });
                              break;
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/strictObject/strictObjectAsync.ts
                function strictObjectAsync(entries, message) {
                  return {
                    kind: "schema",
                    type: "strict_object",
                    reference: strictObjectAsync,
                    expects: "Object",
                    async: true,
                    entries,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        dataset.typed = true;
                        dataset.value = {};
                        const valueDatasets = await Promise.all(
                          Object.entries(this.entries).map(async ([key, schema]) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await schema._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, valueDataset] of valueDatasets) {
                          if (valueDataset.issues) {
                            const pathItem = {
                              type: "object",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of valueDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = valueDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!valueDataset.typed) {
                            dataset.typed = false;
                          }
                          if (valueDataset.value !== void 0 || key in input) {
                            dataset.value[key] = valueDataset.value;
                          }
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const key in input) {
                            if (!(key in this.entries)) {
                              const value2 = input[key];
                              _addIssue(this, "type", dataset, config2, {
                                input: value2,
                                expected: "never",
                                path: [
                                  {
                                    type: "object",
                                    origin: "value",
                                    input,
                                    key,
                                    value: value2
                                  }
                                ]
                              });
                              break;
                            }
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/strictTuple/strictTuple.ts
                function strictTuple(items, message) {
                  return {
                    kind: "schema",
                    type: "strict_tuple",
                    reference: strictTuple,
                    expects: "Array",
                    async: false,
                    items,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        for (let key = 0; key < this.items.length; key++) {
                          const value2 = input[key];
                          const itemDataset = this.items[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                          const value2 = input[items.length];
                          _addIssue(this, "type", dataset, config2, {
                            input: value2,
                            expected: "never",
                            path: [
                              {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: value2
                              }
                            ]
                          });
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/strictTuple/strictTupleAsync.ts
                function strictTupleAsync(items, message) {
                  return {
                    kind: "schema",
                    type: "strict_tuple",
                    reference: strictTupleAsync,
                    expects: "Array",
                    async: true,
                    items,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        const itemDatasets = await Promise.all(
                          this.items.map(async (item, key) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await item._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, itemDataset] of itemDatasets) {
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {
                          const value2 = input[items.length];
                          _addIssue(this, "type", dataset, config2, {
                            input: value2,
                            expected: "never",
                            path: [
                              {
                                type: "array",
                                origin: "value",
                                input,
                                key: this.items.length,
                                value: value2
                              }
                            ]
                          });
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/string/string.ts
                function string(message) {
                  return {
                    kind: "schema",
                    type: "string",
                    reference: string,
                    expects: "string",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "string") {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/symbol/symbol.ts
                function symbol(message) {
                  return {
                    kind: "schema",
                    type: "symbol",
                    reference: symbol,
                    expects: "symbol",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (typeof dataset.value === "symbol") {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/tuple/tuple.ts
                function tuple(items, message) {
                  return {
                    kind: "schema",
                    type: "tuple",
                    reference: tuple,
                    expects: "Array",
                    async: false,
                    items,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        for (let key = 0; key < this.items.length; key++) {
                          const value2 = input[key];
                          const itemDataset = this.items[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/tuple/tupleAsync.ts
                function tupleAsync(items, message) {
                  return {
                    kind: "schema",
                    type: "tuple",
                    reference: tupleAsync,
                    expects: "Array",
                    async: true,
                    items,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        const itemDatasets = await Promise.all(
                          this.items.map(async (item, key) => {
                            const value2 = input[key];
                            return [
                              key,
                              value2,
                              await item._run({ typed: false, value: value2 }, config2)
                            ];
                          })
                        );
                        for (const [key, value2, itemDataset] of itemDatasets) {
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/tupleWithRest/tupleWithRest.ts
                function tupleWithRest(items, rest, message) {
                  return {
                    kind: "schema",
                    type: "tuple_with_rest",
                    reference: tupleWithRest,
                    expects: "Array",
                    async: false,
                    items,
                    rest,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        for (let key = 0; key < this.items.length; key++) {
                          const value2 = input[key];
                          const itemDataset = this.items[key]._run(
                            { typed: false, value: value2 },
                            config2
                          );
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (let key = this.items.length; key < input.length; key++) {
                            const value2 = input[key];
                            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);
                            if (itemDataset.issues) {
                              const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                              };
                              for (const issue of itemDataset.issues) {
                                if (issue.path) {
                                  issue.path.unshift(pathItem);
                                } else {
                                  issue.path = [pathItem];
                                }
                                dataset.issues?.push(issue);
                              }
                              if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                              }
                              if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                              }
                            }
                            if (!itemDataset.typed) {
                              dataset.typed = false;
                            }
                            dataset.value.push(itemDataset.value);
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/tupleWithRest/tupleWithRestAsync.ts
                function tupleWithRestAsync(items, rest, message) {
                  return {
                    kind: "schema",
                    type: "tuple_with_rest",
                    reference: tupleWithRestAsync,
                    expects: "Array",
                    async: true,
                    items,
                    rest,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (Array.isArray(input)) {
                        dataset.typed = true;
                        dataset.value = [];
                        const [normalDatasets, restDatasets] = await Promise.all([
                          // Parse schema of each normal item
                          Promise.all(
                            this.items.map(async (item, key) => {
                              const value2 = input[key];
                              return [
                                key,
                                value2,
                                await item._run({ typed: false, value: value2 }, config2)
                              ];
                            })
                          ),
                          // Parse other items with rest schema
                          Promise.all(
                            input.slice(this.items.length).map(async (value2, key) => {
                              return [
                                key + this.items.length,
                                value2,
                                await this.rest._run({ typed: false, value: value2 }, config2)
                              ];
                            })
                          )
                        ]);
                        for (const [key, value2, itemDataset] of normalDatasets) {
                          if (itemDataset.issues) {
                            const pathItem = {
                              type: "array",
                              origin: "value",
                              input,
                              key,
                              value: value2
                            };
                            for (const issue of itemDataset.issues) {
                              if (issue.path) {
                                issue.path.unshift(pathItem);
                              } else {
                                issue.path = [pathItem];
                              }
                              dataset.issues?.push(issue);
                            }
                            if (!dataset.issues) {
                              dataset.issues = itemDataset.issues;
                            }
                            if (config2.abortEarly) {
                              dataset.typed = false;
                              break;
                            }
                          }
                          if (!itemDataset.typed) {
                            dataset.typed = false;
                          }
                          dataset.value.push(itemDataset.value);
                        }
                        if (!dataset.issues || !config2.abortEarly) {
                          for (const [key, value2, itemDataset] of restDatasets) {
                            if (itemDataset.issues) {
                              const pathItem = {
                                type: "array",
                                origin: "value",
                                input,
                                key,
                                value: value2
                              };
                              for (const issue of itemDataset.issues) {
                                if (issue.path) {
                                  issue.path.unshift(pathItem);
                                } else {
                                  issue.path = [pathItem];
                                }
                                dataset.issues?.push(issue);
                              }
                              if (!dataset.issues) {
                                dataset.issues = itemDataset.issues;
                              }
                              if (config2.abortEarly) {
                                dataset.typed = false;
                                break;
                              }
                            }
                            if (!itemDataset.typed) {
                              dataset.typed = false;
                            }
                            dataset.value.push(itemDataset.value);
                          }
                        }
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/undefined/undefined.ts
                function undefined_(message) {
                  return {
                    kind: "schema",
                    type: "undefined",
                    reference: undefined_,
                    expects: "undefined",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/union/utils/_subIssues/_subIssues.ts
                function _subIssues(datasets) {
                  let issues;
                  if (datasets) {
                    for (const dataset of datasets) {
                      if (issues) {
                        issues.push(...dataset.issues);
                      } else {
                        issues = dataset.issues;
                      }
                    }
                  }
                  return issues;
                }

                // src/schemas/union/union.ts
                function union(options, message) {
                  return {
                    kind: "schema",
                    type: "union",
                    reference: union,
                    expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
                    async: false,
                    options,
                    message,
                    _run(dataset, config2) {
                      let validDataset;
                      let typedDatasets;
                      let untypedDatasets;
                      for (const schema of this.options) {
                        const optionDataset = schema._run(
                          { typed: false, value: dataset.value },
                          config2
                        );
                        if (optionDataset.typed) {
                          if (optionDataset.issues) {
                            if (typedDatasets) {
                              typedDatasets.push(optionDataset);
                            } else {
                              typedDatasets = [optionDataset];
                            }
                          } else {
                            validDataset = optionDataset;
                            break;
                          }
                        } else {
                          if (untypedDatasets) {
                            untypedDatasets.push(optionDataset);
                          } else {
                            untypedDatasets = [optionDataset];
                          }
                        }
                      }
                      if (validDataset) {
                        return validDataset;
                      }
                      if (typedDatasets) {
                        if (typedDatasets.length === 1) {
                          return typedDatasets[0];
                        }
                        _addIssue(this, "type", dataset, config2, {
                          issues: _subIssues(typedDatasets)
                        });
                        dataset.typed = true;
                      } else if (untypedDatasets?.length === 1) {
                        return untypedDatasets[0];
                      } else {
                        _addIssue(this, "type", dataset, config2, {
                          issues: _subIssues(untypedDatasets)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/union/unionAsync.ts
                function unionAsync(options, message) {
                  return {
                    kind: "schema",
                    type: "union",
                    reference: unionAsync,
                    expects: [...new Set(options.map((option) => option.expects))].join(" | ") || "never",
                    async: true,
                    options,
                    message,
                    async _run(dataset, config2) {
                      let validDataset;
                      let typedDatasets;
                      let untypedDatasets;
                      for (const schema of this.options) {
                        const optionDataset = await schema._run(
                          { typed: false, value: dataset.value },
                          config2
                        );
                        if (optionDataset.typed) {
                          if (optionDataset.issues) {
                            if (typedDatasets) {
                              typedDatasets.push(optionDataset);
                            } else {
                              typedDatasets = [optionDataset];
                            }
                          } else {
                            validDataset = optionDataset;
                            break;
                          }
                        } else {
                          if (untypedDatasets) {
                            untypedDatasets.push(optionDataset);
                          } else {
                            untypedDatasets = [optionDataset];
                          }
                        }
                      }
                      if (validDataset) {
                        return validDataset;
                      }
                      if (typedDatasets) {
                        if (typedDatasets.length === 1) {
                          return typedDatasets[0];
                        }
                        _addIssue(this, "type", dataset, config2, {
                          issues: _subIssues(typedDatasets)
                        });
                        dataset.typed = true;
                      } else if (untypedDatasets?.length === 1) {
                        return untypedDatasets[0];
                      } else {
                        _addIssue(this, "type", dataset, config2, {
                          issues: _subIssues(untypedDatasets)
                        });
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/unknown/unknown.ts
                function unknown() {
                  return {
                    kind: "schema",
                    type: "unknown",
                    reference: unknown,
                    expects: "unknown",
                    async: false,
                    _run(dataset) {
                      dataset.typed = true;
                      return dataset;
                    }
                  };
                }

                // src/schemas/variant/utils/_discriminators/_discriminators.ts
                function _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {
                  for (const schema of options) {
                    if (schema.type === "variant") {
                      _discriminators(key, schema.options, set2);
                    } else {
                      set2.add(schema.entries[key].expects);
                    }
                  }
                  return set2;
                }

                // src/schemas/variant/variant.ts
                function variant(key, options, message) {
                  let expectedDiscriminators;
                  return {
                    kind: "schema",
                    type: "variant",
                    reference: variant,
                    expects: "Object",
                    async: false,
                    key,
                    options,
                    message,
                    _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        const discriminator = input[this.key];
                        if (this.key in input) {
                          let outputDataset;
                          for (const schema of this.options) {
                            if (schema.type === "variant" || !schema.entries[this.key]._run(
                              { typed: false, value: discriminator },
                              config2
                            ).issues) {
                              const optionDataset = schema._run(
                                { typed: false, value: input },
                                config2
                              );
                              if (!optionDataset.issues) {
                                return optionDataset;
                              }
                              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                outputDataset = optionDataset;
                              }
                            }
                          }
                          if (outputDataset) {
                            return outputDataset;
                          }
                        }
                        if (!expectedDiscriminators) {
                          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(" | ") || "never";
                        }
                        _addIssue(this, "type", dataset, config2, {
                          input: discriminator,
                          expected: expectedDiscriminators,
                          path: [
                            {
                              type: "object",
                              origin: "value",
                              input,
                              key: this.key,
                              value: discriminator
                            }
                          ]
                        });
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/variant/variantAsync.ts
                function variantAsync(key, options, message) {
                  let expectedDiscriminators;
                  return {
                    kind: "schema",
                    type: "variant",
                    reference: variantAsync,
                    expects: "Object",
                    async: true,
                    key,
                    options,
                    message,
                    async _run(dataset, config2) {
                      const input = dataset.value;
                      if (input && typeof input === "object") {
                        const discriminator = input[this.key];
                        if (this.key in input) {
                          let outputDataset;
                          for (const schema of this.options) {
                            if (schema.type === "variant" || !(await schema.entries[this.key]._run(
                              { typed: false, value: discriminator },
                              config2
                            )).issues) {
                              const optionDataset = await schema._run(
                                { typed: false, value: input },
                                config2
                              );
                              if (!optionDataset.issues) {
                                return optionDataset;
                              }
                              if (!outputDataset || !outputDataset.typed && optionDataset.typed) {
                                outputDataset = optionDataset;
                              }
                            }
                          }
                          if (outputDataset) {
                            return outputDataset;
                          }
                        }
                        if (!expectedDiscriminators) {
                          expectedDiscriminators = [..._discriminators(this.key, this.options)].join(" | ") || "never";
                        }
                        _addIssue(this, "type", dataset, config2, {
                          input: discriminator,
                          expected: expectedDiscriminators,
                          path: [
                            {
                              type: "object",
                              origin: "value",
                              input,
                              key: this.key,
                              value: discriminator
                            }
                          ]
                        });
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/schemas/void/void.ts
                function void_(message) {
                  return {
                    kind: "schema",
                    type: "void",
                    reference: void_,
                    expects: "void",
                    async: false,
                    message,
                    _run(dataset, config2) {
                      if (dataset.value === void 0) {
                        dataset.typed = true;
                      } else {
                        _addIssue(this, "type", dataset, config2);
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/keyof/keyof.ts
                function keyof(schema, message) {
                  return picklist(Object.keys(schema.entries), message);
                }

                // src/methods/omit/omit.ts
                function omit(schema, keys) {
                  const entries = {
                    ...schema.entries
                  };
                  for (const key of keys) {
                    delete entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/parse/parse.ts
                function parse(schema, input, config2) {
                  const dataset = schema._run(
                    { typed: false, value: input },
                    getGlobalConfig(config2)
                  );
                  if (dataset.issues) {
                    throw new ValiError(dataset.issues);
                  }
                  return dataset.value;
                }

                // src/methods/parse/parseAsync.ts
                async function parseAsync(schema, input, config2) {
                  const dataset = await schema._run(
                    { typed: false, value: input },
                    getGlobalConfig(config2)
                  );
                  if (dataset.issues) {
                    throw new ValiError(dataset.issues);
                  }
                  return dataset.value;
                }

                // src/methods/parser/parser.ts
                function parser(schema, config2) {
                  const func = (input) => parse(schema, input, config2);
                  func.schema = schema;
                  func.config = config2;
                  return func;
                }

                // src/methods/parser/parserAsync.ts
                function parserAsync(schema, config2) {
                  const func = (input) => parseAsync(schema, input, config2);
                  func.schema = schema;
                  func.config = config2;
                  return func;
                }

                // src/methods/partial/partial.ts
                function partial(schema, keys) {
                  const entries = {};
                  for (const key in schema.entries) {
                    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/partial/partialAsync.ts
                function partialAsync(schema, keys) {
                  const entries = {};
                  for (const key in schema.entries) {
                    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/pick/pick.ts
                function pick(schema, keys) {
                  const entries = {};
                  for (const key of keys) {
                    entries[key] = schema.entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/pipe/pipe.ts
                function pipe(...pipe2) {
                  return {
                    ...pipe2[0],
                    pipe: pipe2,
                    _run(dataset, config2) {
                      for (const item of pipe2) {
                        if (item.kind !== "metadata") {
                          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                            dataset.typed = false;
                            break;
                          }
                          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                            dataset = item._run(dataset, config2);
                          }
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/pipe/pipeAsync.ts
                function pipeAsync(...pipe2) {
                  return {
                    ...pipe2[0],
                    pipe: pipe2,
                    async: true,
                    async _run(dataset, config2) {
                      for (const item of pipe2) {
                        if (item.kind !== "metadata") {
                          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
                            dataset.typed = false;
                            break;
                          }
                          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
                            dataset = await item._run(dataset, config2);
                          }
                        }
                      }
                      return dataset;
                    }
                  };
                }

                // src/methods/required/required.ts
                function required(schema, arg2, arg3) {
                  const keys = Array.isArray(arg2) ? arg2 : void 0;
                  const message = Array.isArray(arg2) ? arg3 : arg2;
                  const entries = {};
                  for (const key in schema.entries) {
                    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/required/requiredAsync.ts
                function requiredAsync(schema, arg2, arg3) {
                  const keys = Array.isArray(arg2) ? arg2 : void 0;
                  const message = Array.isArray(arg2) ? arg3 : arg2;
                  const entries = {};
                  for (const key in schema.entries) {
                    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];
                  }
                  return { ...schema, entries };
                }

                // src/methods/safeParse/safeParse.ts
                function safeParse(schema, input, config2) {
                  const dataset = schema._run(
                    { typed: false, value: input },
                    getGlobalConfig(config2)
                  );
                  return {
                    typed: dataset.typed,
                    success: !dataset.issues,
                    output: dataset.value,
                    issues: dataset.issues
                  };
                }

                // src/methods/safeParse/safeParseAsync.ts
                async function safeParseAsync(schema, input, config2) {
                  const dataset = await schema._run(
                    { typed: false, value: input },
                    getGlobalConfig(config2)
                  );
                  return {
                    typed: dataset.typed,
                    success: !dataset.issues,
                    output: dataset.value,
                    issues: dataset.issues
                  };
                }

                // src/methods/safeParser/safeParser.ts
                function safeParser(schema, config2) {
                  const func = (input) => safeParse(schema, input, config2);
                  func.schema = schema;
                  func.config = config2;
                  return func;
                }

                // src/methods/safeParser/safeParserAsync.ts
                function safeParserAsync(schema, config2) {
                  const func = (input) => safeParseAsync(schema, input, config2);
                  func.schema = schema;
                  func.config = config2;
                  return func;
                }

                // src/methods/unwrap/unwrap.ts
                function unwrap(schema) {
                  return schema.wrapped;
                }
                return {
                  BASE64_REGEX,
                  BIC_REGEX,
                  CUID2_REGEX,
                  DECIMAL_REGEX,
                  EMAIL_REGEX,
                  EMOJI_REGEX,
                  HEXADECIMAL_REGEX,
                  HEX_COLOR_REGEX,
                  IMEI_REGEX,
                  IPV4_REGEX,
                  IPV6_REGEX,
                  IP_REGEX,
                  ISO_DATE_REGEX,
                  ISO_DATE_TIME_REGEX,
                  ISO_TIMESTAMP_REGEX,
                  ISO_TIME_REGEX,
                  ISO_TIME_SECOND_REGEX,
                  ISO_WEEK_REGEX,
                  MAC48_REGEX,
                  MAC64_REGEX,
                  MAC_REGEX,
                  OCTAL_REGEX,
                  ULID_REGEX,
                  UUID_REGEX,
                  ValiError,
                  _addIssue,
                  _isLuhnAlgo,
                  _isValidObjectKey,
                  _stringify,
                  any,
                  array,
                  arrayAsync,
                  awaitAsync,
                  base64,
                  bic,
                  bigint,
                  blob,
                  boolean,
                  brand,
                  bytes,
                  check,
                  checkAsync,
                  checkItems,
                  config,
                  creditCard,
                  cuid2,
                  custom,
                  customAsync,
                  date,
                  decimal,
                  deleteGlobalConfig,
                  deleteGlobalMessage,
                  deleteSchemaMessage,
                  deleteSpecificMessage,
                  description,
                  email,
                  emoji,
                  empty,
                  endsWith,
                  entriesFromList,
                  'enum': enum_,
                  enum_,
                  everyItem,
                  excludes,
                  fallback,
                  fallbackAsync,
                  file,
                  filterItems,
                  findItem,
                  finite,
                  flatten,
                  forward,
                  forwardAsync,
                  'function': function_,
                  function_,
                  getDefault,
                  getDefaults,
                  getDefaultsAsync,
                  getDotPath,
                  getFallback,
                  getFallbacks,
                  getFallbacksAsync,
                  getGlobalConfig,
                  getGlobalMessage,
                  getSchemaMessage,
                  getSpecificMessage,
                  hash,
                  hexColor,
                  hexadecimal,
                  imei,
                  includes,
                  instance,
                  integer,
                  intersect,
                  intersectAsync,
                  ip,
                  ipv4,
                  ipv6,
                  is,
                  isOfKind,
                  isOfType,
                  isValiError,
                  isoDate,
                  isoDateTime,
                  isoTime,
                  isoTimeSecond,
                  isoTimestamp,
                  isoWeek,
                  keyof,
                  lazy,
                  lazyAsync,
                  length,
                  literal,
                  looseObject,
                  looseObjectAsync,
                  looseTuple,
                  looseTupleAsync,
                  mac,
                  mac48,
                  mac64,
                  map,
                  mapAsync,
                  mapItems,
                  maxBytes,
                  maxLength,
                  maxSize,
                  maxValue,
                  mimeType,
                  minBytes,
                  minLength,
                  minSize,
                  minValue,
                  multipleOf,
                  nan,
                  never,
                  nonEmpty,
                  nonNullable,
                  nonNullableAsync,
                  nonNullish,
                  nonNullishAsync,
                  nonOptional,
                  nonOptionalAsync,
                  normalize,
                  notBytes,
                  notLength,
                  notSize,
                  notValue,
                  'null': null_,
                  null_,
                  nullable,
                  nullableAsync,
                  nullish,
                  nullishAsync,
                  number,
                  object,
                  objectAsync,
                  objectWithRest,
                  objectWithRestAsync,
                  octal,
                  omit,
                  optional,
                  optionalAsync,
                  parse,
                  parseAsync,
                  parser,
                  parserAsync,
                  partial,
                  partialAsync,
                  partialCheck,
                  partialCheckAsync,
                  pick,
                  picklist,
                  pipe,
                  pipeAsync,
                  promise,
                  rawCheck,
                  rawCheckAsync,
                  rawTransform,
                  rawTransformAsync,
                  readonly,
                  record,
                  recordAsync,
                  reduceItems,
                  regex,
                  required,
                  requiredAsync,
                  safeInteger,
                  safeParse,
                  safeParseAsync,
                  safeParser,
                  safeParserAsync,
                  set,
                  setAsync,
                  setGlobalConfig,
                  setGlobalMessage,
                  setSchemaMessage,
                  setSpecificMessage,
                  size,
                  someItem,
                  sortItems,
                  startsWith,
                  strictObject,
                  strictObjectAsync,
                  strictTuple,
                  strictTupleAsync,
                  string,
                  symbol,
                  toLowerCase,
                  toMaxValue,
                  toMinValue,
                  toUpperCase,
                  transform,
                  transformAsync,
                  trim,
                  trimEnd,
                  trimStart,
                  tuple,
                  tupleAsync,
                  tupleWithRest,
                  tupleWithRestAsync,
                  ulid,
                  'undefined': undefined_,
                  undefined_,
                  union,
                  unionAsync,
                  unknown,
                  unwrap,
                  url,
                  uuid,
                  value,
                  variant,
                  variantAsync,
                  'void': void_,
                  void_
                };
            })();
        </script>
        <script type="text/javascript">
            /**
             * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
             * Original file: /npm/wif@5.0.0/src/esm/index.js
             *
             * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
             */
            var wif = (() => {
                function decodeRaw(buffer, version) {
                    // check version only if defined
                    if (version !== undefined && buffer[0] !== version)
                        throw new Error('Invalid network version');
                    // uncompressed
                    if (buffer.length === 33) {
                        return {
                            version: buffer[0],
                            privateKey: buffer.slice(1, 33),
                            compressed: false
                        };
                    }
                    // invalid length
                    if (buffer.length !== 34)
                        throw new Error('Invalid WIF length');
                    // invalid compression flag
                    if (buffer[33] !== 0x01)
                        throw new Error('Invalid compression flag');
                    return {
                        version: buffer[0],
                        privateKey: buffer.slice(1, 33),
                        compressed: true
                    };
                }
                function encodeRaw(version, privateKey, compressed) {
                    if (privateKey.length !== 32)
                        throw new TypeError('Invalid privateKey length');
                    var result = new Uint8Array(compressed ? 34 : 33);
                    var view = new DataView(result.buffer);
                    view.setUint8(0, version);
                    result.set(privateKey, 1);
                    if (compressed) {
                        result[33] = 0x01;
                    }
                    return result;
                }
                function decode(str, version) {
                    return decodeRaw(bs58check.decode(str), version);
                }
                function encode(wif) {
                    return bs58check.encode(encodeRaw(wif.version, wif.privateKey, wif.compressed));
                }
                return { decodeRaw, encodeRaw, decode, encode };
            })();
        </script>
        <script type="text/javascript">
            var bitcoin;
/******/ "use strict";
/******/ var __webpack_modules__ = ({

/***/ "./src/analyze/crypto/algorithm/ripemd160.js"
/*!***************************************************!*\
  !*** ./src/analyze/crypto/algorithm/ripemd160.js ***!
  \***************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var hashes = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
function ripemd160(blocks) {
  var status = hashes.slice();
  for (var i = 0; i < blocks.length; i += 16) {
    var _status = status,
      _status2 = _slicedToArray(_status, 5),
      A1 = _status2[0],
      B1 = _status2[1],
      C1 = _status2[2],
      D1 = _status2[3],
      E1 = _status2[4];
    var _status3 = status,
      _status4 = _slicedToArray(_status3, 5),
      A2 = _status4[0],
      B2 = _status4[1],
      C2 = _status4[2],
      D2 = _status4[3],
      E2 = _status4[4];
    for (var j = 0; j <= 79; ++j) {
      var T = safe_add(A1, rmd160_f(j, B1, C1, D1));
      T = safe_add(T, blocks[i + rmd160_r1[j]]);
      T = safe_add(T, rmd160_K1(j));
      T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
      A1 = E1;
      E1 = D1;
      D1 = bit_rol(C1, 10);
      C1 = B1;
      B1 = T;
      T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
      T = safe_add(T, blocks[i + rmd160_r2[j]]);
      T = safe_add(T, rmd160_K2(j));
      T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
      A2 = E2;
      E2 = D2;
      D2 = bit_rol(C2, 10);
      C2 = B2;
      B2 = T;
    }
    status = [safe_add(status[1], safe_add(C1, D2)), safe_add(status[2], safe_add(D1, E2)), safe_add(status[3], safe_add(E1, A2)), safe_add(status[4], safe_add(A1, B2)), safe_add(status[0], safe_add(B1, C2))];
  }
  var output = [];
  for (var _i = 0; _i < status.length * 32; _i += 8) output.push(status[_i >> 5] >>> _i % 32 & 0xff);
  return new Uint8Array(output);
}
function rmd160_f(j, x, y, z) {
  return 0 <= j && j <= 15 ? x ^ y ^ z : 16 <= j && j <= 31 ? x & y | ~x & z : 32 <= j && j <= 47 ? (x | ~y) ^ z : 48 <= j && j <= 63 ? x & z | y & ~z : 64 <= j && j <= 79 ? x ^ (y | ~z) : "rmd160_f: j out of range";
}
function rmd160_K1(j) {
  return 0 <= j && j <= 15 ? 0x00000000 : 16 <= j && j <= 31 ? 0x5a827999 : 32 <= j && j <= 47 ? 0x6ed9eba1 : 48 <= j && j <= 63 ? 0x8f1bbcdc : 64 <= j && j <= 79 ? 0xa953fd4e : "rmd160_K1: j out of range";
}
function rmd160_K2(j) {
  return 0 <= j && j <= 15 ? 0x50a28be6 : 16 <= j && j <= 31 ? 0x5c4dd124 : 32 <= j && j <= 47 ? 0x6d703ef3 : 48 <= j && j <= 63 ? 0x7a6d76e9 : 64 <= j && j <= 79 ? 0x00000000 : "rmd160_K2: j out of range";
}
var rmd160_r1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rmd160_r2 = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var rmd160_s1 = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var rmd160_s2 = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
function safe_add(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}
function bit_rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function bytesToLWords(bytes) {
  var n = bytes.length;
  var output = Array(n >> 2);
  for (var i = 0; i < output.length; i++) output[i] = 0;
  for (var _i2 = 0; _i2 < bytes.length * 8; _i2 += 8) output[_i2 >> 5] |= (bytes[_i2 / 8] & 0xFF) << _i2 % 32;
  var len = n * 8;
  output[len >> 5] |= 0x80 << len % 32;
  output[(len + 64 >>> 9 << 4) + 14] = len;
  return output;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(bytes) {
  return ripemd160(bytesToLWords(bytes));
}
;

/***/ },

/***/ "./src/analyze/crypto/algorithm/sha256.js"
/*!************************************************!*\
  !*** ./src/analyze/crypto/algorithm/sha256.js ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bitcoin_v5_hash_sha_256_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bitcoin/v5/hash/sha/256.js */ "./src/analyze/crypto/bitcoin/v5/hash/sha/256.js");

function sha256(msg) {
  return new Uint8Array((0,_bitcoin_v5_hash_sha_256_js__WEBPACK_IMPORTED_MODULE_0__["default"])().update(new Uint8Array(msg)).digest());
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha256);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/bech32@2.0.0.js"
/*!*******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/bech32@2.0.0.js ***!
  \*******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __esModule: () => (/* binding */ a),
/* harmony export */   bech32: () => (/* binding */ l),
/* harmony export */   bech32m: () => (/* binding */ t),
/* harmony export */   "default": () => (/* binding */ r)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var r = {};
Object.defineProperty(r, "__esModule", {
  value: !0
});
var t = r.bech32m = r.bech32 = void 0;
var e = "qpzry9x8gf2tvdw0s3jn54khce6mua7l",
  n = {};
for (var _r = 0; _r < 32; _r++) {
  var _t = e.charAt(_r);
  n[_t] = _r;
}
function o(r) {
  var t = r >> 25;
  return (33554431 & r) << 5 ^ 996825010 & -(1 & t) ^ 642813549 & -(t >> 1 & 1) ^ 513874426 & -(t >> 2 & 1) ^ 1027748829 & -(t >> 3 & 1) ^ 705979059 & -(t >> 4 & 1);
}
function c(r) {
  var t = 1;
  for (var _e = 0; _e < r.length; ++_e) {
    var _n = r.charCodeAt(_e);
    if (_n < 33 || _n > 126) return "Invalid prefix (" + r + ")";
    t = o(t) ^ _n >> 5;
  }
  t = o(t);
  for (var _e2 = 0; _e2 < r.length; ++_e2) {
    var _n2 = r.charCodeAt(_e2);
    t = o(t) ^ 31 & _n2;
  }
  return t;
}
function f(r, t, e, n) {
  var o = 0,
    c = 0;
  var f = (1 << e) - 1,
    i = [];
  for (var _n3 = 0; _n3 < r.length; ++_n3) for (o = o << t | r[_n3], c += t; c >= e;) c -= e, i.push(o >> c & f);
  if (n) c > 0 && i.push(o << e - c & f);else {
    if (c >= t) return "Excess padding";
    if (o << e - c & f) return "Non-zero padding";
  }
  return i;
}
function i(r) {
  return f(r, 8, 5, !0);
}
function s(r) {
  var t = f(r, 5, 8, !1);
  if (Array.isArray(t)) return t;
}
function u(r) {
  var t = f(r, 5, 8, !1);
  if (Array.isArray(t)) return t;
  throw new Error(t);
}
function h(r) {
  var t;
  function f(r, e) {
    if (e = e || 90, r.length < 8) return r + " too short";
    if (r.length > e) return "Exceeds length limit";
    var f = r.toLowerCase(),
      i = r.toUpperCase();
    if (r !== f && r !== i) return "Mixed-case string " + r;
    var s = (r = f).lastIndexOf("1");
    if (-1 === s) return "No separator character for " + r;
    if (0 === s) return "Missing prefix for " + r;
    var u = r.slice(0, s),
      h = r.slice(s + 1);
    if (h.length < 6) return "Data too short";
    var l = c(u);
    if ("string" == typeof l) return l;
    var a = [];
    for (var _r2 = 0; _r2 < h.length; ++_r2) {
      var _t2 = h.charAt(_r2),
        _e3 = n[_t2];
      if (void 0 === _e3) return "Unknown character " + _t2;
      l = o(l) ^ _e3, _r2 + 6 >= h.length || a.push(_e3);
    }
    return l !== t ? "Invalid checksum for " + r : {
      prefix: u,
      words: a
    };
  }
  return t = "bech32" === r ? 1 : 734539939, {
    decodeUnsafe: function decodeUnsafe(r, t) {
      var e = f(r, t);
      if ("object" == _typeof(e)) return e;
    },
    decode: function decode(r, t) {
      var e = f(r, t);
      if ("object" == _typeof(e)) return e;
      throw new Error(e);
    },
    encode: function encode(r, n, f) {
      if (f = f || 90, r.length + 7 + n.length > f) throw new TypeError("Exceeds length limit");
      var i = c(r = r.toLowerCase());
      if ("string" == typeof i) throw new Error(i);
      var s = r + "1";
      for (var _r3 = 0; _r3 < n.length; ++_r3) {
        var _t3 = n[_r3];
        if (_t3 >> 5) throw new Error("Non 5-bit word");
        i = o(i) ^ _t3, s += e.charAt(_t3);
      }
      for (var _r4 = 0; _r4 < 6; ++_r4) i = o(i);
      i ^= t;
      for (var _r5 = 0; _r5 < 6; ++_r5) {
        s += e.charAt(i >> 5 * (5 - _r5) & 31);
      }
      return s;
    },
    toWords: i,
    fromWordsUnsafe: s,
    fromWords: u
  };
}
var l = r.bech32 = h("bech32");
t = r.bech32m = h("bech32m");
var a = r.__esModule;


/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/bip174@2.1.1.js"
/*!*******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/bip174@2.1.1.js ***!
  \*******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Psbt: () => (/* binding */ Ht),
/* harmony export */   __esModule: () => (/* binding */ qt),
/* harmony export */   "default": () => (/* binding */ re)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n0 = 0, F = function F() {}; return { s: F, n: function n() { return _n0 >= r.length ? { done: !0 } : { done: !1, value: r[_n0++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var e = "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {},
  t = [],
  r = [],
  n = "undefined" != typeof Uint8Array ? Uint8Array : Array,
  o = !1;
function i() {
  o = !0;
  for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0; n < 64; ++n) t[n] = e[n], r[e.charCodeAt(n)] = n;
  r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63;
}
function u(e, r, n) {
  for (var o, i, u = [], s = r; s < n; s += 3) o = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], u.push(t[(i = o) >> 18 & 63] + t[i >> 12 & 63] + t[i >> 6 & 63] + t[63 & i]);
  return u.join("");
}
function s(e) {
  var r;
  o || i();
  for (var n = e.length, s = n % 3, a = "", c = [], f = 16383, p = 0, l = n - s; p < l; p += f) c.push(u(e, p, p + f > l ? l : p + f));
  return 1 === s ? (r = e[n - 1], a += t[r >> 2], a += t[r << 4 & 63], a += "==") : 2 === s && (r = (e[n - 2] << 8) + e[n - 1], a += t[r >> 10], a += t[r >> 4 & 63], a += t[r << 2 & 63], a += "="), c.push(a), c.join("");
}
function a(e, t, r, n, o) {
  var i,
    u,
    s = 8 * o - n - 1,
    a = (1 << s) - 1,
    c = a >> 1,
    f = -7,
    p = r ? o - 1 : 0,
    l = r ? -1 : 1,
    h = e[t + p];
  for (p += l, i = h & (1 << -f) - 1, h >>= -f, f += s; f > 0; i = 256 * i + e[t + p], p += l, f -= 8);
  for (u = i & (1 << -f) - 1, i >>= -f, f += n; f > 0; u = 256 * u + e[t + p], p += l, f -= 8);
  if (0 === i) i = 1 - c;else {
    if (i === a) return u ? NaN : 1 / 0 * (h ? -1 : 1);
    u += Math.pow(2, n), i -= c;
  }
  return (h ? -1 : 1) * u * Math.pow(2, i - n);
}
function c(e, t, r, n, o, i) {
  var u,
    s,
    a,
    c = 8 * i - o - 1,
    f = (1 << c) - 1,
    p = f >> 1,
    l = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    h = n ? 0 : i - 1,
    d = n ? 1 : -1,
    y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, u = f) : (u = Math.floor(Math.log(t) / Math.LN2), t * (a = Math.pow(2, -u)) < 1 && (u--, a *= 2), (t += u + p >= 1 ? l / a : l * Math.pow(2, 1 - p)) * a >= 2 && (u++, a /= 2), u + p >= f ? (s = 0, u = f) : u + p >= 1 ? (s = (t * a - 1) * Math.pow(2, o), u += p) : (s = t * Math.pow(2, p - 1) * Math.pow(2, o), u = 0)); o >= 8; e[r + h] = 255 & s, h += d, s /= 256, o -= 8);
  for (u = u << o | s, c += o; c > 0; e[r + h] = 255 & u, h += d, u /= 256, c -= 8);
  e[r + h - d] |= 128 * y;
}
var f = {}.toString,
  p = Array.isArray || function (e) {
    return "[object Array]" == f.call(e);
  };
function l() {
  return d.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function h(e, t) {
  if (l() < t) throw new RangeError("Invalid typed array length");
  return d.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = d.prototype : (null === e && (e = new d(t)), e.length = t), e;
}
function d(e, t, r) {
  if (!(d.TYPED_ARRAY_SUPPORT || this instanceof d)) return new d(e, t, r);
  if ("number" == typeof e) {
    if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
    return E(this, e);
  }
  return y(this, e, t, r);
}
function y(e, t, r, n) {
  if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, r, n) {
    if (t.byteLength, r < 0 || t.byteLength < r) throw new RangeError("'offset' is out of bounds");
    if (t.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
    t = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n);
    d.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = d.prototype : e = T(e, t);
    return e;
  }(e, t, r, n) : "string" == typeof t ? function (e, t, r) {
    "string" == typeof r && "" !== r || (r = "utf8");
    if (!d.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
    var n = 0 | k(t, r);
    e = h(e, n);
    var o = e.write(t, r);
    o !== n && (e = e.slice(0, o));
    return e;
  }(e, t, r) : function (e, t) {
    if (I(t)) {
      var r = 0 | w(t.length);
      return 0 === (e = h(e, r)).length || t.copy(e, 0, 0, r), e;
    }
    if (t) {
      if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (n = t.length) != n ? h(e, 0) : T(e, t);
      if ("Buffer" === t.type && p(t.data)) return T(e, t.data);
    }
    var n;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(e, t);
}
function g(e) {
  if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
  if (e < 0) throw new RangeError('"size" argument must not be negative');
}
function E(e, t) {
  if (g(t), e = h(e, t < 0 ? 0 : 0 | w(t)), !d.TYPED_ARRAY_SUPPORT) for (var r = 0; r < t; ++r) e[r] = 0;
  return e;
}
function T(e, t) {
  var r = t.length < 0 ? 0 : 0 | w(t.length);
  e = h(e, r);
  for (var n = 0; n < r; n += 1) e[n] = 255 & t[n];
  return e;
}
function w(e) {
  if (e >= l()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l().toString(16) + " bytes");
  return 0 | e;
}
function I(e) {
  return !(null == e || !e._isBuffer);
}
function k(e, t) {
  if (I(e)) return e.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
  "string" != typeof e && (e = "" + e);
  var r = e.length;
  if (0 === r) return 0;
  for (var n = !1;;) switch (t) {
    case "ascii":
    case "latin1":
    case "binary":
      return r;
    case "utf8":
    case "utf-8":
    case void 0:
      return q(e).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * r;
    case "hex":
      return r >>> 1;
    case "base64":
      return $(e).length;
    default:
      if (n) return q(e).length;
      t = ("" + t).toLowerCase(), n = !0;
  }
}
function S(e, t, r) {
  var n = !1;
  if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
  if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
  if ((r >>>= 0) <= (t >>>= 0)) return "";
  for (e || (e = "utf8");;) switch (e) {
    case "hex":
      return D(this, t, r);
    case "utf8":
    case "utf-8":
      return x(this, t, r);
    case "ascii":
      return L(this, t, r);
    case "latin1":
    case "binary":
      return M(this, t, r);
    case "base64":
      return U(this, t, r);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return K(this, t, r);
    default:
      if (n) throw new TypeError("Unknown encoding: " + e);
      e = (e + "").toLowerCase(), n = !0;
  }
}
function v(e, t, r) {
  var n = e[t];
  e[t] = e[r], e[r] = n;
}
function b(e, t, r, n, o) {
  if (0 === e.length) return -1;
  if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = o ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
    if (o) return -1;
    r = e.length - 1;
  } else if (r < 0) {
    if (!o) return -1;
    r = 0;
  }
  if ("string" == typeof t && (t = d.from(t, n)), I(t)) return 0 === t.length ? -1 : _(e, t, r, n, o);
  if ("number" == typeof t) return t &= 255, d.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : _(e, [t], r, n, o);
  throw new TypeError("val must be string, number or Buffer");
}
function _(e, t, r, n, o) {
  var i,
    u = 1,
    s = e.length,
    a = t.length;
  if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
    if (e.length < 2 || t.length < 2) return -1;
    u = 2, s /= 2, a /= 2, r /= 2;
  }
  function c(e, t) {
    return 1 === u ? e[t] : e.readUInt16BE(t * u);
  }
  if (o) {
    var f = -1;
    for (i = r; i < s; i++) if (c(e, i) === c(t, -1 === f ? 0 : i - f)) {
      if (-1 === f && (f = i), i - f + 1 === a) return f * u;
    } else -1 !== f && (i -= i - f), f = -1;
  } else for (r + a > s && (r = s - a), i = r; i >= 0; i--) {
    for (var p = !0, l = 0; l < a; l++) if (c(e, i + l) !== c(t, l)) {
      p = !1;
      break;
    }
    if (p) return i;
  }
  return -1;
}
function A(e, t, r, n) {
  r = Number(r) || 0;
  var o = e.length - r;
  n ? (n = Number(n)) > o && (n = o) : n = o;
  var i = t.length;
  if (i % 2 != 0) throw new TypeError("Invalid hex string");
  n > i / 2 && (n = i / 2);
  for (var u = 0; u < n; ++u) {
    var s = parseInt(t.substr(2 * u, 2), 16);
    if (isNaN(s)) return u;
    e[r + u] = s;
  }
  return u;
}
function m(e, t, r, n) {
  return z(q(t, e.length - r), e, r, n);
}
function P(e, t, r, n) {
  return z(function (e) {
    for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
    return t;
  }(t), e, r, n);
}
function R(e, t, r, n) {
  return P(e, t, r, n);
}
function O(e, t, r, n) {
  return z($(t), e, r, n);
}
function B(e, t, r, n) {
  return z(function (e, t) {
    for (var r, n, o, i = [], u = 0; u < e.length && !((t -= 2) < 0); ++u) n = (r = e.charCodeAt(u)) >> 8, o = r % 256, i.push(o), i.push(n);
    return i;
  }(t, e.length - r), e, r, n);
}
function U(e, t, r) {
  return 0 === t && r === e.length ? s(e) : s(e.slice(t, r));
}
function x(e, t, r) {
  r = Math.min(e.length, r);
  for (var n = [], o = t; o < r;) {
    var i,
      u,
      s,
      a,
      c = e[o],
      f = null,
      p = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
    if (o + p <= r) switch (p) {
      case 1:
        c < 128 && (f = c);
        break;
      case 2:
        128 == (192 & (i = e[o + 1])) && (a = (31 & c) << 6 | 63 & i) > 127 && (f = a);
        break;
      case 3:
        i = e[o + 1], u = e[o + 2], 128 == (192 & i) && 128 == (192 & u) && (a = (15 & c) << 12 | (63 & i) << 6 | 63 & u) > 2047 && (a < 55296 || a > 57343) && (f = a);
        break;
      case 4:
        i = e[o + 1], u = e[o + 2], s = e[o + 3], 128 == (192 & i) && 128 == (192 & u) && 128 == (192 & s) && (a = (15 & c) << 18 | (63 & i) << 12 | (63 & u) << 6 | 63 & s) > 65535 && a < 1114112 && (f = a);
    }
    null === f ? (f = 65533, p = 1) : f > 65535 && (f -= 65536, n.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), n.push(f), o += p;
  }
  return function (e) {
    var t = e.length;
    if (t <= N) return String.fromCharCode.apply(String, e);
    var r = "",
      n = 0;
    for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += N));
    return r;
  }(n);
}
d.TYPED_ARRAY_SUPPORT = void 0 === e.TYPED_ARRAY_SUPPORT || e.TYPED_ARRAY_SUPPORT, l(), d.poolSize = 8192, d._augment = function (e) {
  return e.__proto__ = d.prototype, e;
}, d.from = function (e, t, r) {
  return y(null, e, t, r);
}, d.TYPED_ARRAY_SUPPORT && (d.prototype.__proto__ = Uint8Array.prototype, d.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && d[Symbol.species]), d.alloc = function (e, t, r) {
  return function (e, t, r, n) {
    return g(t), t <= 0 ? h(e, t) : void 0 !== r ? "string" == typeof n ? h(e, t).fill(r, n) : h(e, t).fill(r) : h(e, t);
  }(null, e, t, r);
}, d.allocUnsafe = function (e) {
  return E(null, e);
}, d.allocUnsafeSlow = function (e) {
  return E(null, e);
}, d.isBuffer = function (e) {
  return null != e && (!!e._isBuffer || J(e) || function (e) {
    return "function" == typeof e.readFloatLE && "function" == typeof e.slice && J(e.slice(0, 0));
  }(e));
}, d.compare = function (e, t) {
  if (!I(e) || !I(t)) throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var r = e.length, n = t.length, o = 0, i = Math.min(r, n); o < i; ++o) if (e[o] !== t[o]) {
    r = e[o], n = t[o];
    break;
  }
  return r < n ? -1 : n < r ? 1 : 0;
}, d.isEncoding = function (e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, d.concat = function (e, t) {
  if (!p(e)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === e.length) return d.alloc(0);
  var r;
  if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
  var n = d.allocUnsafe(t),
    o = 0;
  for (r = 0; r < e.length; ++r) {
    var i = e[r];
    if (!I(i)) throw new TypeError('"list" argument must be an Array of Buffers');
    i.copy(n, o), o += i.length;
  }
  return n;
}, d.byteLength = k, d.prototype._isBuffer = !0, d.prototype.swap16 = function () {
  var e = this.length;
  if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2) v(this, t, t + 1);
  return this;
}, d.prototype.swap32 = function () {
  var e = this.length;
  if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4) v(this, t, t + 3), v(this, t + 1, t + 2);
  return this;
}, d.prototype.swap64 = function () {
  var e = this.length;
  if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8) v(this, t, t + 7), v(this, t + 1, t + 6), v(this, t + 2, t + 5), v(this, t + 3, t + 4);
  return this;
}, d.prototype.toString = function () {
  var e = 0 | this.length;
  return 0 === e ? "" : 0 === arguments.length ? x(this, 0, e) : S.apply(this, arguments);
}, d.prototype.equals = function (e) {
  if (!I(e)) throw new TypeError("Argument must be a Buffer");
  return this === e || 0 === d.compare(this, e);
}, d.prototype.inspect = function () {
  var e = "";
  return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">";
}, d.prototype.compare = function (e, t, r, n, o) {
  if (!I(e)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), t < 0 || r > e.length || n < 0 || o > this.length) throw new RangeError("out of range index");
  if (n >= o && t >= r) return 0;
  if (n >= o) return -1;
  if (t >= r) return 1;
  if (this === e) return 0;
  for (var i = (o >>>= 0) - (n >>>= 0), u = (r >>>= 0) - (t >>>= 0), s = Math.min(i, u), a = this.slice(n, o), c = e.slice(t, r), f = 0; f < s; ++f) if (a[f] !== c[f]) {
    i = a[f], u = c[f];
    break;
  }
  return i < u ? -1 : u < i ? 1 : 0;
}, d.prototype.includes = function (e, t, r) {
  return -1 !== this.indexOf(e, t, r);
}, d.prototype.indexOf = function (e, t, r) {
  return b(this, e, t, r, !0);
}, d.prototype.lastIndexOf = function (e, t, r) {
  return b(this, e, t, r, !1);
}, d.prototype.write = function (e, t, r, n) {
  if (void 0 === t) n = "utf8", r = this.length, t = 0;else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;else {
    if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    t |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0);
  }
  var o = this.length - t;
  if ((void 0 === r || r > o) && (r = o), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var i = !1;;) switch (n) {
    case "hex":
      return A(this, e, t, r);
    case "utf8":
    case "utf-8":
      return m(this, e, t, r);
    case "ascii":
      return P(this, e, t, r);
    case "latin1":
    case "binary":
      return R(this, e, t, r);
    case "base64":
      return O(this, e, t, r);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return B(this, e, t, r);
    default:
      if (i) throw new TypeError("Unknown encoding: " + n);
      n = ("" + n).toLowerCase(), i = !0;
  }
}, d.prototype.toJSON = function () {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
var N = 4096;
function L(e, t, r) {
  var n = "";
  r = Math.min(e.length, r);
  for (var o = t; o < r; ++o) n += String.fromCharCode(127 & e[o]);
  return n;
}
function M(e, t, r) {
  var n = "";
  r = Math.min(e.length, r);
  for (var o = t; o < r; ++o) n += String.fromCharCode(e[o]);
  return n;
}
function D(e, t, r) {
  var n = e.length;
  (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
  for (var o = "", i = t; i < r; ++i) o += H(e[i]);
  return o;
}
function K(e, t, r) {
  for (var n = e.slice(t, r), o = "", i = 0; i < n.length; i += 2) o += String.fromCharCode(n[i] + 256 * n[i + 1]);
  return o;
}
function C(e, t, r) {
  if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + t > r) throw new RangeError("Trying to access beyond buffer length");
}
function V(e, t, r, n, o, i) {
  if (!I(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > o || t < i) throw new RangeError('"value" argument is out of bounds');
  if (r + n > e.length) throw new RangeError("Index out of range");
}
function Y(e, t, r, n) {
  t < 0 && (t = 65535 + t + 1);
  for (var o = 0, i = Math.min(e.length - r, 2); o < i; ++o) e[r + o] = (t & 255 << 8 * (n ? o : 1 - o)) >>> 8 * (n ? o : 1 - o);
}
function F(e, t, r, n) {
  t < 0 && (t = 4294967295 + t + 1);
  for (var o = 0, i = Math.min(e.length - r, 4); o < i; ++o) e[r + o] = t >>> 8 * (n ? o : 3 - o) & 255;
}
function G(e, t, r, n, o, i) {
  if (r + n > e.length) throw new RangeError("Index out of range");
  if (r < 0) throw new RangeError("Index out of range");
}
function j(e, t, r, n, o) {
  return o || G(e, 0, r, 4), c(e, t, r, n, 23, 4), r + 4;
}
function W(e, t, r, n, o) {
  return o || G(e, 0, r, 8), c(e, t, r, n, 52, 8), r + 8;
}
d.prototype.slice = function (e, t) {
  var r,
    n = this.length;
  if ((e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), d.TYPED_ARRAY_SUPPORT) (r = this.subarray(e, t)).__proto__ = d.prototype;else {
    var o = t - e;
    r = new d(o, void 0);
    for (var i = 0; i < o; ++i) r[i] = this[i + e];
  }
  return r;
}, d.prototype.readUIntLE = function (e, t, r) {
  e |= 0, t |= 0, r || C(e, t, this.length);
  for (var n = this[e], o = 1, i = 0; ++i < t && (o *= 256);) n += this[e + i] * o;
  return n;
}, d.prototype.readUIntBE = function (e, t, r) {
  e |= 0, t |= 0, r || C(e, t, this.length);
  for (var n = this[e + --t], o = 1; t > 0 && (o *= 256);) n += this[e + --t] * o;
  return n;
}, d.prototype.readUInt8 = function (e, t) {
  return t || C(e, 1, this.length), this[e];
}, d.prototype.readUInt16LE = function (e, t) {
  return t || C(e, 2, this.length), this[e] | this[e + 1] << 8;
}, d.prototype.readUInt16BE = function (e, t) {
  return t || C(e, 2, this.length), this[e] << 8 | this[e + 1];
}, d.prototype.readUInt32LE = function (e, t) {
  return t || C(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
}, d.prototype.readUInt32BE = function (e, t) {
  return t || C(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
}, d.prototype.readIntLE = function (e, t, r) {
  e |= 0, t |= 0, r || C(e, t, this.length);
  for (var n = this[e], o = 1, i = 0; ++i < t && (o *= 256);) n += this[e + i] * o;
  return n >= (o *= 128) && (n -= Math.pow(2, 8 * t)), n;
}, d.prototype.readIntBE = function (e, t, r) {
  e |= 0, t |= 0, r || C(e, t, this.length);
  for (var n = t, o = 1, i = this[e + --n]; n > 0 && (o *= 256);) i += this[e + --n] * o;
  return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i;
}, d.prototype.readInt8 = function (e, t) {
  return t || C(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
}, d.prototype.readInt16LE = function (e, t) {
  t || C(e, 2, this.length);
  var r = this[e] | this[e + 1] << 8;
  return 32768 & r ? 4294901760 | r : r;
}, d.prototype.readInt16BE = function (e, t) {
  t || C(e, 2, this.length);
  var r = this[e + 1] | this[e] << 8;
  return 32768 & r ? 4294901760 | r : r;
}, d.prototype.readInt32LE = function (e, t) {
  return t || C(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
}, d.prototype.readInt32BE = function (e, t) {
  return t || C(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
}, d.prototype.readFloatLE = function (e, t) {
  return t || C(e, 4, this.length), a(this, e, !0, 23, 4);
}, d.prototype.readFloatBE = function (e, t) {
  return t || C(e, 4, this.length), a(this, e, !1, 23, 4);
}, d.prototype.readDoubleLE = function (e, t) {
  return t || C(e, 8, this.length), a(this, e, !0, 52, 8);
}, d.prototype.readDoubleBE = function (e, t) {
  return t || C(e, 8, this.length), a(this, e, !1, 52, 8);
}, d.prototype.writeUIntLE = function (e, t, r, n) {
  (e = +e, t |= 0, r |= 0, n) || V(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
  var o = 1,
    i = 0;
  for (this[t] = 255 & e; ++i < r && (o *= 256);) this[t + i] = e / o & 255;
  return t + r;
}, d.prototype.writeUIntBE = function (e, t, r, n) {
  (e = +e, t |= 0, r |= 0, n) || V(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
  var o = r - 1,
    i = 1;
  for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);) this[t + o] = e / i & 255;
  return t + r;
}, d.prototype.writeUInt8 = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 1, 255, 0), d.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1;
}, d.prototype.writeUInt16LE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 2, 65535, 0), d.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Y(this, e, t, !0), t + 2;
}, d.prototype.writeUInt16BE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 2, 65535, 0), d.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Y(this, e, t, !1), t + 2;
}, d.prototype.writeUInt32LE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 4, 4294967295, 0), d.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : F(this, e, t, !0), t + 4;
}, d.prototype.writeUInt32BE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 4, 4294967295, 0), d.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : F(this, e, t, !1), t + 4;
}, d.prototype.writeIntLE = function (e, t, r, n) {
  if (e = +e, t |= 0, !n) {
    var o = Math.pow(2, 8 * r - 1);
    V(this, e, t, r, o - 1, -o);
  }
  var i = 0,
    u = 1,
    s = 0;
  for (this[t] = 255 & e; ++i < r && (u *= 256);) e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1), this[t + i] = (e / u | 0) - s & 255;
  return t + r;
}, d.prototype.writeIntBE = function (e, t, r, n) {
  if (e = +e, t |= 0, !n) {
    var o = Math.pow(2, 8 * r - 1);
    V(this, e, t, r, o - 1, -o);
  }
  var i = r - 1,
    u = 1,
    s = 0;
  for (this[t + i] = 255 & e; --i >= 0 && (u *= 256);) e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1), this[t + i] = (e / u | 0) - s & 255;
  return t + r;
}, d.prototype.writeInt8 = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 1, 127, -128), d.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
}, d.prototype.writeInt16LE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 2, 32767, -32768), d.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Y(this, e, t, !0), t + 2;
}, d.prototype.writeInt16BE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 2, 32767, -32768), d.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Y(this, e, t, !1), t + 2;
}, d.prototype.writeInt32LE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 4, 2147483647, -2147483648), d.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : F(this, e, t, !0), t + 4;
}, d.prototype.writeInt32BE = function (e, t, r) {
  return e = +e, t |= 0, r || V(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), d.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : F(this, e, t, !1), t + 4;
}, d.prototype.writeFloatLE = function (e, t, r) {
  return j(this, e, t, !0, r);
}, d.prototype.writeFloatBE = function (e, t, r) {
  return j(this, e, t, !1, r);
}, d.prototype.writeDoubleLE = function (e, t, r) {
  return W(this, e, t, !0, r);
}, d.prototype.writeDoubleBE = function (e, t, r) {
  return W(this, e, t, !1, r);
}, d.prototype.copy = function (e, t, r, n) {
  if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
  if (0 === e.length || 0 === this.length) return 0;
  if (t < 0) throw new RangeError("targetStart out of bounds");
  if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
  if (n < 0) throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
  var o,
    i = n - r;
  if (this === e && r < t && t < n) for (o = i - 1; o >= 0; --o) e[o + t] = this[o + r];else if (i < 1e3 || !d.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o) e[o + t] = this[o + r];else Uint8Array.prototype.set.call(e, this.subarray(r, r + i), t);
  return i;
}, d.prototype.fill = function (e, t, r, n) {
  if ("string" == typeof e) {
    if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === e.length) {
      var o = e.charCodeAt(0);
      o < 256 && (e = o);
    }
    if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
    if ("string" == typeof n && !d.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
  } else "number" == typeof e && (e &= 255);
  if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
  if (r <= t) return this;
  var i;
  if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e) for (i = t; i < r; ++i) this[i] = e;else {
    var u = I(e) ? e : q(new d(e, n).toString()),
      s = u.length;
    for (i = 0; i < r - t; ++i) this[i + t] = u[i % s];
  }
  return this;
};
var X = /[^+\/0-9A-Za-z-_]/g;
function H(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function q(e, t) {
  var r;
  t = t || 1 / 0;
  for (var n = e.length, o = null, i = [], u = 0; u < n; ++u) {
    if ((r = e.charCodeAt(u)) > 55295 && r < 57344) {
      if (!o) {
        if (r > 56319) {
          (t -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        if (u + 1 === n) {
          (t -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        o = r;
        continue;
      }
      if (r < 56320) {
        (t -= 3) > -1 && i.push(239, 191, 189), o = r;
        continue;
      }
      r = 65536 + (o - 55296 << 10 | r - 56320);
    } else o && (t -= 3) > -1 && i.push(239, 191, 189);
    if (o = null, r < 128) {
      if ((t -= 1) < 0) break;
      i.push(r);
    } else if (r < 2048) {
      if ((t -= 2) < 0) break;
      i.push(r >> 6 | 192, 63 & r | 128);
    } else if (r < 65536) {
      if ((t -= 3) < 0) break;
      i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
    } else {
      if (!(r < 1114112)) throw new Error("Invalid code point");
      if ((t -= 4) < 0) break;
      i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
    }
  }
  return i;
}
function $(e) {
  return function (e) {
    var t, u, s, a, c, f;
    o || i();
    var p = e.length;
    if (p % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    c = "=" === e[p - 2] ? 2 : "=" === e[p - 1] ? 1 : 0, f = new n(3 * p / 4 - c), s = c > 0 ? p - 4 : p;
    var l = 0;
    for (t = 0, u = 0; t < s; t += 4, u += 3) a = r[e.charCodeAt(t)] << 18 | r[e.charCodeAt(t + 1)] << 12 | r[e.charCodeAt(t + 2)] << 6 | r[e.charCodeAt(t + 3)], f[l++] = a >> 16 & 255, f[l++] = a >> 8 & 255, f[l++] = 255 & a;
    return 2 === c ? (a = r[e.charCodeAt(t)] << 2 | r[e.charCodeAt(t + 1)] >> 4, f[l++] = 255 & a) : 1 === c && (a = r[e.charCodeAt(t)] << 10 | r[e.charCodeAt(t + 1)] << 4 | r[e.charCodeAt(t + 2)] >> 2, f[l++] = a >> 8 & 255, f[l++] = 255 & a), f;
  }(function (e) {
    if ((e = function (e) {
      return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
    }(e).replace(X, "")).length < 2) return "";
    for (; e.length % 4 != 0;) e += "=";
    return e;
  }(e));
}
function z(e, t, r, n) {
  for (var o = 0; o < n && !(o + r >= t.length || o >= e.length); ++o) t[o + r] = e[o];
  return o;
}
function J(e) {
  return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);
}
var Z,
  Q,
  ee,
  te,
  re = {},
  ne = {},
  oe = {},
  ie = {},
  ue = {},
  se = {};
Z = se, Object.defineProperty(Z, "__esModule", {
  value: !0
}), (Q = Z.GlobalTypes || (Z.GlobalTypes = {}))[Q.UNSIGNED_TX = 0] = "UNSIGNED_TX", Q[Q.GLOBAL_XPUB = 1] = "GLOBAL_XPUB", Z.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], (ee = Z.InputTypes || (Z.InputTypes = {}))[ee.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", ee[ee.WITNESS_UTXO = 1] = "WITNESS_UTXO", ee[ee.PARTIAL_SIG = 2] = "PARTIAL_SIG", ee[ee.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", ee[ee.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", ee[ee.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", ee[ee.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", ee[ee.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", ee[ee.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", ee[ee.POR_COMMITMENT = 9] = "POR_COMMITMENT", ee[ee.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", ee[ee.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", ee[ee.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", ee[ee.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", ee[ee.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", ee[ee.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT", Z.INPUT_TYPE_NAMES = ["nonWitnessUtxo", "witnessUtxo", "partialSig", "sighashType", "redeemScript", "witnessScript", "bip32Derivation", "finalScriptSig", "finalScriptWitness", "porCommitment", "tapKeySig", "tapScriptSig", "tapLeafScript", "tapBip32Derivation", "tapInternalKey", "tapMerkleRoot"], (te = Z.OutputTypes || (Z.OutputTypes = {}))[te.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", te[te.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", te[te.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", te[te.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", te[te.TAP_TREE = 6] = "TAP_TREE", te[te.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION", Z.OUTPUT_TYPE_NAMES = ["redeemScript", "witnessScript", "bip32Derivation", "tapInternalKey", "tapTree", "tapBip32Derivation"];
var ae = {};
Object.defineProperty(ae, "__esModule", {
  value: !0
});
var ce = se;
ae.decode = function (e) {
  if (e.key[0] !== ce.GlobalTypes.GLOBAL_XPUB) throw new Error("Decode Error: could not decode globalXpub with key 0x" + e.key.toString("hex"));
  if (79 !== e.key.length || ![2, 3].includes(e.key[46])) throw new Error("Decode Error: globalXpub has invalid extended pubkey in key 0x" + e.key.toString("hex"));
  if (e.value.length / 4 % 1 != 0) throw new Error("Decode Error: Global GLOBAL_XPUB value length should be multiple of 4");
  var t = e.key.slice(1),
    r = {
      masterFingerprint: e.value.slice(0, 4),
      extendedPubkey: t,
      path: "m"
    };
  for (var _i = 0, _arr = (n = e.value.length / 4 - 1, _toConsumableArray(Array(n).keys())); _i < _arr.length; _i++) {
    var _t2 = _arr[_i];
    var _n = e.value.readUInt32LE(4 * _t2 + 4),
      _o = !!(2147483648 & _n),
      _i2 = 2147483647 & _n;
    r.path += "/" + _i2.toString(10) + (_o ? "'" : "");
  }
  var n;
  return r;
}, ae.encode = function (e) {
  var t = d.from([ce.GlobalTypes.GLOBAL_XPUB]),
    r = d.concat([t, e.extendedPubkey]),
    n = e.path.split("/"),
    o = d.allocUnsafe(4 * n.length);
  e.masterFingerprint.copy(o, 0);
  var i = 4;
  return n.slice(1).forEach(function (e) {
    var t = "'" === e.slice(-1);
    var r = 2147483647 & parseInt(t ? e.slice(0, -1) : e, 10);
    t && (r += 2147483648), o.writeUInt32LE(r, i), i += 4;
  }), {
    key: r,
    value: o
  };
}, ae.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }", ae.check = function (e) {
  var t = e.extendedPubkey,
    r = e.masterFingerprint,
    n = e.path;
  return d.isBuffer(t) && 78 === t.length && [2, 3].indexOf(t[45]) > -1 && d.isBuffer(r) && 4 === r.length && "string" == typeof n && !!n.match(/^m(\/\d+'?)*$/);
}, ae.canAddToArray = function (e, t, r) {
  var n = t.extendedPubkey.toString("hex");
  return !r.has(n) && (r.add(n), 0 === e.filter(function (e) {
    return e.extendedPubkey.equals(t.extendedPubkey);
  }).length);
};
var fe = {};
Object.defineProperty(fe, "__esModule", {
  value: !0
});
var pe = se;
fe.encode = function (e) {
  return {
    key: d.from([pe.GlobalTypes.UNSIGNED_TX]),
    value: e.toBuffer()
  };
};
var le = {};
Object.defineProperty(le, "__esModule", {
  value: !0
});
var he = se;
le.decode = function (e) {
  if (e.key[0] !== he.InputTypes.FINAL_SCRIPTSIG) throw new Error("Decode Error: could not decode finalScriptSig with key 0x" + e.key.toString("hex"));
  return e.value;
}, le.encode = function (e) {
  return {
    key: d.from([he.InputTypes.FINAL_SCRIPTSIG]),
    value: e
  };
}, le.expected = "Buffer", le.check = function (e) {
  return d.isBuffer(e);
}, le.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.finalScriptSig;
};
var de = {};
Object.defineProperty(de, "__esModule", {
  value: !0
});
var ye = se;
de.decode = function (e) {
  if (e.key[0] !== ye.InputTypes.FINAL_SCRIPTWITNESS) throw new Error("Decode Error: could not decode finalScriptWitness with key 0x" + e.key.toString("hex"));
  return e.value;
}, de.encode = function (e) {
  return {
    key: d.from([ye.InputTypes.FINAL_SCRIPTWITNESS]),
    value: e
  };
}, de.expected = "Buffer", de.check = function (e) {
  return d.isBuffer(e);
}, de.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.finalScriptWitness;
};
var ge = {};
Object.defineProperty(ge, "__esModule", {
  value: !0
});
var Ee = se;
ge.decode = function (e) {
  if (e.key[0] !== Ee.InputTypes.NON_WITNESS_UTXO) throw new Error("Decode Error: could not decode nonWitnessUtxo with key 0x" + e.key.toString("hex"));
  return e.value;
}, ge.encode = function (e) {
  return {
    key: d.from([Ee.InputTypes.NON_WITNESS_UTXO]),
    value: e
  };
}, ge.expected = "Buffer", ge.check = function (e) {
  return d.isBuffer(e);
}, ge.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.nonWitnessUtxo;
};
var Te = {};
Object.defineProperty(Te, "__esModule", {
  value: !0
});
var we = se;
Te.decode = function (e) {
  if (e.key[0] !== we.InputTypes.PARTIAL_SIG) throw new Error("Decode Error: could not decode partialSig with key 0x" + e.key.toString("hex"));
  if (34 !== e.key.length && 66 !== e.key.length || ![2, 3, 4].includes(e.key[1])) throw new Error("Decode Error: partialSig has invalid pubkey in key 0x" + e.key.toString("hex"));
  return {
    pubkey: e.key.slice(1),
    signature: e.value
  };
}, Te.encode = function (e) {
  var t = d.from([we.InputTypes.PARTIAL_SIG]);
  return {
    key: d.concat([t, e.pubkey]),
    value: e.signature
  };
}, Te.expected = "{ pubkey: Buffer; signature: Buffer; }", Te.check = function (e) {
  return d.isBuffer(e.pubkey) && d.isBuffer(e.signature) && [33, 65].includes(e.pubkey.length) && [2, 3, 4].includes(e.pubkey[0]) && function (e) {
    if (!d.isBuffer(e) || e.length < 9) return !1;
    if (48 !== e[0]) return !1;
    if (e.length !== e[1] + 3) return !1;
    if (2 !== e[2]) return !1;
    var t = e[3];
    if (t > 33 || t < 1) return !1;
    if (2 !== e[3 + t + 1]) return !1;
    var r = e[3 + t + 2];
    return !(r > 33 || r < 1) && e.length === 3 + t + 2 + r + 2;
  }(e.signature);
}, Te.canAddToArray = function (e, t, r) {
  var n = t.pubkey.toString("hex");
  return !r.has(n) && (r.add(n), 0 === e.filter(function (e) {
    return e.pubkey.equals(t.pubkey);
  }).length);
};
var Ie = {};
Object.defineProperty(Ie, "__esModule", {
  value: !0
});
var ke = se;
Ie.decode = function (e) {
  if (e.key[0] !== ke.InputTypes.POR_COMMITMENT) throw new Error("Decode Error: could not decode porCommitment with key 0x" + e.key.toString("hex"));
  return e.value.toString("utf8");
}, Ie.encode = function (e) {
  return {
    key: d.from([ke.InputTypes.POR_COMMITMENT]),
    value: d.from(e, "utf8")
  };
}, Ie.expected = "string", Ie.check = function (e) {
  return "string" == typeof e;
}, Ie.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.porCommitment;
};
var Se = {};
Object.defineProperty(Se, "__esModule", {
  value: !0
});
var ve = se;
Se.decode = function (e) {
  if (e.key[0] !== ve.InputTypes.SIGHASH_TYPE) throw new Error("Decode Error: could not decode sighashType with key 0x" + e.key.toString("hex"));
  return e.value.readUInt32LE(0);
}, Se.encode = function (e) {
  var t = d.from([ve.InputTypes.SIGHASH_TYPE]),
    r = d.allocUnsafe(4);
  return r.writeUInt32LE(e, 0), {
    key: t,
    value: r
  };
}, Se.expected = "number", Se.check = function (e) {
  return "number" == typeof e;
}, Se.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.sighashType;
};
var be = {};
Object.defineProperty(be, "__esModule", {
  value: !0
});
var _e = se;
function Ae(e) {
  return d.isBuffer(e) && (64 === e.length || 65 === e.length);
}
be.decode = function (e) {
  if (e.key[0] !== _e.InputTypes.TAP_KEY_SIG || 1 !== e.key.length) throw new Error("Decode Error: could not decode tapKeySig with key 0x" + e.key.toString("hex"));
  if (!Ae(e.value)) throw new Error("Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature");
  return e.value;
}, be.encode = function (e) {
  return {
    key: d.from([_e.InputTypes.TAP_KEY_SIG]),
    value: e
  };
}, be.expected = "Buffer", be.check = Ae, be.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.tapKeySig;
};
var me = {};
Object.defineProperty(me, "__esModule", {
  value: !0
});
var Pe = se;
me.decode = function (e) {
  if (e.key[0] !== Pe.InputTypes.TAP_LEAF_SCRIPT) throw new Error("Decode Error: could not decode tapLeafScript with key 0x" + e.key.toString("hex"));
  if ((e.key.length - 2) % 32 != 0) throw new Error("Decode Error: tapLeafScript has invalid control block in key 0x" + e.key.toString("hex"));
  var t = e.value[e.value.length - 1];
  if ((254 & e.key[1]) !== t) throw new Error("Decode Error: tapLeafScript bad leaf version in key 0x" + e.key.toString("hex"));
  var r = e.value.slice(0, -1);
  return {
    controlBlock: e.key.slice(1),
    script: r,
    leafVersion: t
  };
}, me.encode = function (e) {
  var t = d.from([Pe.InputTypes.TAP_LEAF_SCRIPT]),
    r = d.from([e.leafVersion]);
  return {
    key: d.concat([t, e.controlBlock]),
    value: d.concat([e.script, r])
  };
}, me.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }", me.check = function (e) {
  return d.isBuffer(e.controlBlock) && (e.controlBlock.length - 1) % 32 == 0 && (254 & e.controlBlock[0]) === e.leafVersion && d.isBuffer(e.script);
}, me.canAddToArray = function (e, t, r) {
  var n = t.controlBlock.toString("hex");
  return !r.has(n) && (r.add(n), 0 === e.filter(function (e) {
    return e.controlBlock.equals(t.controlBlock);
  }).length);
};
var Re = {};
Object.defineProperty(Re, "__esModule", {
  value: !0
});
var Oe = se;
function Be(e) {
  return d.isBuffer(e) && 32 === e.length;
}
Re.decode = function (e) {
  if (e.key[0] !== Oe.InputTypes.TAP_MERKLE_ROOT || 1 !== e.key.length) throw new Error("Decode Error: could not decode tapMerkleRoot with key 0x" + e.key.toString("hex"));
  if (!Be(e.value)) throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return e.value;
}, Re.encode = function (e) {
  return {
    key: d.from([Oe.InputTypes.TAP_MERKLE_ROOT]),
    value: e
  };
}, Re.expected = "Buffer", Re.check = Be, Re.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.tapMerkleRoot;
};
var Ue = {};
Object.defineProperty(Ue, "__esModule", {
  value: !0
});
var xe = se;
Ue.decode = function (e) {
  if (e.key[0] !== xe.InputTypes.TAP_SCRIPT_SIG) throw new Error("Decode Error: could not decode tapScriptSig with key 0x" + e.key.toString("hex"));
  if (65 !== e.key.length) throw new Error("Decode Error: tapScriptSig has invalid key 0x" + e.key.toString("hex"));
  if (64 !== e.value.length && 65 !== e.value.length) throw new Error("Decode Error: tapScriptSig has invalid signature in key 0x" + e.key.toString("hex"));
  return {
    pubkey: e.key.slice(1, 33),
    leafHash: e.key.slice(33),
    signature: e.value
  };
}, Ue.encode = function (e) {
  var t = d.from([xe.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: d.concat([t, e.pubkey, e.leafHash]),
    value: e.signature
  };
}, Ue.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }", Ue.check = function (e) {
  return d.isBuffer(e.pubkey) && d.isBuffer(e.leafHash) && d.isBuffer(e.signature) && 32 === e.pubkey.length && 32 === e.leafHash.length && (64 === e.signature.length || 65 === e.signature.length);
}, Ue.canAddToArray = function (e, t, r) {
  var n = t.pubkey.toString("hex") + t.leafHash.toString("hex");
  return !r.has(n) && (r.add(n), 0 === e.filter(function (e) {
    return e.pubkey.equals(t.pubkey) && e.leafHash.equals(t.leafHash);
  }).length);
};
var Ne = {},
  Le = {},
  Me = {};
Object.defineProperty(Me, "__esModule", {
  value: !0
});
function De(e) {
  if (e < 0 || e > 9007199254740991 || e % 1 != 0) throw new RangeError("value out of range");
}
function Ke(e) {
  return De(e), e < 253 ? 1 : e <= 65535 ? 3 : e <= 4294967295 ? 5 : 9;
}
Me.encode = function e(t, r, n) {
  if (De(t), r || (r = d.allocUnsafe(Ke(t))), !d.isBuffer(r)) throw new TypeError("buffer must be a Buffer instance");
  return n || (n = 0), t < 253 ? (r.writeUInt8(t, n), Object.assign(e, {
    bytes: 1
  })) : t <= 65535 ? (r.writeUInt8(253, n), r.writeUInt16LE(t, n + 1), Object.assign(e, {
    bytes: 3
  })) : t <= 4294967295 ? (r.writeUInt8(254, n), r.writeUInt32LE(t, n + 1), Object.assign(e, {
    bytes: 5
  })) : (r.writeUInt8(255, n), r.writeUInt32LE(t >>> 0, n + 1), r.writeUInt32LE(t / 4294967296 | 0, n + 5), Object.assign(e, {
    bytes: 9
  })), r;
}, Me.decode = function e(t, r) {
  if (!d.isBuffer(t)) throw new TypeError("buffer must be a Buffer instance");
  r || (r = 0);
  var n = t.readUInt8(r);
  if (n < 253) return Object.assign(e, {
    bytes: 1
  }), n;
  if (253 === n) return Object.assign(e, {
    bytes: 3
  }), t.readUInt16LE(r + 1);
  if (254 === n) return Object.assign(e, {
    bytes: 5
  }), t.readUInt32LE(r + 1);
  {
    Object.assign(e, {
      bytes: 9
    });
    var _n2 = t.readUInt32LE(r + 1),
      _o2 = 4294967296 * t.readUInt32LE(r + 5) + _n2;
    return De(_o2), _o2;
  }
}, Me.encodingLength = Ke, Object.defineProperty(Le, "__esModule", {
  value: !0
});
var Ce = Me;
function Ve(e) {
  var t = e.key.length,
    r = e.value.length,
    n = Ce.encodingLength(t),
    o = Ce.encodingLength(r),
    i = d.allocUnsafe(n + t + o + r);
  return Ce.encode(t, i, 0), e.key.copy(i, n), Ce.encode(r, i, n + t), e.value.copy(i, n + t + o), i;
}
function Ye(e, t) {
  if ("number" != typeof e) throw new Error("cannot write a non-number as a number");
  if (e < 0) throw new Error("specified a negative value for writing an unsigned value");
  if (e > t) throw new Error("RangeError: value out of range");
  if (Math.floor(e) !== e) throw new Error("value has a fractional component");
}
Le.range = function (e) {
  return _toConsumableArray(Array(e).keys());
}, Le.reverseBuffer = function (e) {
  if (e.length < 1) return e;
  var t = e.length - 1,
    r = 0;
  for (var _n3 = 0; _n3 < e.length / 2; _n3++) r = e[_n3], e[_n3] = e[t], e[t] = r, t--;
  return e;
}, Le.keyValsToBuffer = function (e) {
  var t = e.map(Ve);
  return t.push(d.from([0])), d.concat(t);
}, Le.keyValToBuffer = Ve, Le.readUInt64LE = function (e, t) {
  var r = e.readUInt32LE(t);
  var n = e.readUInt32LE(t + 4);
  return n *= 4294967296, Ye(n + r, 9007199254740991), n + r;
}, Le.writeUInt64LE = function (e, t, r) {
  return Ye(t, 9007199254740991), e.writeInt32LE(-1 & t, r), e.writeUInt32LE(Math.floor(t / 4294967296), r + 4), r + 8;
}, Object.defineProperty(Ne, "__esModule", {
  value: !0
});
var Fe = se,
  Ge = Le,
  je = Me;
Ne.decode = function (e) {
  if (e.key[0] !== Fe.InputTypes.WITNESS_UTXO) throw new Error("Decode Error: could not decode witnessUtxo with key 0x" + e.key.toString("hex"));
  var t = Ge.readUInt64LE(e.value, 0);
  var r = 8;
  var n = je.decode(e.value, r);
  r += je.encodingLength(n);
  var o = e.value.slice(r);
  if (o.length !== n) throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: o,
    value: t
  };
}, Ne.encode = function (e) {
  var t = e.script,
    r = e.value,
    n = je.encodingLength(t.length),
    o = d.allocUnsafe(8 + n + t.length);
  return Ge.writeUInt64LE(o, r, 0), je.encode(t.length, o, 8), t.copy(o, 8 + n), {
    key: d.from([Fe.InputTypes.WITNESS_UTXO]),
    value: o
  };
}, Ne.expected = "{ script: Buffer; value: number; }", Ne.check = function (e) {
  return d.isBuffer(e.script) && "number" == typeof e.value;
}, Ne.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.witnessUtxo;
};
var We = {};
Object.defineProperty(We, "__esModule", {
  value: !0
});
var Xe = se,
  He = Me;
We.decode = function (e) {
  if (e.key[0] !== Xe.OutputTypes.TAP_TREE || 1 !== e.key.length) throw new Error("Decode Error: could not decode tapTree with key 0x" + e.key.toString("hex"));
  var t = 0;
  var r = [];
  for (; t < e.value.length;) {
    var _n4 = e.value[t++],
      _o3 = e.value[t++],
      _i3 = He.decode(e.value, t);
    t += He.encodingLength(_i3), r.push({
      depth: _n4,
      leafVersion: _o3,
      script: e.value.slice(t, t + _i3)
    }), t += _i3;
  }
  return {
    leaves: r
  };
}, We.encode = function (e) {
  var _ref;
  var t = d.from([Xe.OutputTypes.TAP_TREE]),
    r = (_ref = []).concat.apply(_ref, _toConsumableArray(e.leaves.map(function (e) {
      return [d.of(e.depth, e.leafVersion), He.encode(e.script.length), e.script];
    })));
  return {
    key: t,
    value: d.concat(r)
  };
}, We.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }", We.check = function (e) {
  return Array.isArray(e.leaves) && e.leaves.every(function (e) {
    return e.depth >= 0 && e.depth <= 128 && (254 & e.leafVersion) === e.leafVersion && d.isBuffer(e.script);
  });
}, We.canAdd = function (e, t) {
  return !!e && !!t && void 0 === e.tapTree;
};
var qe = {};
Object.defineProperty(qe, "__esModule", {
  value: !0
});
var $e = function $e(e) {
  return 33 === e.length && [2, 3].includes(e[0]) || 65 === e.length && 4 === e[0];
};
qe.makeConverter = function (e) {
  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $e;
  return {
    decode: function decode(r) {
      if (r.key[0] !== e) throw new Error("Decode Error: could not decode bip32Derivation with key 0x" + r.key.toString("hex"));
      var n = r.key.slice(1);
      if (!t(n)) throw new Error("Decode Error: bip32Derivation has invalid pubkey in key 0x" + r.key.toString("hex"));
      if (r.value.length / 4 % 1 != 0) throw new Error("Decode Error: Input BIP32_DERIVATION value length should be multiple of 4");
      var o = {
        masterFingerprint: r.value.slice(0, 4),
        pubkey: n,
        path: "m"
      };
      for (var _i4 = 0, _arr2 = (i = r.value.length / 4 - 1, _toConsumableArray(Array(i).keys())); _i4 < _arr2.length; _i4++) {
        var _e2 = _arr2[_i4];
        var _t3 = r.value.readUInt32LE(4 * _e2 + 4),
          _n5 = !!(2147483648 & _t3),
          _i5 = 2147483647 & _t3;
        o.path += "/" + _i5.toString(10) + (_n5 ? "'" : "");
      }
      var i;
      return o;
    },
    encode: function encode(t) {
      var r = d.from([e]),
        n = d.concat([r, t.pubkey]),
        o = t.path.split("/"),
        i = d.allocUnsafe(4 * o.length);
      t.masterFingerprint.copy(i, 0);
      var u = 4;
      return o.slice(1).forEach(function (e) {
        var t = "'" === e.slice(-1);
        var r = 2147483647 & parseInt(t ? e.slice(0, -1) : e, 10);
        t && (r += 2147483648), i.writeUInt32LE(r, u), u += 4;
      }), {
        key: n,
        value: i
      };
    },
    check: function check(e) {
      return d.isBuffer(e.pubkey) && d.isBuffer(e.masterFingerprint) && "string" == typeof e.path && t(e.pubkey) && 4 === e.masterFingerprint.length;
    },
    expected: "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }",
    canAddToArray: function canAddToArray(e, t, r) {
      var n = t.pubkey.toString("hex");
      return !r.has(n) && (r.add(n), 0 === e.filter(function (e) {
        return e.pubkey.equals(t.pubkey);
      }).length);
    }
  };
};
var ze = {};
Object.defineProperty(ze, "__esModule", {
  value: !0
}), ze.makeChecker = function (e) {
  return function (t) {
    var r;
    if (e.includes(t.key[0]) && (r = t.key.slice(1), 33 !== r.length && 65 !== r.length || ![2, 3, 4].includes(r[0]))) throw new Error("Format Error: invalid pubkey in key 0x" + t.key.toString("hex"));
    return r;
  };
};
var Je = {};
Object.defineProperty(Je, "__esModule", {
  value: !0
}), Je.makeConverter = function (e) {
  return {
    decode: function decode(t) {
      if (t.key[0] !== e) throw new Error("Decode Error: could not decode redeemScript with key 0x" + t.key.toString("hex"));
      return t.value;
    },
    encode: function encode(t) {
      return {
        key: d.from([e]),
        value: t
      };
    },
    check: function check(e) {
      return d.isBuffer(e);
    },
    expected: "Buffer",
    canAdd: function canAdd(e, t) {
      return !!e && !!t && void 0 === e.redeemScript;
    }
  };
};
var Ze = {};
Object.defineProperty(Ze, "__esModule", {
  value: !0
});
var Qe = Me,
  et = qe,
  tt = function tt(e) {
    return 32 === e.length;
  };
Ze.makeConverter = function (e) {
  var t = et.makeConverter(e, tt);
  return {
    decode: function decode(e) {
      var r = Qe.decode(e.value),
        n = Qe.encodingLength(r),
        o = t.decode({
          key: e.key,
          value: e.value.slice(n + 32 * r)
        }),
        i = new Array(r);
      for (var _t4 = 0, _o4 = n; _t4 < r; _t4++, _o4 += 32) i[_t4] = e.value.slice(_o4, _o4 + 32);
      return Object.assign({}, o, {
        leafHashes: i
      });
    },
    encode: function encode(e) {
      var r = t.encode(e),
        n = Qe.encodingLength(e.leafHashes.length),
        o = d.allocUnsafe(n);
      Qe.encode(e.leafHashes.length, o);
      var i = d.concat([o].concat(_toConsumableArray(e.leafHashes), [r.value]));
      return Object.assign({}, r, {
        value: i
      });
    },
    check: function check(e) {
      return Array.isArray(e.leafHashes) && e.leafHashes.every(function (e) {
        return d.isBuffer(e) && 32 === e.length;
      }) && t.check(e);
    },
    expected: "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }",
    canAddToArray: t.canAddToArray
  };
};
var rt = {};
Object.defineProperty(rt, "__esModule", {
  value: !0
}), rt.makeConverter = function (e) {
  return {
    decode: function decode(t) {
      if (t.key[0] !== e || 1 !== t.key.length) throw new Error("Decode Error: could not decode tapInternalKey with key 0x" + t.key.toString("hex"));
      if (32 !== t.value.length) throw new Error("Decode Error: tapInternalKey not a 32-byte x-only pubkey");
      return t.value;
    },
    encode: function encode(t) {
      return {
        key: d.from([e]),
        value: t
      };
    },
    check: function check(e) {
      return d.isBuffer(e) && 32 === e.length;
    },
    expected: "Buffer",
    canAdd: function canAdd(e, t) {
      return !!e && !!t && void 0 === e.tapInternalKey;
    }
  };
};
var nt = {};
Object.defineProperty(nt, "__esModule", {
  value: !0
}), nt.makeConverter = function (e) {
  return {
    decode: function decode(t) {
      if (t.key[0] !== e) throw new Error("Decode Error: could not decode witnessScript with key 0x" + t.key.toString("hex"));
      return t.value;
    },
    encode: function encode(t) {
      return {
        key: d.from([e]),
        value: t
      };
    },
    check: function check(e) {
      return d.isBuffer(e);
    },
    expected: "Buffer",
    canAdd: function canAdd(e, t) {
      return !!e && !!t && void 0 === e.witnessScript;
    }
  };
}, Object.defineProperty(ue, "__esModule", {
  value: !0
});
var ot = se,
  it = le,
  ut = de,
  st = ge,
  at = Te,
  ct = Ie,
  ft = Se,
  pt = be,
  lt = me,
  ht = Re,
  dt = Ue,
  yt = Ne,
  gt = We,
  Et = qe,
  Tt = ze,
  wt = Je,
  It = Ze,
  kt = rt,
  St = nt,
  vt = {
    unsignedTx: fe,
    globalXpub: ae,
    checkPubkey: Tt.makeChecker([])
  };
ue.globals = vt;
var bt = {
  nonWitnessUtxo: st,
  partialSig: at,
  sighashType: ft,
  finalScriptSig: it,
  finalScriptWitness: ut,
  porCommitment: ct,
  witnessUtxo: yt,
  bip32Derivation: Et.makeConverter(ot.InputTypes.BIP32_DERIVATION),
  redeemScript: wt.makeConverter(ot.InputTypes.REDEEM_SCRIPT),
  witnessScript: St.makeConverter(ot.InputTypes.WITNESS_SCRIPT),
  checkPubkey: Tt.makeChecker([ot.InputTypes.PARTIAL_SIG, ot.InputTypes.BIP32_DERIVATION]),
  tapKeySig: pt,
  tapScriptSig: dt,
  tapLeafScript: lt,
  tapBip32Derivation: It.makeConverter(ot.InputTypes.TAP_BIP32_DERIVATION),
  tapInternalKey: kt.makeConverter(ot.InputTypes.TAP_INTERNAL_KEY),
  tapMerkleRoot: ht
};
ue.inputs = bt;
var _t = {
  bip32Derivation: Et.makeConverter(ot.OutputTypes.BIP32_DERIVATION),
  redeemScript: wt.makeConverter(ot.OutputTypes.REDEEM_SCRIPT),
  witnessScript: St.makeConverter(ot.OutputTypes.WITNESS_SCRIPT),
  checkPubkey: Tt.makeChecker([ot.OutputTypes.BIP32_DERIVATION]),
  tapBip32Derivation: It.makeConverter(ot.OutputTypes.TAP_BIP32_DERIVATION),
  tapTree: gt,
  tapInternalKey: kt.makeConverter(ot.OutputTypes.TAP_INTERNAL_KEY)
};
ue.outputs = _t, Object.defineProperty(ie, "__esModule", {
  value: !0
});
var At = ue,
  mt = Le,
  Pt = Me,
  Rt = se;
function Ot(e, t, r) {
  if (!t.equals(d.from([r]))) throw new Error("Format Error: Invalid ".concat(e, " key: ").concat(t.toString("hex")));
}
function Bt(e, _ref2) {
  var t = _ref2.globalMapKeyVals,
    r = _ref2.inputKeyVals,
    n = _ref2.outputKeyVals;
  var o = {
    unsignedTx: e
  };
  var i = 0;
  var _iterator = _createForOfIteratorHelper(t),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _e3 = _step.value;
      switch (_e3.key[0]) {
        case Rt.GlobalTypes.UNSIGNED_TX:
          if (Ot("global", _e3.key, Rt.GlobalTypes.UNSIGNED_TX), i > 0) throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
          i++;
          break;
        case Rt.GlobalTypes.GLOBAL_XPUB:
          void 0 === o.globalXpub && (o.globalXpub = []), o.globalXpub.push(At.globals.globalXpub.decode(_e3));
          break;
        default:
          o.unknownKeyVals || (o.unknownKeyVals = []), o.unknownKeyVals.push(_e3);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var u = r.length,
    s = n.length,
    a = [],
    c = [];
  var _iterator2 = _createForOfIteratorHelper(mt.range(u)),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _e4 = _step2.value;
      var _t5 = {};
      var _iterator4 = _createForOfIteratorHelper(r[_e4]),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _n6 = _step4.value;
          switch (At.inputs.checkPubkey(_n6), _n6.key[0]) {
            case Rt.InputTypes.NON_WITNESS_UTXO:
              if (Ot("input", _n6.key, Rt.InputTypes.NON_WITNESS_UTXO), void 0 !== _t5.nonWitnessUtxo) throw new Error("Format Error: Input has multiple NON_WITNESS_UTXO");
              _t5.nonWitnessUtxo = At.inputs.nonWitnessUtxo.decode(_n6);
              break;
            case Rt.InputTypes.WITNESS_UTXO:
              if (Ot("input", _n6.key, Rt.InputTypes.WITNESS_UTXO), void 0 !== _t5.witnessUtxo) throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              _t5.witnessUtxo = At.inputs.witnessUtxo.decode(_n6);
              break;
            case Rt.InputTypes.PARTIAL_SIG:
              void 0 === _t5.partialSig && (_t5.partialSig = []), _t5.partialSig.push(At.inputs.partialSig.decode(_n6));
              break;
            case Rt.InputTypes.SIGHASH_TYPE:
              if (Ot("input", _n6.key, Rt.InputTypes.SIGHASH_TYPE), void 0 !== _t5.sighashType) throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              _t5.sighashType = At.inputs.sighashType.decode(_n6);
              break;
            case Rt.InputTypes.REDEEM_SCRIPT:
              if (Ot("input", _n6.key, Rt.InputTypes.REDEEM_SCRIPT), void 0 !== _t5.redeemScript) throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              _t5.redeemScript = At.inputs.redeemScript.decode(_n6);
              break;
            case Rt.InputTypes.WITNESS_SCRIPT:
              if (Ot("input", _n6.key, Rt.InputTypes.WITNESS_SCRIPT), void 0 !== _t5.witnessScript) throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              _t5.witnessScript = At.inputs.witnessScript.decode(_n6);
              break;
            case Rt.InputTypes.BIP32_DERIVATION:
              void 0 === _t5.bip32Derivation && (_t5.bip32Derivation = []), _t5.bip32Derivation.push(At.inputs.bip32Derivation.decode(_n6));
              break;
            case Rt.InputTypes.FINAL_SCRIPTSIG:
              Ot("input", _n6.key, Rt.InputTypes.FINAL_SCRIPTSIG), _t5.finalScriptSig = At.inputs.finalScriptSig.decode(_n6);
              break;
            case Rt.InputTypes.FINAL_SCRIPTWITNESS:
              Ot("input", _n6.key, Rt.InputTypes.FINAL_SCRIPTWITNESS), _t5.finalScriptWitness = At.inputs.finalScriptWitness.decode(_n6);
              break;
            case Rt.InputTypes.POR_COMMITMENT:
              Ot("input", _n6.key, Rt.InputTypes.POR_COMMITMENT), _t5.porCommitment = At.inputs.porCommitment.decode(_n6);
              break;
            case Rt.InputTypes.TAP_KEY_SIG:
              Ot("input", _n6.key, Rt.InputTypes.TAP_KEY_SIG), _t5.tapKeySig = At.inputs.tapKeySig.decode(_n6);
              break;
            case Rt.InputTypes.TAP_SCRIPT_SIG:
              void 0 === _t5.tapScriptSig && (_t5.tapScriptSig = []), _t5.tapScriptSig.push(At.inputs.tapScriptSig.decode(_n6));
              break;
            case Rt.InputTypes.TAP_LEAF_SCRIPT:
              void 0 === _t5.tapLeafScript && (_t5.tapLeafScript = []), _t5.tapLeafScript.push(At.inputs.tapLeafScript.decode(_n6));
              break;
            case Rt.InputTypes.TAP_BIP32_DERIVATION:
              void 0 === _t5.tapBip32Derivation && (_t5.tapBip32Derivation = []), _t5.tapBip32Derivation.push(At.inputs.tapBip32Derivation.decode(_n6));
              break;
            case Rt.InputTypes.TAP_INTERNAL_KEY:
              Ot("input", _n6.key, Rt.InputTypes.TAP_INTERNAL_KEY), _t5.tapInternalKey = At.inputs.tapInternalKey.decode(_n6);
              break;
            case Rt.InputTypes.TAP_MERKLE_ROOT:
              Ot("input", _n6.key, Rt.InputTypes.TAP_MERKLE_ROOT), _t5.tapMerkleRoot = At.inputs.tapMerkleRoot.decode(_n6);
              break;
            default:
              _t5.unknownKeyVals || (_t5.unknownKeyVals = []), _t5.unknownKeyVals.push(_n6);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      a.push(_t5);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var _iterator3 = _createForOfIteratorHelper(mt.range(s)),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _e5 = _step3.value;
      var _t6 = {};
      var _iterator5 = _createForOfIteratorHelper(n[_e5]),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _r = _step5.value;
          switch (At.outputs.checkPubkey(_r), _r.key[0]) {
            case Rt.OutputTypes.REDEEM_SCRIPT:
              if (Ot("output", _r.key, Rt.OutputTypes.REDEEM_SCRIPT), void 0 !== _t6.redeemScript) throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              _t6.redeemScript = At.outputs.redeemScript.decode(_r);
              break;
            case Rt.OutputTypes.WITNESS_SCRIPT:
              if (Ot("output", _r.key, Rt.OutputTypes.WITNESS_SCRIPT), void 0 !== _t6.witnessScript) throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              _t6.witnessScript = At.outputs.witnessScript.decode(_r);
              break;
            case Rt.OutputTypes.BIP32_DERIVATION:
              void 0 === _t6.bip32Derivation && (_t6.bip32Derivation = []), _t6.bip32Derivation.push(At.outputs.bip32Derivation.decode(_r));
              break;
            case Rt.OutputTypes.TAP_INTERNAL_KEY:
              Ot("output", _r.key, Rt.OutputTypes.TAP_INTERNAL_KEY), _t6.tapInternalKey = At.outputs.tapInternalKey.decode(_r);
              break;
            case Rt.OutputTypes.TAP_TREE:
              Ot("output", _r.key, Rt.OutputTypes.TAP_TREE), _t6.tapTree = At.outputs.tapTree.decode(_r);
              break;
            case Rt.OutputTypes.TAP_BIP32_DERIVATION:
              void 0 === _t6.tapBip32Derivation && (_t6.tapBip32Derivation = []), _t6.tapBip32Derivation.push(At.outputs.tapBip32Derivation.decode(_r));
              break;
            default:
              _t6.unknownKeyVals || (_t6.unknownKeyVals = []), _t6.unknownKeyVals.push(_r);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      c.push(_t6);
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return {
    globalMap: o,
    inputs: a,
    outputs: c
  };
}
ie.psbtFromBuffer = function (e, t) {
  var r = 0;
  function n() {
    var t = Pt.decode(e, r);
    r += Pt.encodingLength(t);
    var n = e.slice(r, r + t);
    return r += t, n;
  }
  function o() {
    return {
      key: n(),
      value: n()
    };
  }
  function i() {
    if (r >= e.length) throw new Error("Format Error: Unexpected End of PSBT");
    var t = 0 === e.readUInt8(r);
    return t && r++, t;
  }
  if (1886610036 !== function () {
    var t = e.readUInt32BE(r);
    return r += 4, t;
  }()) throw new Error("Format Error: Invalid Magic Number");
  if (255 !== function () {
    var t = e.readUInt8(r);
    return r += 1, t;
  }()) throw new Error("Format Error: Magic Number must be followed by 0xff separator");
  var u = [],
    s = {};
  for (; !i();) {
    var _e6 = o(),
      _t7 = _e6.key.toString("hex");
    if (s[_t7]) throw new Error("Format Error: Keys must be unique for global keymap: key " + _t7);
    s[_t7] = 1, u.push(_e6);
  }
  var a = u.filter(function (e) {
    return e.key[0] === Rt.GlobalTypes.UNSIGNED_TX;
  });
  if (1 !== a.length) throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  var c = t(a[0].value),
    _c$getInputOutputCoun = c.getInputOutputCounts(),
    f = _c$getInputOutputCoun.inputCount,
    p = _c$getInputOutputCoun.outputCount,
    l = [],
    h = [];
  var _iterator6 = _createForOfIteratorHelper(mt.range(f)),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _e7 = _step6.value;
      var _t8 = {},
        _r2 = [];
      for (; !i();) {
        var _n7 = o(),
          _i6 = _n7.key.toString("hex");
        if (_t8[_i6]) throw new Error("Format Error: Keys must be unique for each input: input index " + _e7 + " key " + _i6);
        _t8[_i6] = 1, _r2.push(_n7);
      }
      l.push(_r2);
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  var _iterator7 = _createForOfIteratorHelper(mt.range(p)),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _e8 = _step7.value;
      var _t9 = {},
        _r3 = [];
      for (; !i();) {
        var _n8 = o(),
          _i7 = _n8.key.toString("hex");
        if (_t9[_i7]) throw new Error("Format Error: Keys must be unique for each output: output index " + _e8 + " key " + _i7);
        _t9[_i7] = 1, _r3.push(_n8);
      }
      h.push(_r3);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  return Bt(c, {
    globalMapKeyVals: u,
    inputKeyVals: l,
    outputKeyVals: h
  });
}, ie.checkKeyBuffer = Ot, ie.psbtFromKeyVals = Bt;
var Ut = {};
Object.defineProperty(Ut, "__esModule", {
  value: !0
});
var xt = ue,
  Nt = Le;
Ut.psbtToBuffer = function (_ref3) {
  var e = _ref3.globalMap,
    t = _ref3.inputs,
    r = _ref3.outputs;
  var _Dt = Dt({
      globalMap: e,
      inputs: t,
      outputs: r
    }),
    n = _Dt.globalKeyVals,
    o = _Dt.inputKeyVals,
    i = _Dt.outputKeyVals,
    u = Nt.keyValsToBuffer(n),
    s = function s(e) {
      return 0 === e.length ? [d.from([0])] : e.map(Nt.keyValsToBuffer);
    },
    a = s(o),
    c = s(i),
    f = d.allocUnsafe(5);
  return f.writeUIntBE(482972169471, 0, 5), d.concat([f, u].concat(a, c));
};
var Lt = function Lt(e, t) {
  return e.key.compare(t.key);
};
function Mt(e, t) {
  var r = new Set(),
    n = Object.entries(e).reduce(function (e, _ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        n = _ref5[0],
        o = _ref5[1];
      if ("unknownKeyVals" === n) return e;
      var i = t[n];
      if (void 0 === i) return e;
      var u = (Array.isArray(o) ? o : [o]).map(i.encode);
      return u.map(function (e) {
        return e.key.toString("hex");
      }).forEach(function (e) {
        if (r.has(e)) throw new Error("Serialize Error: Duplicate key: " + e);
        r.add(e);
      }), e.concat(u);
    }, []),
    o = e.unknownKeyVals ? e.unknownKeyVals.filter(function (e) {
      return !r.has(e.key.toString("hex"));
    }) : [];
  return n.concat(o).sort(Lt);
}
function Dt(_ref6) {
  var e = _ref6.globalMap,
    t = _ref6.inputs,
    r = _ref6.outputs;
  return {
    globalKeyVals: Mt(e, xt.globals),
    inputKeyVals: t.map(function (e) {
      return Mt(e, xt.inputs);
    }),
    outputKeyVals: r.map(function (e) {
      return Mt(e, xt.outputs);
    })
  };
}
Ut.psbtToKeyVals = Dt, function (e) {
  function t(t) {
    for (var r in t) e.hasOwnProperty(r) || (e[r] = t[r]);
  }
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), t(ie), t(Ut);
}(oe), Object.defineProperty(ne, "__esModule", {
  value: !0
});
var Kt = oe;
function Ct(e, t, r) {
  return function (n) {
    if (e.has(n)) return;
    var o = r.filter(function (e) {
      return e.key.toString("hex") === n;
    })[0];
    t.push(o), e.add(n);
  };
}
function Vt(e) {
  return e.globalMap.unsignedTx;
}
function Yt(e) {
  var t = new Set();
  return e.forEach(function (e) {
    var r = e.key.toString("hex");
    if (t.has(r)) throw new Error("Combine: KeyValue Map keys should be unique");
    t.add(r);
  }), t;
}
ne.combine = function (e) {
  var t = e[0],
    r = Kt.psbtToKeyVals(t),
    n = e.slice(1);
  if (0 === n.length) throw new Error("Combine: Nothing to combine");
  var o = Vt(t);
  if (void 0 === o) throw new Error("Combine: Self missing transaction");
  var i = Yt(r.globalKeyVals),
    u = r.inputKeyVals.map(Yt),
    s = r.outputKeyVals.map(Yt);
  var _iterator8 = _createForOfIteratorHelper(n),
    _step8;
  try {
    var _loop = function _loop() {
      var e = _step8.value;
      var t = Vt(e);
      if (void 0 === t || !t.toBuffer().equals(o.toBuffer())) throw new Error("Combine: One of the Psbts does not have the same transaction.");
      var n = Kt.psbtToKeyVals(e);
      Yt(n.globalKeyVals).forEach(Ct(i, r.globalKeyVals, n.globalKeyVals));
      n.inputKeyVals.map(Yt).forEach(function (e, t) {
        return e.forEach(Ct(u[t], r.inputKeyVals[t], n.inputKeyVals[t]));
      });
      n.outputKeyVals.map(Yt).forEach(function (e, t) {
        return e.forEach(Ct(s[t], r.outputKeyVals[t], n.outputKeyVals[t]));
      });
    };
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  return Kt.psbtFromKeyVals(o, {
    globalMapKeyVals: r.globalKeyVals,
    inputKeyVals: r.inputKeyVals,
    outputKeyVals: r.outputKeyVals
  });
};
var Ft = {};
!function (e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = ue;
  function r(e, t) {
    var r = e[t];
    if (void 0 === r) throw new Error("No input #".concat(t));
    return r;
  }
  function n(e, t) {
    var r = e[t];
    if (void 0 === r) throw new Error("No output #".concat(t));
    return r;
  }
  function o(e, t, r, n) {
    throw new Error("Data for ".concat(e, " key ").concat(t, " is incorrect: Expected ").concat(r, " and got ").concat(JSON.stringify(n)));
  }
  function i(e) {
    return function (r, n) {
      var _loop2 = function _loop2() {
        var i = _Object$keys[_i8];
        var u = r[i],
          _ref7 = t[e + "s"][i] || {},
          s = _ref7.canAdd,
          a = _ref7.canAddToArray,
          c = _ref7.check,
          f = _ref7.expected;
        if (c) if (!!a) {
          if (!Array.isArray(u) || n[i] && !Array.isArray(n[i])) throw new Error("Key type ".concat(i, " must be an array"));
          u.every(c) || o(e, i, f, u);
          var _t0 = n[i] || [],
            _r4 = new Set();
          if (!u.every(function (e) {
            return a(_t0, e, _r4);
          })) throw new Error("Can not add duplicate data to array");
          n[i] = _t0.concat(u);
        } else {
          if (c(u) || o(e, i, f, u), !s(n, u)) throw new Error("Can not add duplicate data to ".concat(e));
          n[i] = u;
        }
      };
      for (var _i8 = 0, _Object$keys = Object.keys(r); _i8 < _Object$keys.length; _i8++) {
        _loop2();
      }
    };
  }
  e.checkForInput = r, e.checkForOutput = n, e.checkHasKey = function (e, t, r) {
    if (e.key[0] < r) throw new Error("Use the method for your specific key instead of addUnknownKeyVal*");
    if (t && 0 !== t.filter(function (t) {
      return t.key.equals(e.key);
    }).length) throw new Error("Duplicate Key: ".concat(e.key.toString("hex")));
  }, e.getEnumLength = function (e) {
    var t = 0;
    return Object.keys(e).forEach(function (e) {
      Number(isNaN(Number(e))) && t++;
    }), t;
  }, e.inputCheckUncleanFinalized = function (e, t) {
    var r = !1;
    if (t.nonWitnessUtxo || t.witnessUtxo) {
      var _e9 = !!t.redeemScript,
        _n9 = !!t.witnessScript,
        _o5 = !_e9 || !!t.finalScriptSig,
        _i9 = !_n9 || !!t.finalScriptWitness,
        _u = !!t.finalScriptSig || !!t.finalScriptWitness;
      r = _o5 && _i9 && _u;
    }
    if (!1 === r) throw new Error("Input #".concat(e, " has too much or too little data to clean"));
  }, e.updateGlobal = i("global"), e.updateInput = i("input"), e.updateOutput = i("output"), e.addInputAttributes = function (t, n) {
    var o = r(t, t.length - 1);
    e.updateInput(n, o);
  }, e.addOutputAttributes = function (t, r) {
    var o = n(t, t.length - 1);
    e.updateOutput(r, o);
  }, e.defaultVersionSetter = function (e, t) {
    if (!d.isBuffer(t) || t.length < 4) throw new Error("Set Version: Invalid Transaction");
    return t.writeUInt32LE(e, 0), t;
  }, e.defaultLocktimeSetter = function (e, t) {
    if (!d.isBuffer(t) || t.length < 4) throw new Error("Set Locktime: Invalid Transaction");
    return t.writeUInt32LE(e, t.length - 4), t;
  };
}(Ft), Object.defineProperty(re, "__esModule", {
  value: !0
});
var Gt = ne,
  jt = oe,
  Wt = se,
  Xt = Ft;
var Ht = re.Psbt = function () {
    function _class(e) {
      _classCallCheck(this, _class);
      this.inputs = [], this.outputs = [], this.globalMap = {
        unsignedTx: e
      };
    }
    return _createClass(_class, [{
      key: "toBase64",
      value: function toBase64() {
        return this.toBuffer().toString("base64");
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return this.toBuffer().toString("hex");
      }
    }, {
      key: "toBuffer",
      value: function toBuffer() {
        return jt.psbtToBuffer(this);
      }
    }, {
      key: "updateGlobal",
      value: function updateGlobal(e) {
        return Xt.updateGlobal(e, this.globalMap), this;
      }
    }, {
      key: "updateInput",
      value: function updateInput(e, t) {
        var r = Xt.checkForInput(this.inputs, e);
        return Xt.updateInput(t, r), this;
      }
    }, {
      key: "updateOutput",
      value: function updateOutput(e, t) {
        var r = Xt.checkForOutput(this.outputs, e);
        return Xt.updateOutput(t, r), this;
      }
    }, {
      key: "addUnknownKeyValToGlobal",
      value: function addUnknownKeyValToGlobal(e) {
        return Xt.checkHasKey(e, this.globalMap.unknownKeyVals, Xt.getEnumLength(Wt.GlobalTypes)), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(e), this;
      }
    }, {
      key: "addUnknownKeyValToInput",
      value: function addUnknownKeyValToInput(e, t) {
        var r = Xt.checkForInput(this.inputs, e);
        return Xt.checkHasKey(t, r.unknownKeyVals, Xt.getEnumLength(Wt.InputTypes)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
      }
    }, {
      key: "addUnknownKeyValToOutput",
      value: function addUnknownKeyValToOutput(e, t) {
        var r = Xt.checkForOutput(this.outputs, e);
        return Xt.checkHasKey(t, r.unknownKeyVals, Xt.getEnumLength(Wt.OutputTypes)), r.unknownKeyVals || (r.unknownKeyVals = []), r.unknownKeyVals.push(t), this;
      }
    }, {
      key: "addInput",
      value: function addInput(e) {
        var _this = this;
        this.globalMap.unsignedTx.addInput(e), this.inputs.push({
          unknownKeyVals: []
        });
        var t = e.unknownKeyVals || [],
          r = this.inputs.length - 1;
        if (!Array.isArray(t)) throw new Error("unknownKeyVals must be an Array");
        return t.forEach(function (e) {
          return _this.addUnknownKeyValToInput(r, e);
        }), Xt.addInputAttributes(this.inputs, e), this;
      }
    }, {
      key: "addOutput",
      value: function addOutput(e) {
        var _this2 = this;
        this.globalMap.unsignedTx.addOutput(e), this.outputs.push({
          unknownKeyVals: []
        });
        var t = e.unknownKeyVals || [],
          r = this.outputs.length - 1;
        if (!Array.isArray(t)) throw new Error("unknownKeyVals must be an Array");
        return t.forEach(function (e) {
          return _this2.addUnknownKeyValToOutput(r, e);
        }), Xt.addOutputAttributes(this.outputs, e), this;
      }
    }, {
      key: "clearFinalizedInput",
      value: function clearFinalizedInput(e) {
        var t = Xt.checkForInput(this.inputs, e);
        Xt.inputCheckUncleanFinalized(e, t);
        for (var _i0 = 0, _Object$keys2 = Object.keys(t); _i0 < _Object$keys2.length; _i0++) {
          var _e0 = _Object$keys2[_i0];
          ["witnessUtxo", "nonWitnessUtxo", "finalScriptSig", "finalScriptWitness", "unknownKeyVals"].includes(_e0) || delete t[_e0];
        }
        return this;
      }
    }, {
      key: "combine",
      value: function combine() {
        for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
          e[_key] = arguments[_key];
        }
        var t = Gt.combine([this].concat(e));
        return Object.assign(this, t), this;
      }
    }, {
      key: "getTransaction",
      value: function getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    }], [{
      key: "fromBase64",
      value: function fromBase64(e, t) {
        var r = d.from(e, "base64");
        return this.fromBuffer(r, t);
      }
    }, {
      key: "fromHex",
      value: function fromHex(e, t) {
        var r = d.from(e, "hex");
        return this.fromBuffer(r, t);
      }
    }, {
      key: "fromBuffer",
      value: function fromBuffer(e, t) {
        var r = jt.psbtFromBuffer(e, t),
          n = new this(r.globalMap.unsignedTx);
        return Object.assign(n, r), n;
      }
    }]);
  }(),
  qt = re.__esModule;


/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/bs58check@3.0.1.js"
/*!**********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/bs58check@3.0.1.js ***!
  \**********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),
/* harmony export */   SHA1: () => (/* binding */ SHA1),
/* harmony export */   SHA256: () => (/* binding */ SHA256),
/* harmony export */   "default": () => (/* binding */ o),
/* harmony export */   ripemd160: () => (/* binding */ ripemd160),
/* harmony export */   sha1: () => (/* binding */ sha1),
/* harmony export */   sha224: () => (/* binding */ sha224),
/* harmony export */   sha256: () => (/* binding */ sha256)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v5/buffer.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function abytes(b) {
  if (!isBytes(b)) throw new Error('Uint8Array expected');
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
  if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance) {
  var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
  abytes(out);
  var min = instance.outputLen;
  if (out.length < min) {
    throw new Error('digestInto() expects output buffer of length at least ' + min);
  }
}
var assert = {
  number: anumber,
  bytes: abytes,
  hash: ahash,
  exists: aexists,
  output: aoutput
};
var u8 = function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
var u32 = function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
var createView = function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
var rotr = function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
};
var rotl = function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
};
var isLE = function () {
  return new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
}();
var byteSwap = function byteSwap(word) {
  return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
};
var byteSwapIfBE = isLE ? function (n) {
  return n;
} : function (n) {
  return byteSwap(n);
};
function byteSwap32(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
var hexes = Array.from({
  length: 256
}, function (_, i) {
  return i.toString(16).padStart(2, '0');
});
function bytesToHex(bytes) {
  abytes(bytes);
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
var asciis = {
  _0: 48,
  _9: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
  var hl = hex.length;
  var al = hl / 2;
  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
  var array = new Uint8Array(al);
  for (var ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    var n1 = asciiToBase16(hex.charCodeAt(hi));
    var n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      var _char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + _char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
var nextTick = function () {
  var _ref = _asyncToGenerator(_regenerator().m(function _callee() {
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          return _context.a(2);
      }
    }, _callee);
  }));
  return function nextTick() {
    return _ref.apply(this, arguments);
  };
}();
function asyncLoop(_x, _x2, _x3) {
  return _asyncLoop.apply(this, arguments);
}
function _asyncLoop() {
  _asyncLoop = _asyncToGenerator(_regenerator().m(function _callee2(iters, tick, cb) {
    var ts, _i10, diff;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          ts = Date.now();
          _i10 = 0;
        case 1:
          if (!(_i10 < iters)) {
            _context2.n = 5;
            break;
          }
          cb(_i10);
          diff = Date.now() - ts;
          if (!(diff >= 0 && diff < tick)) {
            _context2.n = 2;
            break;
          }
          return _context2.a(3, 4);
        case 2:
          _context2.n = 3;
          return nextTick();
        case 3:
          ts += diff;
        case 4:
          _i10++;
          _context2.n = 1;
          break;
        case 5:
          return _context2.a(2);
      }
    }, _callee2);
  }));
  return _asyncLoop.apply(this, arguments);
}
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + _typeof(str));
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes() {
  var sum = 0;
  for (var i = 0; i < arguments.length; i++) {
    var a = i < 0 || arguments.length <= i ? undefined : arguments[i];
    abytes(a);
    sum += a.length;
  }
  var res = new Uint8Array(sum);
  for (var _i = 0, pad = 0; _i < arguments.length; _i++) {
    var _a = _i < 0 || arguments.length <= _i ? undefined : arguments[_i];
    res.set(_a, pad);
    pad += _a.length;
  }
  return res;
}
var Hash = function () {
  function Hash() {
    _classCallCheck(this, Hash);
  }
  return _createClass(Hash, [{
    key: "clone",
    value: function clone() {
      return this._cloneInto();
    }
  }]);
}();
function checkOpts(defaults, opts) {
  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
  var merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  var hashC = function hashC(msg) {
    return hashCons().update(toBytes(msg)).digest();
  };
  var tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function () {
    return hashCons();
  };
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
function randomBytes() {
  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
  if (crypto && typeof crypto.getRandomValues === 'function') {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto && typeof crypto.randomBytes === 'function') {
    return crypto.randomBytes(bytesLength);
  }
  throw new Error('crypto.getRandomValues must be defined');
}
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  var _32n = BigInt(32);
  var _u32_max = BigInt(0xffffffff);
  var wh = Number(value >> _32n & _u32_max);
  var wl = Number(value & _u32_max);
  var h = isLE ? 4 : 0;
  var l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
var Chi = function Chi(a, b, c) {
  return a & b ^ ~a & c;
};
var Maj = function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
};
var HashMD = function (_Hash) {
  function HashMD(blockLen, outputLen, padOffset, isLE) {
    var _this;
    _classCallCheck(this, HashMD);
    _this = _callSuper(this, HashMD);
    _this.blockLen = blockLen;
    _this.outputLen = outputLen;
    _this.padOffset = padOffset;
    _this.isLE = isLE;
    _this.finished = false;
    _this.length = 0;
    _this.pos = 0;
    _this.destroyed = false;
    _this.buffer = new Uint8Array(blockLen);
    _this.view = createView(_this.buffer);
    return _this;
  }
  _inherits(HashMD, _Hash);
  return _createClass(HashMD, [{
    key: "update",
    value: function update(data) {
      aexists(this);
      var view = this.view,
        buffer = this.buffer,
        blockLen = this.blockLen;
      data = toBytes(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          var dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      var buffer = this.buffer,
        view = this.view,
        blockLen = this.blockLen,
        isLE = this.isLE;
      var pos = this.pos;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (var i = pos; i < blockLen; i++) buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      var oview = createView(out);
      var len = this.outputLen;
      if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
      var outLen = len / 4;
      var state = this.get();
      if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
      for (var _i2 = 0; _i2 < outLen; _i2++) oview.setUint32(4 * _i2, state[_i2], isLE);
    }
  }, {
    key: "digest",
    value: function digest() {
      var buffer = this.buffer,
        outputLen = this.outputLen;
      this.digestInto(buffer);
      var res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var _to;
      to || (to = new this.constructor());
      (_to = to).set.apply(_to, _toConsumableArray(this.get()));
      var blockLen = this.blockLen,
        buffer = this.buffer,
        length = this.length,
        finished = this.finished,
        destroyed = this.destroyed,
        pos = this.pos;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
  }]);
}(Hash);
var SHA1_IV = new Uint32Array([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
var SHA1_W = new Uint32Array(80);
var SHA1 = function (_HashMD) {
  function SHA1() {
    var _this2;
    _classCallCheck(this, SHA1);
    _this2 = _callSuper(this, SHA1, [64, 20, 8, false]);
    _this2.A = SHA1_IV[0] | 0;
    _this2.B = SHA1_IV[1] | 0;
    _this2.C = SHA1_IV[2] | 0;
    _this2.D = SHA1_IV[3] | 0;
    _this2.E = SHA1_IV[4] | 0;
    return _this2;
  }
  _inherits(SHA1, _HashMD);
  return _createClass(SHA1, [{
    key: "get",
    value: function get() {
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E;
      return [A, B, C, D, E];
    }
  }, {
    key: "set",
    value: function set(A, B, C, D, E) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);
      for (var _i3 = 16; _i3 < 80; _i3++) SHA1_W[_i3] = rotl(SHA1_W[_i3 - 3] ^ SHA1_W[_i3 - 8] ^ SHA1_W[_i3 - 14] ^ SHA1_W[_i3 - 16], 1);
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E;
      for (var _i4 = 0; _i4 < 80; _i4++) {
        var F = void 0,
          K = void 0;
        if (_i4 < 20) {
          F = Chi(B, C, D);
          K = 0x5a827999;
        } else if (_i4 < 40) {
          F = B ^ C ^ D;
          K = 0x6ed9eba1;
        } else if (_i4 < 60) {
          F = Maj(B, C, D);
          K = 0x8f1bbcdc;
        } else {
          F = B ^ C ^ D;
          K = 0xca62c1d6;
        }
        var T = rotl(A, 5) + F + E + K + SHA1_W[_i4] | 0;
        E = D;
        D = C;
        C = rotl(B, 30);
        B = A;
        A = T;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      this.set(A, B, C, D, E);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA1_W.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.set(0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }]);
}(HashMD);
var sha1 = wrapConstructor(function () {
  return new SHA1();
});
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map(function (_, i) {
  return i;
}));
var Pi = Id.map(function (i) {
  return (9 * i + 5) % 16;
});
var idxL = [Id];
var idxR = [Pi];
for (var i = 0; i < 4; i++) for (var _i5 = 0, _arr = [idxL, idxR]; _i5 < _arr.length; _i5++) {
  var j = _arr[_i5];
  j.push(j[i].map(function (k) {
    return Rho[k];
  }));
}
var shifts = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {
  return new Uint8Array(i);
});
var shiftsL = idxL.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var shiftsR = idxR.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
var Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
function f(group, x, y, z) {
  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = function (_HashMD2) {
  function RIPEMD160() {
    var _this3;
    _classCallCheck(this, RIPEMD160);
    _this3 = _callSuper(this, RIPEMD160, [64, 20, 8, true]);
    _this3.h0 = 0x67452301 | 0;
    _this3.h1 = 0xefcdab89 | 0;
    _this3.h2 = 0x98badcfe | 0;
    _this3.h3 = 0x10325476 | 0;
    _this3.h4 = 0xc3d2e1f0 | 0;
    return _this3;
  }
  _inherits(RIPEMD160, _HashMD2);
  return _createClass(RIPEMD160, [{
    key: "get",
    value: function get() {
      var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3,
        h4 = this.h4;
      return [h0, h1, h2, h3, h4];
    }
  }, {
    key: "set",
    value: function set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var _i6 = 0; _i6 < 16; _i6++, offset += 4) R_BUF[_i6] = view.getUint32(offset, true);
      var al = this.h0 | 0,
        ar = al,
        bl = this.h1 | 0,
        br = bl,
        cl = this.h2 | 0,
        cr = cl,
        dl = this.h3 | 0,
        dr = dl,
        el = this.h4 | 0,
        er = el;
      for (var group = 0; group < 5; group++) {
        var rGroup = 4 - group;
        var hbl = Kl[group],
          hbr = Kr[group];
        var rl = idxL[group],
          rr = idxR[group];
        var sl = shiftsL[group],
          sr = shiftsR[group];
        for (var _i7 = 0; _i7 < 16; _i7++) {
          var tl = rotl(al + f(group, bl, cl, dl) + R_BUF[rl[_i7]] + hbl, sl[_i7]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (var _i8 = 0; _i8 < 16; _i8++) {
          var tr = rotl(ar + f(rGroup, br, cr, dr) + R_BUF[rr[_i8]] + hbr, sr[_i8]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      R_BUF.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  }]);
}(HashMD);
var ripemd160 = wrapConstructor(function () {
  return new RIPEMD160();
});
var SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
var SHA256_IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
var SHA256_W = new Uint32Array(64);
var SHA256 = function (_HashMD3) {
  function SHA256() {
    var _this4;
    _classCallCheck(this, SHA256);
    _this4 = _callSuper(this, SHA256, [64, 32, 8, false]);
    _this4.A = SHA256_IV[0] | 0;
    _this4.B = SHA256_IV[1] | 0;
    _this4.C = SHA256_IV[2] | 0;
    _this4.D = SHA256_IV[3] | 0;
    _this4.E = SHA256_IV[4] | 0;
    _this4.F = SHA256_IV[5] | 0;
    _this4.G = SHA256_IV[6] | 0;
    _this4.H = SHA256_IV[7] | 0;
    return _this4;
  }
  _inherits(SHA256, _HashMD3);
  return _createClass(SHA256, [{
    key: "get",
    value: function get() {
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      return [A, B, C, D, E, F, G, H];
    }
  }, {
    key: "set",
    value: function set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var _i9 = 0; _i9 < 16; _i9++, offset += 4) SHA256_W[_i9] = view.getUint32(offset, false);
      for (var _i0 = 16; _i0 < 64; _i0++) {
        var W15 = SHA256_W[_i0 - 15];
        var W2 = SHA256_W[_i0 - 2];
        var s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        var s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[_i0] = s1 + SHA256_W[_i0 - 7] + s0 + SHA256_W[_i0 - 16] | 0;
      }
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      for (var _i1 = 0; _i1 < 64; _i1++) {
        var sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        var T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[_i1] + SHA256_W[_i1] | 0;
        var sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        var T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA256_W.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }]);
}(HashMD);
var SHA224 = function (_SHA) {
  function SHA224() {
    var _this5;
    _classCallCheck(this, SHA224);
    _this5 = _callSuper(this, SHA224);
    _this5.A = 0xc1059ed8 | 0;
    _this5.B = 0x367cd507 | 0;
    _this5.C = 0x3070dd17 | 0;
    _this5.D = 0xf70e5939 | 0;
    _this5.E = 0xffc00b31 | 0;
    _this5.F = 0x68581511 | 0;
    _this5.G = 0x64f98fa7 | 0;
    _this5.H = 0xbefa4fa4 | 0;
    _this5.outputLen = 28;
    return _this5;
  }
  _inherits(SHA224, _SHA);
  return _createClass(SHA224);
}(SHA256);
var sha256 = wrapConstructor(function () {
  return new SHA256();
});
var sha224 = wrapConstructor(function () {
  return new SHA224();
});
function base(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode(source) {
    if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError('Expected Uint8Array');
    }
    if (source.length === 0) {
      return '';
    }
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error('Non-base' + BASE + ' character');
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var ee = base("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var e = sha256;
var n = ee,
  t = e;
var o = function (e) {
  function r(r) {
    var n = r.slice(0, -4),
      t = r.slice(-4),
      o = e(n);
    if (!(t[0] ^ o[0] | t[1] ^ o[1] | t[2] ^ o[2] | t[3] ^ o[3])) return n;
  }
  return {
    encode: function encode(r) {
      var t = Uint8Array.from(r),
        o = e(t),
        a = t.length + 4,
        c = new Uint8Array(a);
      c.set(t, 0);
      c.set(o.subarray(0, 4), t.length);
      return n.encode(c, a);
    },
    decode: function decode(e) {
      var t = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(r(n.decode(e)));
      if (!t) throw new Error("Invalid checksum");
      return t;
    },
    decodeUnsafe: function decodeUnsafe(e) {
      var t = n.decodeUnsafe(e);
      if (t) return r(t);
    }
  };
}(function (e) {
  return t(t(e));
});


/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/buffer.js"
/*!*************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/buffer.js ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength2(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}
var base64 = {
  byteLength: byteLength2,
  toByteArray: toByteArray,
  fromByteArray: fromByteArray
};
var ieee754 = {
  read: function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  },
  write: function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  }
};
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') : null;
var exports = {};
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
var K_STRING_MAX_LENGTH = (1 << 28) - 16;
exports.kStringMaxLength = K_STRING_MAX_LENGTH;
exports.constants = {
  MAX_LENGTH: K_MAX_LENGTH,
  MAX_STRING_LENGTH: K_STRING_MAX_LENGTH
};
exports.Blob = typeof Blob !== 'undefined' ? Blob : undefined;
exports.File = typeof File !== 'undefined' ? File : undefined;
exports.atob = typeof atob !== 'undefined' ? atob : undefined;
exports.btoa = typeof btoa !== 'undefined' ? btoa : undefined;
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function Buffer(arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var _i = 0; _i < length; _i += 1) {
    buf[_i] = array[_i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var _len = checked(obj.length) | 0;
    var buf = createBuffer(_len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, _len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
  if (!isInstance(a, Uint8Array) || !isInstance(b, Uint8Array)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var _i2 = 0, _len2 = Math.min(x, y); _i2 < _len2; ++_i2) {
    if (a[_i2] !== b[_i2]) {
      x = a[_i2];
      y = b[_i2];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!isInstance(buf, Uint8Array)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (pos + buf.length > buffer.length) {
      buffer.set(buf.subarray(0, buffer.length - pos), pos);
      break;
    }
    buffer.set(buf, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof SharedArrayBuffer !== 'undefined' && isInstance(string, SharedArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length;
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var _i3 = 0; _i3 < len; _i3 += 2) {
    swap(this, _i3, _i3 + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var _i4 = 0; _i4 < len; _i4 += 4) {
    swap(this, _i4, _i4 + 3);
    swap(this, _i4 + 1, _i4 + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var _i5 = 0; _i5 < len; _i5 += 8) {
    swap(this, _i5, _i5 + 7);
    swap(this, _i5 + 1, _i5 + 6);
    swap(this, _i5 + 2, _i5 + 5);
    swap(this, _i5 + 3, _i5 + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!isInstance(target, Uint8Array)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  for (var _i6 = 0; _i6 < len; ++_i6) {
    if (this[thisStart + _i6] !== target[start + _i6]) {
      x = this[thisStart + _i6];
      y = target[start + _i6];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;
  if (numberIsNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }
  if (Buffer.isBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF;
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen >>> 1) {
    length = strLen >>> 1;
  }
  for (var _i7 = 0; _i7 < length; ++_i7) {
    var a = string.charCodeAt(_i7 * 2 + 0);
    var b = string.charCodeAt(_i7 * 2 + 1);
    var hi = hexCharValueTable[a & 0x7f];
    var lo = hexCharValueTable[b & 0x7f];
    if ((a | b | hi | lo) & ~0x7f) {
      return _i7;
    }
    buf[offset + _i7] = hi << 4 | lo;
  }
  return length;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
        thirdByte = void 0,
        fourthByte = void 0,
        tempCodePoint = void 0;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var _i8 = start; _i8 < end; ++_i8) {
    ret += String.fromCharCode(buf[_i8] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var _i9 = start; _i9 < end; ++_i9) {
    ret += String.fromCharCode(buf[_i9]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var _i0 = start; _i0 < end; ++_i0) {
    out += hexSliceLookupTable[buf[_i0]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var _i1 = 0; _i1 < bytes.length - 1; _i1 += 2) {
    res += String.fromCharCode(bytes[_i1] + bytes[_i1 + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = (first << 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!isInstance(target, Uint8Array)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var _code = val.charCodeAt(0);
      if (encoding === 'utf8' && _code < 128 || encoding === 'latin1') {
        val = _code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = isInstance(val, Uint8Array) ? val : Buffer.from(val, encoding);
    var _len3 = bytes.length;
    if (_len3 === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % _len3];
    }
  }
  return this;
};
var errors = {};
function E(sym, getMessage, Base) {
  function NodeError() {
    var err = new Base(getMessage.apply(null, arguments));
    Object.setPrototypeOf(err, NodeError.prototype);
    err.code = sym;
    err.name = "".concat(err.name, " [").concat(sym, "]");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(err, NodeError);
    }
    err.stack;
    delete err.name;
    return err;
  }
  Object.setPrototypeOf(NodeError.prototype, Base.prototype);
  Object.setPrototypeOf(NodeError, Base);
  NodeError.prototype.toString = function toString() {
    return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
  };
  errors[sym] = NodeError;
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;
  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);
    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }
    received += 'n';
  }
  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);
function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }
  return "".concat(val.slice(0, i)).concat(res);
}
function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }
  checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }
  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
}
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = str.split('=')[0];
  str = str.trim().replace(INVALID_BASE64_RE, '');
  if (str.length < 2) return '';
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var _i10 = 0; _i10 < length; ++_i10) {
    codePoint = string.charCodeAt(_i10);
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      if (!leadSurrogate) {
        if (codePoint > 0xDBFF) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (_i10 + 1 === length) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var _i11 = 0; _i11 < str.length; ++_i11) {
    byteArray.push(str.charCodeAt(_i11) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var _i12 = 0; _i12 < str.length; ++_i12) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(_i12);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  var i;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name || type === Uint8Array && Buffer.isBuffer(obj);
}
function numberIsNaN(obj) {
  return obj !== obj;
}
var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var _i13 = 0; _i13 < 16; ++_i13) {
    var i16 = _i13 * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[_i13] + alphabet[j];
    }
  }
  return table;
}();
var hexCharValueTable = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Buffer);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/hash/common.js"
/*!******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/hash/common.js ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./src/analyze/crypto/bitcoin/v5/hash/utils.js");

function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};
function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
var common = {
  BlockHash: BlockHash
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (common);
BlockHash.prototype.update = function update(msg, enc) {
  msg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);
  return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++) res[i] = 0;
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t = 8; t < this.padLength; t++) res[i++] = 0;
  }
  return res;
};

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/hash/sha/256.js"
/*!*******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/hash/sha/256.js ***!
  \*******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/analyze/crypto/bitcoin/v5/hash/utils.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common.js */ "./src/analyze/crypto/bitcoin/v5/hash/common.js");
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ "./src/analyze/crypto/bitcoin/v5/hash/sha/common.js");



var assert = _utils_js__WEBPACK_IMPORTED_MODULE_0__.assert;
var sum32 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.sum32;
var sum32_4 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.sum32_4;
var sum32_5 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.sum32_5;
var ch32 = _common_js__WEBPACK_IMPORTED_MODULE_2__.ch32;
var maj32 = _common_js__WEBPACK_IMPORTED_MODULE_2__.maj32;
var s0_256 = _common_js__WEBPACK_IMPORTED_MODULE_2__.s0_256;
var s1_256 = _common_js__WEBPACK_IMPORTED_MODULE_2__.s1_256;
var g0_256 = _common_js__WEBPACK_IMPORTED_MODULE_2__.g0_256;
var g1_256 = _common_js__WEBPACK_IMPORTED_MODULE_2__.g1_256;
var BlockHash = _common_js__WEBPACK_IMPORTED_MODULE_1__["default"].BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
function SHA256() {
  if (!(this instanceof SHA256)) return new SHA256();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}
_utils_js__WEBPACK_IMPORTED_MODULE_0__.inherits(SHA256, BlockHash);
var sha256 = SHA256;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha256);
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++) W[i] = msg[start + i];
  for (; i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }
  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex') return _utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex32(this.h, 'big');else return _utils_js__WEBPACK_IMPORTED_MODULE_0__.split32(this.h, 'big');
};

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/hash/sha/common.js"
/*!**********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/hash/sha/common.js ***!
  \**********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ch32: () => (/* binding */ ch32),
/* harmony export */   ft_1: () => (/* binding */ ft_1),
/* harmony export */   g0_256: () => (/* binding */ g0_256),
/* harmony export */   g1_256: () => (/* binding */ g1_256),
/* harmony export */   maj32: () => (/* binding */ maj32),
/* harmony export */   p32: () => (/* binding */ p32),
/* harmony export */   s0_256: () => (/* binding */ s0_256),
/* harmony export */   s1_256: () => (/* binding */ s1_256)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./src/analyze/crypto/bitcoin/v5/hash/utils.js");

var rotr32 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr32;
function ft_1(s, x, y, z) {
  if (s === 0) return ch32(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32(x, y, z);
}
function ch32(x, y, z) {
  return x & y ^ ~x & z;
}
function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
function p32(x, y, z) {
  return x ^ y ^ z;
}
function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/hash/utils.js"
/*!*****************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/hash/utils.js ***!
  \*****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert),
/* harmony export */   htonl: () => (/* binding */ htonl),
/* harmony export */   inherits: () => (/* binding */ inherits),
/* harmony export */   join32: () => (/* binding */ join32),
/* harmony export */   rotl32: () => (/* binding */ rotl32),
/* harmony export */   rotr32: () => (/* binding */ rotr32),
/* harmony export */   rotr64_hi: () => (/* binding */ rotr64_hi),
/* harmony export */   rotr64_lo: () => (/* binding */ rotr64_lo),
/* harmony export */   shr64_hi: () => (/* binding */ shr64_hi),
/* harmony export */   shr64_lo: () => (/* binding */ shr64_lo),
/* harmony export */   split32: () => (/* binding */ split32),
/* harmony export */   sum32: () => (/* binding */ sum32),
/* harmony export */   sum32_3: () => (/* binding */ sum32_3),
/* harmony export */   sum32_4: () => (/* binding */ sum32_4),
/* harmony export */   sum32_5: () => (/* binding */ sum32_5),
/* harmony export */   sum64: () => (/* binding */ sum64),
/* harmony export */   sum64_4_hi: () => (/* binding */ sum64_4_hi),
/* harmony export */   sum64_4_lo: () => (/* binding */ sum64_4_lo),
/* harmony export */   sum64_5_hi: () => (/* binding */ sum64_5_hi),
/* harmony export */   sum64_5_lo: () => (/* binding */ sum64_5_lo),
/* harmony export */   sum64_hi: () => (/* binding */ sum64_hi),
/* harmony export */   sum64_lo: () => (/* binding */ sum64_lo),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toHex: () => (/* binding */ toHex),
/* harmony export */   toHex32: () => (/* binding */ toHex32),
/* harmony export */   zero2: () => (/* binding */ zero2),
/* harmony export */   zero8: () => (/* binding */ zero8)
/* harmony export */ });


function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};
function inherits(ctor, superCtor) {
  if (superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  }
}
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
  }
  return res;
}
function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
  return res;
}
function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}
function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}
function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}
function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}
function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}
function sum32(a, b) {
  return a + b >>> 0;
}
function sum32_3(a, b, c) {
  return a + b + c >>> 0;
}
function sum32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}
function sum32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}
function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
function sum64_hi(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
function rotr64_hi(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}
function rotr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}
function shr64_hi(ah, al, num) {
  return ah >>> num;
}
function shr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v5/payments/varuint-bitcoin.js"
/*!*******************************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v5/payments/varuint-bitcoin.js ***!
  \*******************************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   encodingLength: () => (/* binding */ encodingLength)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../buffer.js */ "./src/analyze/crypto/bitcoin/v5/buffer.js");

var MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');
}
function encode(number, buffer, offset) {
  checkUInt53(number);
  if (!buffer) buffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(encodingLength(number));
  if (!_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset);
    encode.bytes = 1;
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(number, offset + 1);
    encode.bytes = 3;
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(number, offset + 1);
    encode.bytes = 5;
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(number >>> 0, offset + 1);
    buffer.writeUInt32LE(number / 0x100000000 | 0, offset + 5);
    encode.bytes = 9;
  }
  return buffer;
}
function decode(buffer, offset) {
  if (!_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  var first = buffer.readUInt8(offset);
  if (first < 0xfd) {
    decode.bytes = 1;
    return first;
  } else if (first === 0xfd) {
    decode.bytes = 3;
    return buffer.readUInt16LE(offset + 1);
  } else if (first === 0xfe) {
    decode.bytes = 5;
    return buffer.readUInt32LE(offset + 1);
  } else {
    decode.bytes = 9;
    var lo = buffer.readUInt32LE(offset + 1);
    var hi = buffer.readUInt32LE(offset + 5);
    var number = hi * 0x0100000000 + lo;
    checkUInt53(number);
    return number;
  }
}
function encodingLength(number) {
  checkUInt53(number);
  return number < 0xfd ? 1 : number <= 0xffff ? 3 : number <= 0xffffffff ? 5 : 9;
}


/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/address.js"
/*!**************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/address.js ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _payments_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./payments/index.js */ "./src/analyze/crypto/bitcoin/v6/payments/index.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../v5/bech32@2.0.0.js */ "./src/analyze/crypto/bitcoin/v5/bech32@2.0.0.js");
/* harmony import */ var _v5_bs58check_3_0_1_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../v5/bs58check@3.0.1.js */ "./src/analyze/crypto/bitcoin/v5/bs58check@3.0.1.js");






var exports = {};
var FUTURE_SEGWIT_MAX_SIZE = 40;
var FUTURE_SEGWIT_MIN_SIZE = 2;
var FUTURE_SEGWIT_MAX_VERSION = 16;
var FUTURE_SEGWIT_MIN_VERSION = 2;
var FUTURE_SEGWIT_VERSION_DIFF = 0x50;
var FUTURE_SEGWIT_VERSION_WARNING = 'WARNING: Sending to a future segwit version address can lead to loss of funds. ' + 'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' + 'with caution. Wallets should verify the segwit version from the output of fromBech32, ' + 'then decide when it is safe to use which version of segwit.';
function _toFutureSegwitAddress(output, network) {
  var data = output.slice(2);
  if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE) throw new TypeError('Invalid program length for segwit address');
  var version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
  if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION) throw new TypeError('Invalid version for segwit address');
  if (output[1] !== data.length) throw new TypeError('Invalid script for segwit address');
  console.warn(FUTURE_SEGWIT_VERSION_WARNING);
  return toBech32(data, version, network.bech32);
}
function fromBase58Check(address) {
  var payload = Buffer.from(_v5_bs58check_3_0_1_js__WEBPACK_IMPORTED_MODULE_5__["default"].decode(address));
  if (payload.length < 21) throw new TypeError(address + ' is too short');
  if (payload.length > 21) throw new TypeError(address + ' is too long');
  var version = payload.readUInt8(0);
  var hash = payload.slice(1);
  return {
    version: version,
    hash: hash
  };
}
exports.fromBase58Check = fromBase58Check;
function fromBech32(address) {
  var result;
  var version;
  try {
    result = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32.decode(address);
  } catch (e) {}
  if (result) {
    version = result.words[0];
    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');
  } else {
    result = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32m.decode(address);
    version = result.words[0];
    if (version === 0) throw new TypeError(address + ' uses wrong encoding');
  }
  var data = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32.fromWords(result.words.slice(1));
  return {
    version: version,
    prefix: result.prefix,
    data: Buffer.from(data)
  };
}
exports.fromBech32 = fromBech32;
function toBase58Check(hash, version) {
  (0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce)((0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].tuple)(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].Hash160bit, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].UInt8), arguments);
  var payload = Buffer.allocUnsafe(21);
  payload.writeUInt8(version, 0);
  hash.copy(payload, 1);
  return _v5_bs58check_3_0_1_js__WEBPACK_IMPORTED_MODULE_5__["default"].encode(payload);
}
exports.toBase58Check = toBase58Check;
function toBech32(data, version, prefix) {
  var words = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32.toWords(data);
  words.unshift(version);
  return version === 0 ? _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32.encode(prefix, words) : _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_4__.bech32m.encode(prefix, words);
}
exports.toBech32 = toBech32;
function fromOutputScript(output, network) {
  network = network || _networks_js__WEBPACK_IMPORTED_MODULE_0__["default"].bitcoin;
  try {
    return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2pkh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2sh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2wpkh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2wsh({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2tr({
      output: output,
      network: network
    }).address;
  } catch (e) {}
  try {
    return _toFutureSegwitAddress(output, network);
  } catch (e) {}
  throw new Error(_script_js__WEBPACK_IMPORTED_MODULE_2__["default"].toASM(output) + ' has no matching Address');
}
exports.fromOutputScript = fromOutputScript;
function toOutputScript(address, network) {
  network = network || _networks_js__WEBPACK_IMPORTED_MODULE_0__["default"].bitcoin;
  var decodeBase58;
  var decodeBech32;
  try {
    decodeBase58 = fromBase58Check(address);
  } catch (e) {}
  if (decodeBase58) {
    if (decodeBase58.version === network.pubKeyHash) return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2pkh({
      hash: decodeBase58.hash
    }).output;
    if (decodeBase58.version === network.scriptHash) return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2sh({
      hash: decodeBase58.hash
    }).output;
  } else {
    try {
      decodeBech32 = fromBech32(address);
    } catch (e) {}
    if (decodeBech32) {
      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20) return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2wpkh({
          hash: decodeBech32.data
        }).output;
        if (decodeBech32.data.length === 32) return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2wsh({
          hash: decodeBech32.data
        }).output;
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32) return _payments_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2tr({
          pubkey: decodeBech32.data
        }).output;
      } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
        console.warn(FUTURE_SEGWIT_VERSION_WARNING);
        return _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile([decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF, decodeBech32.data]);
      }
    }
  }
  throw new Error(address + ' has no matching Script');
}
exports.toOutputScript = toOutputScript;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/bip66.js"
/*!************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/bip66.js ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var exports = {};
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  var lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  var lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) return false;
  return true;
}
exports.check = check;
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  var lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  var lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded');
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  };
}
exports.decode = decode;
function encode(r, s) {
  var lenR = r.length;
  var lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) throw new Error('S value excessively padded');
  var signature = Buffer.allocUnsafe(6 + lenR + lenS);
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
exports.encode = encode;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/buffer.js"
/*!*************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/buffer.js ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength2(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}
var base64 = {
  byteLength: byteLength2,
  toByteArray: toByteArray,
  fromByteArray: fromByteArray
};
var ieee754 = {
  read: function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  },
  write: function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  }
};
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') : null;
var exports = {};
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
var K_STRING_MAX_LENGTH = (1 << 28) - 16;
exports.kStringMaxLength = K_STRING_MAX_LENGTH;
exports.constants = {
  MAX_LENGTH: K_MAX_LENGTH,
  MAX_STRING_LENGTH: K_STRING_MAX_LENGTH
};
exports.Blob = typeof Blob !== 'undefined' ? Blob : undefined;
exports.File = typeof File !== 'undefined' ? File : undefined;
exports.atob = typeof atob !== 'undefined' ? atob : undefined;
exports.btoa = typeof btoa !== 'undefined' ? btoa : undefined;
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function Buffer(arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }
  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var _i = 0; _i < length; _i += 1) {
    buf[_i] = array[_i] & 255;
  }
  return buf;
}
function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }
  return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var _len = checked(obj.length) | 0;
    var buf = createBuffer(_len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, _len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
  if (!isInstance(a, Uint8Array) || !isInstance(b, Uint8Array)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var _i2 = 0, _len2 = Math.min(x, y); _i2 < _len2; ++_i2) {
    if (a[_i2] !== b[_i2]) {
      x = a[_i2];
      y = b[_i2];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!isInstance(buf, Uint8Array)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (pos + buf.length > buffer.length) {
      buffer.set(buf.subarray(0, buffer.length - pos), pos);
      break;
    }
    buffer.set(buf, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof SharedArrayBuffer !== 'undefined' && isInstance(string, SharedArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length;
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === undefined || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var _i3 = 0; _i3 < len; _i3 += 2) {
    swap(this, _i3, _i3 + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var _i4 = 0; _i4 < len; _i4 += 4) {
    swap(this, _i4, _i4 + 3);
    swap(this, _i4 + 1, _i4 + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var _i5 = 0; _i5 < len; _i5 += 8) {
    swap(this, _i5, _i5 + 7);
    swap(this, _i5 + 1, _i5 + 6);
    swap(this, _i5 + 2, _i5 + 5);
    swap(this, _i5 + 3, _i5 + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!isInstance(target, Uint8Array)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  for (var _i6 = 0; _i6 < len; ++_i6) {
    if (this[thisStart + _i6] !== target[start + _i6]) {
      x = this[thisStart + _i6];
      y = target[start + _i6];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0) return -1;
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;
  if (numberIsNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }
  if (Buffer.isBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF;
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen >>> 1) {
    length = strLen >>> 1;
  }
  for (var _i7 = 0; _i7 < length; ++_i7) {
    var a = string.charCodeAt(_i7 * 2 + 0);
    var b = string.charCodeAt(_i7 * 2 + 1);
    var hi = hexCharValueTable[a & 0x7f];
    var lo = hexCharValueTable[b & 0x7f];
    if ((a | b | hi | lo) & ~0x7f) {
      return _i7;
    }
    buf[offset + _i7] = hi << 4 | lo;
  }
  return length;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);
      case 'base64':
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
        thirdByte = void 0,
        fourthByte = void 0,
        tempCodePoint = void 0;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var _i8 = start; _i8 < end; ++_i8) {
    ret += String.fromCharCode(buf[_i8] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var _i9 = start; _i9 < end; ++_i9) {
    ret += String.fromCharCode(buf[_i9]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var _i0 = start; _i0 < end; ++_i0) {
    out += hexSliceLookupTable[buf[_i0]];
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var _i1 = 0; _i1 < bytes.length - 1; _i1 += 2) {
    res += String.fromCharCode(bytes[_i1] + bytes[_i1 + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24);
  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }
  var val = (first << 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!isInstance(target, Uint8Array)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var _code = val.charCodeAt(0);
      if (encoding === 'utf8' && _code < 128 || encoding === 'latin1') {
        val = _code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = isInstance(val, Uint8Array) ? val : Buffer.from(val, encoding);
    var _len3 = bytes.length;
    if (_len3 === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % _len3];
    }
  }
  return this;
};
var errors = {};
function E(sym, getMessage, Base) {
  function NodeError() {
    var err = new Base(getMessage.apply(null, arguments));
    Object.setPrototypeOf(err, NodeError.prototype);
    err.code = sym;
    err.name = "".concat(err.name, " [").concat(sym, "]");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(err, NodeError);
    }
    err.stack;
    delete err.name;
    return err;
  }
  Object.setPrototypeOf(NodeError.prototype, Base.prototype);
  Object.setPrototypeOf(NodeError, Base);
  NodeError.prototype.toString = function toString() {
    return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
  };
  errors[sym] = NodeError;
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }
  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;
  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);
    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }
    received += 'n';
  }
  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);
function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;
  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }
  return "".concat(val.slice(0, i)).concat(res);
}
function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }
  checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}
function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }
  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }
  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
}
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = str.split('=')[0];
  str = str.trim().replace(INVALID_BASE64_RE, '');
  if (str.length < 2) return '';
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var _i10 = 0; _i10 < length; ++_i10) {
    codePoint = string.charCodeAt(_i10);
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      if (!leadSurrogate) {
        if (codePoint > 0xDBFF) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (_i10 + 1 === length) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var _i11 = 0; _i11 < str.length; ++_i11) {
    byteArray.push(str.charCodeAt(_i11) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var _i12 = 0; _i12 < str.length; ++_i12) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(_i12);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  var i;
  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name || type === Uint8Array && Buffer.isBuffer(obj);
}
function numberIsNaN(obj) {
  return obj !== obj;
}
var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);
  for (var _i13 = 0; _i13 < 16; ++_i13) {
    var i16 = _i13 * 16;
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[_i13] + alphabet[j];
    }
  }
  return table;
}();
var hexCharValueTable = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Buffer);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/bufferutils.js"
/*!******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/bufferutils.js ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../v5/payments/varuint-bitcoin.js */ "./src/analyze/crypto/bitcoin/v5/payments/varuint-bitcoin.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var typeforce = _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].typeforce;
var exports = {};
exports.varuint = _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__;
function verifuint(value, max) {
  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');
  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');
  if (value > max) throw new Error('RangeError: value out of range');
  if (Math.floor(value) !== value) throw new Error('value has a fractional component');
}
function readUInt64LE(buffer, offset) {
  var a = buffer.readUInt32LE(offset);
  var b = buffer.readUInt32LE(offset + 4);
  b *= 0x100000000;
  verifuint(b + a, 0x001fffffffffffff);
  return b + a;
}
exports.readUInt64LE = readUInt64LE;
function writeUInt64LE(buffer, value, offset) {
  verifuint(value, 0x001fffffffffffff);
  buffer.writeInt32LE(value & -1, offset);
  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);
  return offset + 8;
}
exports.writeUInt64LE = writeUInt64LE;
function reverseBuffer(buffer) {
  if (buffer.length < 1) return buffer;
  var j = buffer.length - 1;
  var tmp = 0;
  for (var i = 0; i < buffer.length / 2; i++) {
    tmp = buffer[i];
    buffer[i] = buffer[j];
    buffer[j] = tmp;
    j--;
  }
  return buffer;
}
exports.reverseBuffer = reverseBuffer;
function cloneBuffer(buffer) {
  var clone = Buffer.allocUnsafe(buffer.length);
  buffer.copy(clone);
  return clone;
}
exports.cloneBuffer = cloneBuffer;
var BufferWriter = function () {
  function BufferWriter(buffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, BufferWriter);
    this.buffer = buffer;
    this.offset = offset;
    typeforce(_types_js__WEBPACK_IMPORTED_MODULE_0__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer, _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].UInt32), [buffer, offset]);
  }
  return _createClass(BufferWriter, [{
    key: "writeUInt8",
    value: function writeUInt8(i) {
      this.offset = this.buffer.writeUInt8(i, this.offset);
    }
  }, {
    key: "writeInt32",
    value: function writeInt32(i) {
      this.offset = this.buffer.writeInt32LE(i, this.offset);
    }
  }, {
    key: "writeUInt32",
    value: function writeUInt32(i) {
      this.offset = this.buffer.writeUInt32LE(i, this.offset);
    }
  }, {
    key: "writeUInt64",
    value: function writeUInt64(i) {
      this.offset = writeUInt64LE(this.buffer, i, this.offset);
    }
  }, {
    key: "writeVarInt",
    value: function writeVarInt(i) {
      _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__.encode(i, this.buffer, this.offset);
      this.offset += _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__.encode.bytes;
    }
  }, {
    key: "writeSlice",
    value: function writeSlice(slice) {
      if (this.buffer.length < this.offset + slice.length) {
        throw new Error('Cannot write slice out of bounds');
      }
      this.offset += slice.copy(this.buffer, this.offset);
    }
  }, {
    key: "writeVarSlice",
    value: function writeVarSlice(slice) {
      this.writeVarInt(slice.length);
      this.writeSlice(slice);
    }
  }, {
    key: "writeVector",
    value: function writeVector(vector) {
      var _this = this;
      this.writeVarInt(vector.length);
      vector.forEach(function (buf) {
        return _this.writeVarSlice(buf);
      });
    }
  }, {
    key: "end",
    value: function end() {
      if (this.buffer.length === this.offset) {
        return this.buffer;
      }
      throw new Error("buffer size ".concat(this.buffer.length, ", offset ").concat(this.offset));
    }
  }], [{
    key: "withCapacity",
    value: function withCapacity(size) {
      return new BufferWriter(Buffer.alloc(size));
    }
  }]);
}();
exports.BufferWriter = BufferWriter;
var BufferReader = function () {
  function BufferReader(buffer) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    _classCallCheck(this, BufferReader);
    this.buffer = buffer;
    this.offset = offset;
    typeforce(_types_js__WEBPACK_IMPORTED_MODULE_0__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_0__["default"].Buffer, _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].UInt32), [buffer, offset]);
  }
  return _createClass(BufferReader, [{
    key: "readUInt8",
    value: function readUInt8() {
      var result = this.buffer.readUInt8(this.offset);
      this.offset++;
      return result;
    }
  }, {
    key: "readInt32",
    value: function readInt32() {
      var result = this.buffer.readInt32LE(this.offset);
      this.offset += 4;
      return result;
    }
  }, {
    key: "readUInt32",
    value: function readUInt32() {
      var result = this.buffer.readUInt32LE(this.offset);
      this.offset += 4;
      return result;
    }
  }, {
    key: "readUInt64",
    value: function readUInt64() {
      var result = readUInt64LE(this.buffer, this.offset);
      this.offset += 8;
      return result;
    }
  }, {
    key: "readVarInt",
    value: function readVarInt() {
      var vi = _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__.decode(this.buffer, this.offset);
      this.offset += _v5_payments_varuint_bitcoin_js__WEBPACK_IMPORTED_MODULE_1__.decode.bytes;
      return vi;
    }
  }, {
    key: "readSlice",
    value: function readSlice(n) {
      if (this.buffer.length < this.offset + n) {
        throw new Error('Cannot read slice out of bounds');
      }
      var result = this.buffer.slice(this.offset, this.offset + n);
      this.offset += n;
      return result;
    }
  }, {
    key: "readVarSlice",
    value: function readVarSlice() {
      return this.readSlice(this.readVarInt());
    }
  }, {
    key: "readVector",
    value: function readVector() {
      var count = this.readVarInt();
      var vector = [];
      for (var i = 0; i < count; i++) vector.push(this.readVarSlice());
      return vector;
    }
  }]);
}();
exports.BufferReader = BufferReader;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/crypto.js"
/*!*************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/crypto.js ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");
/* harmony import */ var _algorithm_ripemd160_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../algorithm/ripemd160.js */ "./src/analyze/crypto/algorithm/ripemd160.js");
/* harmony import */ var _algorithm_sha256_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../algorithm/sha256.js */ "./src/analyze/crypto/algorithm/sha256.js");



var exports = {};
function ripemd160(buffer) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from((0,_algorithm_ripemd160_js__WEBPACK_IMPORTED_MODULE_1__["default"])(Uint8Array.from(buffer)));
}
exports.ripemd160 = ripemd160;
function sha1(buffer) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from((0, sha1_1)(Uint8Array.from(buffer)));
}
exports.sha1 = sha1;
function sha256(buffer) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from((0, _algorithm_sha256_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Uint8Array.from(buffer)));
}
exports.sha256 = sha256;
function hash160(buffer) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from((0, ripemd160)((0, _algorithm_sha256_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Uint8Array.from(buffer))));
}
exports.hash160 = hash160;
function hash256(buffer) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from((0, _algorithm_sha256_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0, _algorithm_sha256_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Uint8Array.from(buffer))));
}
exports.hash256 = hash256;
exports.TAGS = ['BIP0340/challenge', 'BIP0340/aux', 'BIP0340/nonce', 'TapLeaf', 'TapBranch', 'TapSighash', 'TapTweak', 'KeyAgg list', 'KeyAgg coefficient'];
exports.TAGGED_HASH_PREFIXES = {
  'BIP0340/challenge': _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124, 123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130, 210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124]),
  'BIP0340/aux': _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144, 241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160, 105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144]),
  'BIP0340/nonce': _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47]),
  TapLeaf: _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238]),
  TapBranch: _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21]),
  TapSighash: _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49]),
  TapTweak: _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233]),
  'KeyAgg list': _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240]),
  'KeyAgg coefficient': _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129])
};
function taggedHash(prefix, data) {
  return sha256(_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
}
exports.taggedHash = taggedHash;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/ecc_lib.js"
/*!**************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/ecc_lib.js ***!
  \**************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");

var exports = {};
var _ECCLIB_CACHE = {};
function initEccLib(eccLib, opts) {
  if (!eccLib) {
    _ECCLIB_CACHE.eccLib = eccLib;
  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
    if (!(opts !== null && opts !== void 0 && opts.DANGER_DO_NOT_VERIFY_ECCLIB)) verifyEcc(eccLib);
    _ECCLIB_CACHE.eccLib = eccLib;
  }
}
exports.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib) throw new Error('No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance');
  return _ECCLIB_CACHE.eccLib;
}
exports.getEccLib = getEccLib;
var h = function h(hex) {
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(hex, 'hex');
};
function verifyEcc(ecc) {
  assert(typeof ecc.isXOnlyPoint === 'function');
  assert(ecc.isXOnlyPoint(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
  assert(ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e')));
  assert(ecc.isXOnlyPoint(h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9')));
  assert(ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000001')));
  assert(!ecc.isXOnlyPoint(h('0000000000000000000000000000000000000000000000000000000000000000')));
  assert(!ecc.isXOnlyPoint(h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f')));
  assert(typeof ecc.xOnlyPointAddTweak === 'function');
  tweakAddVectors.forEach(function (t) {
    var r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));
    if (t.result === null) {
      assert(r === null);
    } else {
      assert(r !== null);
      assert(r.parity === t.parity);
      assert(_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(r.xOnlyPubkey).equals(h(t.result)));
    }
  });
}
function assert(bool) {
  if (!bool) throw new Error('ecc library invalid');
}
var tweakAddVectors = [{
  pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
  tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',
  parity: -1,
  result: null
}, {
  pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',
  tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',
  parity: 1,
  result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'
}, {
  pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',
  tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',
  parity: 0,
  result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'
}];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/networks.js"
/*!***************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/networks.js ***!
  \***************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

var networks = {};
networks.bitcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bc',
  bip32: {
    "public": 0x0488b21e,
    "private": 0x0488ade4
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80
};
networks.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    "public": 0x043587cf,
    "private": 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};
networks.testnet = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'tb',
  bip32: {
    "public": 0x043587cf,
    "private": 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (networks);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/ops.js"
/*!**********************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/ops.js ***!
  \**********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OPS: () => (/* binding */ OPS),
/* harmony export */   REVERSE_OPS: () => (/* binding */ REVERSE_OPS)
/* harmony export */ });
var OPS = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
var REVERSE_OPS = {};
for (var _i = 0, _Object$keys = Object.keys(OPS); _i < _Object$keys.length; _i++) {
  var op = _Object$keys[_i];
  var code = OPS[op];
  REVERSE_OPS[code] = op;
}

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/bip341.js"
/*!**********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/bip341.js ***!
  \**********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");
/* harmony import */ var _ecc_lib_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ecc_lib.js */ "./src/analyze/crypto/bitcoin/v6/ecc_lib.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");
/* harmony import */ var _bufferutils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bufferutils.js */ "./src/analyze/crypto/bitcoin/v6/bufferutils.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }





var exports = {};
exports.LEAF_VERSION_TAPSCRIPT = 0xc0;
exports.MAX_TAPTREE_DEPTH = 128;
var isHashBranch = function isHashBranch(ht) {
  return 'left' in ht && 'right' in ht;
};
function rootHashFromPath(controlBlock, leafHash) {
  if (controlBlock.length < 33) throw new TypeError("The control-block length is too small. Got ".concat(controlBlock.length, ", expected min 33."));
  var m = (controlBlock.length - 33) / 32;
  var kj = leafHash;
  for (var j = 0; j < m; j++) {
    var ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);
    if (kj.compare(ej) < 0) {
      kj = tapBranchHash(kj, ej);
    } else {
      kj = tapBranchHash(ej, kj);
    }
  }
  return kj;
}
exports.rootHashFromPath = rootHashFromPath;
function toHashTree(scriptTree) {
  if ((0, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].isTapleaf)(scriptTree)) return {
    hash: tapleafHash(scriptTree)
  };
  var hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
  hashes.sort(function (a, b) {
    return a.hash.compare(b.hash);
  });
  var left = hashes[0],
    right = hashes[1];
  return {
    hash: tapBranchHash(left.hash, right.hash),
    left: left,
    right: right
  };
}
exports.toHashTree = toHashTree;
function findScriptPath(node, hash) {
  if (isHashBranch(node)) {
    var leftPath = findScriptPath(node.left, hash);
    if (leftPath !== undefined) return [].concat(_toConsumableArray(leftPath), [node.right.hash]);
    var rightPath = findScriptPath(node.right, hash);
    if (rightPath !== undefined) return [].concat(_toConsumableArray(rightPath), [node.left.hash]);
  } else if (node.hash.equals(hash)) {
    return [];
  }
  return undefined;
}
exports.findScriptPath = findScriptPath;
function tapleafHash(leaf) {
  var version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
  return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].taggedHash('TapLeaf', _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([version]), serializeScript(leaf.output)]));
}
exports.tapleafHash = tapleafHash;
function tapTweakHash(pubKey, h) {
  return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].taggedHash('TapTweak', _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat(h ? [pubKey, h] : [pubKey]));
}
exports.tapTweakHash = tapTweakHash;
function tweakKey(pubKey, h) {
  if (!_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(pubKey)) return null;
  if (pubKey.length !== 32) return null;
  if (h && h.length !== 32) return null;
  var tweakHash = tapTweakHash(pubKey, h);
  var res = (0, _ecc_lib_js__WEBPACK_IMPORTED_MODULE_1__["default"].getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
  if (!res || res.xOnlyPubkey === null) return null;
  return {
    parity: res.parity,
    x: _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(res.xOnlyPubkey)
  };
}
exports.tweakKey = tweakKey;
function tapBranchHash(a, b) {
  return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].taggedHash('TapBranch', _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([a, b]));
}
function serializeScript(s) {
  var varintLen = _bufferutils_js__WEBPACK_IMPORTED_MODULE_3__["default"].varuint.encodingLength(s.length);
  var buffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(varintLen);
  _bufferutils_js__WEBPACK_IMPORTED_MODULE_3__["default"].varuint.encode(s.length, buffer);
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([buffer, s]);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/index.js"
/*!*********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/index.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _p2pkh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./p2pkh.js */ "./src/analyze/crypto/bitcoin/v6/payments/p2pkh.js");
/* harmony import */ var _p2sh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./p2sh.js */ "./src/analyze/crypto/bitcoin/v6/payments/p2sh.js");
/* harmony import */ var _p2wpkh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./p2wpkh.js */ "./src/analyze/crypto/bitcoin/v6/payments/p2wpkh.js");
/* harmony import */ var _p2tr_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./p2tr.js */ "./src/analyze/crypto/bitcoin/v6/payments/p2tr.js");




var exports = {};
Object.defineProperty(exports, 'p2pkh', {
  enumerable: true,
  get: function get() {
    return _p2pkh_js__WEBPACK_IMPORTED_MODULE_0__["default"].p2pkh;
  }
});
Object.defineProperty(exports, 'p2sh', {
  enumerable: true,
  get: function get() {
    return _p2sh_js__WEBPACK_IMPORTED_MODULE_1__["default"].p2sh;
  }
});
Object.defineProperty(exports, 'p2wpkh', {
  enumerable: true,
  get: function get() {
    return _p2wpkh_js__WEBPACK_IMPORTED_MODULE_2__["default"].p2wpkh;
  }
});
Object.defineProperty(exports, 'p2tr', {
  enumerable: true,
  get: function get() {
    return _p2tr_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2tr;
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/lazy.js"
/*!********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/lazy.js ***!
  \********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var exports = {};
function prop(object, name, f) {
  Object.defineProperty(object, name, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var _value = f.call(this);
      this[name] = _value;
      return _value;
    },
    set: function set(_value) {
      Object.defineProperty(this, name, {
        configurable: true,
        enumerable: true,
        value: _value,
        writable: true
      });
    }
  });
}
exports.prop = prop;
function value(f) {
  var _value;
  return function () {
    if (_value !== undefined) return _value;
    _value = f();
    return _value;
  };
}
exports.value = value;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/p2pkh.js"
/*!*********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/p2pkh.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v5_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../v5/buffer.js */ "./src/analyze/crypto/bitcoin/v5/buffer.js");
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lazy.js */ "./src/analyze/crypto/bitcoin/v6/payments/lazy.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");






var exports = {};
var OPS = _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPS;
function p2pkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  (0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce)({
    network: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.Object),
    address: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.String),
    hash: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.BufferN(20)),
    output: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.BufferN(25)),
    pubkey: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPoint),
    signature: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isCanonicalScriptSignature),
    input: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.Buffer)
  }, a);
  var _address = _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].value(function () {
    var payload = _v5_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(bs58check.decode(a.address));
    var version = payload.readUInt8(0);
    var hash = payload.slice(1);
    return {
      version: version,
      hash: hash
    };
  });
  var _chunks = _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].value(function () {
    return _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].decompile(a.input);
  });
  var network = a.network || _networks_js__WEBPACK_IMPORTED_MODULE_1__["default"].bitcoin;
  var o = {
    name: 'p2pkh',
    network: network
  };
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'address', function () {
    if (!o.hash) return;
    var payload = _v5_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(21);
    payload.writeUInt8(network.pubKeyHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'hash', function () {
    if (a.output) return a.output.slice(3, 23);
    if (a.address) return _address().hash;
    if (a.pubkey || o.pubkey) return _crypto_js__WEBPACK_IMPORTED_MODULE_5__["default"].hash160(a.pubkey || o.pubkey);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'output', function () {
    if (!o.hash) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile([OPS.OP_DUP, OPS.OP_HASH160, o.hash, OPS.OP_EQUALVERIFY, OPS.OP_CHECKSIG]);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'pubkey', function () {
    if (!a.input) return;
    return _chunks()[1];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'signature', function () {
    if (!a.input) return;
    return _chunks()[0];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'input', function () {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile([a.signature, a.pubkey]);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_4__["default"].prop(o, 'witness', function () {
    if (!o.input) return;
    return [];
  });
  if (opts.validate) {
    var hash = _v5_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([]);
    if (a.address) {
      if (_address().version !== network.pubKeyHash) throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 25 || a.output[0] !== OPS.OP_DUP || a.output[1] !== OPS.OP_HASH160 || a.output[2] !== 0x14 || a.output[23] !== OPS.OP_EQUALVERIFY || a.output[24] !== OPS.OP_CHECKSIG) throw new TypeError('Output is invalid');
      var hash2 = a.output.slice(3, 23);
      if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError('Hash mismatch');else hash = hash2;
    }
    if (a.pubkey) {
      var pkh = _crypto_js__WEBPACK_IMPORTED_MODULE_5__["default"].hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError('Hash mismatch');else hash = pkh;
    }
    if (a.input) {
      var chunks = _chunks();
      if (chunks.length !== 2) throw new TypeError('Input is invalid');
      if (!_script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isCanonicalScriptSignature(chunks[0])) throw new TypeError('Input has invalid signature');
      if (!(0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPoint)(chunks[1])) throw new TypeError('Input has invalid pubkey');
      if (a.signature && !a.signature.equals(chunks[0])) throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(chunks[1])) throw new TypeError('Pubkey mismatch');
      var _pkh = _crypto_js__WEBPACK_IMPORTED_MODULE_5__["default"].hash160(chunks[1]);
      if (hash.length > 0 && !hash.equals(_pkh)) throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2pkh = p2pkh;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/p2sh.js"
/*!********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/p2sh.js ***!
  \********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lazy.js */ "./src/analyze/crypto/bitcoin/v6/payments/lazy.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");





var exports = {};
var OPS = _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPS;
function p2sh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  (0, _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce)({
    network: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Object),
    address: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.String),
    hash: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(20)),
    output: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(23)),
    redeem: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe({
      network: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Object),
      output: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer),
      input: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer),
      witness: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer))
    }),
    input: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer),
    witness: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer))
  }, a);
  var network = a.network;
  if (!network) {
    network = a.redeem && a.redeem.network || _networks_js__WEBPACK_IMPORTED_MODULE_0__["default"].bitcoin;
  }
  var o = {
    network: network
  };
  var _address = _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].value(function () {
    var payload = Buffer.from(bs58check.decode(a.address));
    var version = payload.readUInt8(0);
    var hash = payload.slice(1);
    return {
      version: version,
      hash: hash
    };
  });
  var _chunks = _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].value(function () {
    return _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].decompile(a.input);
  });
  var _redeem = _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].value(function () {
    var chunks = _chunks();
    var lastChunk = chunks[chunks.length - 1];
    return {
      network: network,
      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
      input: _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile(chunks.slice(0, -1)),
      witness: a.witness || []
    };
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'address', function () {
    if (!o.hash) return;
    var payload = Buffer.allocUnsafe(21);
    payload.writeUInt8(o.network.scriptHash, 0);
    o.hash.copy(payload, 1);
    return bs58check.encode(payload);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'hash', function () {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().hash;
    if (o.redeem && o.redeem.output) return _crypto_js__WEBPACK_IMPORTED_MODULE_4__["default"].hash160(o.redeem.output);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'output', function () {
    if (!o.hash) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'redeem', function () {
    if (!a.input) return;
    return _redeem();
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'input', function () {
    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile([].concat(_script_js__WEBPACK_IMPORTED_MODULE_1__["default"].decompile(a.redeem.input), a.redeem.output));
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'witness', function () {
    if (o.redeem && o.redeem.witness) return o.redeem.witness;
    if (o.input) return [];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_3__["default"].prop(o, 'name', function () {
    var nameParts = ['p2sh'];
    if (o.redeem !== undefined && o.redeem.name !== undefined) nameParts.push(o.redeem.name);
    return nameParts.join('-');
  });
  if (opts.validate) {
    var hash = Buffer.from([]);
    if (a.address) {
      if (_address().version !== network.scriptHash) throw new TypeError('Invalid version or Network mismatch');
      if (_address().hash.length !== 20) throw new TypeError('Invalid address');
      hash = _address().hash;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 23 || a.output[0] !== OPS.OP_HASH160 || a.output[1] !== 0x14 || a.output[22] !== OPS.OP_EQUAL) throw new TypeError('Output is invalid');
      var hash2 = a.output.slice(2, 22);
      if (hash.length > 0 && !hash.equals(hash2)) throw new TypeError('Hash mismatch');else hash = hash2;
    }
    var checkRedeem = function checkRedeem(redeem) {
      if (redeem.output) {
        var decompile = _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].decompile(redeem.output);
        if (!decompile || decompile.length < 1) throw new TypeError('Redeem.output too short');
        if (redeem.output.byteLength > 520) throw new TypeError('Redeem.output unspendable if larger than 520 bytes');
        if (_script_js__WEBPACK_IMPORTED_MODULE_1__["default"].countNonPushOnlyOPs(decompile) > 201) throw new TypeError('Redeem.output unspendable with more than 201 non-push ops');
        var _hash = _crypto_js__WEBPACK_IMPORTED_MODULE_4__["default"].hash160(redeem.output);
        if (hash.length > 0 && !hash.equals(_hash)) throw new TypeError('Hash mismatch');else hash = _hash;
      }
      if (redeem.input) {
        var hasInput = redeem.input.length > 0;
        var hasWitness = redeem.witness && redeem.witness.length > 0;
        if (!hasInput && !hasWitness) throw new TypeError('Empty input');
        if (hasInput && hasWitness) throw new TypeError('Input and witness provided');
        if (hasInput) {
          var richunks = _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].decompile(redeem.input);
          if (!_script_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPushOnly(richunks)) throw new TypeError('Non push-only scriptSig');
        }
      }
    };
    if (a.input) {
      var chunks = _chunks();
      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');
      if (!Buffer.isBuffer(_redeem().output)) throw new TypeError('Input is invalid');
      checkRedeem(_redeem());
    }
    if (a.redeem) {
      if (a.redeem.network && a.redeem.network !== network) throw new TypeError('Network mismatch');
      if (a.input) {
        var redeem = _redeem();
        if (a.redeem.output && !a.redeem.output.equals(redeem.output)) throw new TypeError('Redeem.output mismatch');
        if (a.redeem.input && !a.redeem.input.equals(redeem.input)) throw new TypeError('Redeem.input mismatch');
      }
      checkRedeem(a.redeem);
    }
    if (a.witness) {
      if (a.redeem && a.redeem.witness && !(0, _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].stacksEqual)(a.redeem.witness, a.witness)) throw new TypeError('Witness and redeem.witness mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2sh = p2sh;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/p2tr.js"
/*!********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/p2tr.js ***!
  \********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _ecc_lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ecc_lib.js */ "./src/analyze/crypto/bitcoin/v6/ecc_lib.js");
/* harmony import */ var _bip341_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bip341.js */ "./src/analyze/crypto/bitcoin/v6/payments/bip341.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lazy.js */ "./src/analyze/crypto/bitcoin/v6/payments/lazy.js");
/* harmony import */ var _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../v5/bech32@2.0.0.js */ "./src/analyze/crypto/bitcoin/v5/bech32@2.0.0.js");
/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../address.js */ "./src/analyze/crypto/bitcoin/v6/address.js");








var exports = {};
var OPS = _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].OPS;
var TAPROOT_WITNESS_VERSION = 0x01;
var ANNEX_PREFIX = 0x50;
function p2tr(a, opts) {
  if (!a.address && !a.output && !a.pubkey && !a.internalPubkey && !(a.witness && a.witness.length > 1)) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  (0, _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce)({
    address: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.String),
    input: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(0)),
    network: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Object),
    output: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(34)),
    internalPubkey: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(32)),
    hash: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(32)),
    pubkey: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(32)),
    signature: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.anyOf(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(64), _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.BufferN(65))),
    witness: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer)),
    scriptTree: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].isTaptree),
    redeem: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe({
      output: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer),
      redeemVersion: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Number),
      witness: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Buffer))
    }),
    redeemVersion: _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_2__["default"].typeforce.Number)
  }, a);
  var _address = _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].value(function () {
    return (0, _address_js__WEBPACK_IMPORTED_MODULE_7__["default"].fromBech32)(a.address);
  });
  var _witness = _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].value(function () {
    if (!a.witness || !a.witness.length) return;
    if (a.witness.length >= 2 && a.witness[a.witness.length - 1][0] === ANNEX_PREFIX) {
      return a.witness.slice(0, -1);
    }
    return a.witness.slice();
  });
  var _hashTree = _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].value(function () {
    if (a.scriptTree) return (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].toHashTree)(a.scriptTree);
    if (a.hash) return {
      hash: a.hash
    };
    return;
  });
  var network = a.network || _networks_js__WEBPACK_IMPORTED_MODULE_0__["default"].bitcoin;
  var o = {
    name: 'p2tr',
    network: network
  };
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'address', function () {
    if (!o.pubkey) return;
    var words = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_6__.bech32m.toWords(o.pubkey);
    words.unshift(TAPROOT_WITNESS_VERSION);
    return _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_6__.bech32m.encode(network.bech32, words);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'hash', function () {
    var hashTree = _hashTree();
    if (hashTree) return hashTree.hash;
    var w = _witness();
    if (w && w.length > 1) {
      var controlBlock = w[w.length - 1];
      var leafVersion = controlBlock[0] & _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].TAPLEAF_VERSION_MASK;
      var script = w[w.length - 2];
      var leafHash = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tapleafHash)({
        output: script,
        version: leafVersion
      });
      return (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].rootHashFromPath)(controlBlock, leafHash);
    }
    return null;
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'output', function () {
    if (!o.pubkey) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_1__["default"].compile([OPS.OP_1, o.pubkey]);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'redeemVersion', function () {
    if (a.redeemVersion) return a.redeemVersion;
    if (a.redeem && a.redeem.redeemVersion !== undefined && a.redeem.redeemVersion !== null) {
      return a.redeem.redeemVersion;
    }
    return _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].LEAF_VERSION_TAPSCRIPT;
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'redeem', function () {
    var witness = _witness();
    if (!witness || witness.length < 2) return;
    return {
      output: witness[witness.length - 2],
      witness: witness.slice(0, -2),
      redeemVersion: witness[witness.length - 1][0] & _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].TAPLEAF_VERSION_MASK
    };
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'pubkey', function () {
    if (a.pubkey) return a.pubkey;
    if (a.output) return a.output.slice(2);
    if (a.address) return _address().data;
    if (o.internalPubkey) {
      var tweakedKey = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tweakKey)(o.internalPubkey, o.hash);
      if (tweakedKey) return tweakedKey.x;
    }
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'internalPubkey', function () {
    if (a.internalPubkey) return a.internalPubkey;
    var witness = _witness();
    if (witness && witness.length > 1) return witness[witness.length - 1].slice(1, 33);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'signature', function () {
    if (a.signature) return a.signature;
    var witness = _witness();
    if (!witness || witness.length !== 1) return;
    return witness[0];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_5__["default"].prop(o, 'witness', function () {
    if (a.witness) return a.witness;
    var hashTree = _hashTree();
    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {
      var leafHash = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      var path = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].findScriptPath)(hashTree, leafHash);
      if (!path) return;
      var outputKey = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tweakKey)(a.internalPubkey, hashTree.hash);
      if (!outputKey) return;
      var controlBock = Buffer.concat([Buffer.from([o.redeemVersion | outputKey.parity]), a.internalPubkey].concat(path));
      return [a.redeem.output, controlBock];
    }
    if (a.signature) return [a.signature];
  });
  if (opts.validate) {
    var pubkey = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== TAPROOT_WITNESS_VERSION) throw new TypeError('Invalid address version');
      if (_address().data.length !== 32) throw new TypeError('Invalid address data');
      pubkey = _address().data;
    }
    if (a.pubkey) {
      if (pubkey.length > 0 && !pubkey.equals(a.pubkey)) throw new TypeError('Pubkey mismatch');else pubkey = a.pubkey;
    }
    if (a.output) {
      if (a.output.length !== 34 || a.output[0] !== OPS.OP_1 || a.output[1] !== 0x20) throw new TypeError('Output is invalid');
      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2))) throw new TypeError('Pubkey mismatch');else pubkey = a.output.slice(2);
    }
    if (a.internalPubkey) {
      var tweakedKey = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tweakKey)(a.internalPubkey, o.hash);
      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x)) throw new TypeError('Pubkey mismatch');else pubkey = tweakedKey.x;
    }
    if (pubkey && pubkey.length) {
      if (!(0, _ecc_lib_js__WEBPACK_IMPORTED_MODULE_3__["default"].getEccLib)().isXOnlyPoint(pubkey)) throw new TypeError('Invalid pubkey for p2tr');
    }
    var hashTree = _hashTree();
    if (a.hash && hashTree) {
      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');
    }
    if (a.redeem && a.redeem.output && hashTree) {
      var leafHash = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tapleafHash)({
        output: a.redeem.output,
        version: o.redeemVersion
      });
      if (!(0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].findScriptPath)(hashTree, leafHash)) throw new TypeError('Redeem script not in tree');
    }
    var witness = _witness();
    if (a.redeem && o.redeem) {
      if (a.redeem.redeemVersion) {
        if (a.redeem.redeemVersion !== o.redeem.redeemVersion) throw new TypeError('Redeem.redeemVersion and witness mismatch');
      }
      if (a.redeem.output) {
        if (_script_js__WEBPACK_IMPORTED_MODULE_1__["default"].decompile(a.redeem.output).length === 0) throw new TypeError('Redeem.output is invalid');
        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output)) throw new TypeError('Redeem.output and witness mismatch');
      }
      if (a.redeem.witness) {
        if (o.redeem.witness && !(0, _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].stacksEqual)(a.redeem.witness, o.redeem.witness)) throw new TypeError('Redeem.witness and witness mismatch');
      }
    }
    if (witness && witness.length) {
      if (witness.length === 1) {
        if (a.signature && !a.signature.equals(witness[0])) throw new TypeError('Signature mismatch');
      } else {
        var controlBlock = witness[witness.length - 1];
        if (controlBlock.length < 33) throw new TypeError("The control-block length is too small. Got ".concat(controlBlock.length, ", expected min 33."));
        if ((controlBlock.length - 33) % 32 !== 0) throw new TypeError("The control-block length of ".concat(controlBlock.length, " is incorrect!"));
        var m = (controlBlock.length - 33) / 32;
        if (m > 128) throw new TypeError("The script path is too long. Got ".concat(m, ", expected max 128."));
        var internalPubkey = controlBlock.slice(1, 33);
        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey)) throw new TypeError('Internal pubkey mismatch');
        if (!(0, _ecc_lib_js__WEBPACK_IMPORTED_MODULE_3__["default"].getEccLib)().isXOnlyPoint(internalPubkey)) throw new TypeError('Invalid internalPubkey for p2tr witness');
        var leafVersion = controlBlock[0] & _types_js__WEBPACK_IMPORTED_MODULE_2__["default"].TAPLEAF_VERSION_MASK;
        var script = witness[witness.length - 2];
        var _leafHash = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tapleafHash)({
          output: script,
          version: leafVersion
        });
        var hash = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].rootHashFromPath)(controlBlock, _leafHash);
        var outputKey = (0, _bip341_js__WEBPACK_IMPORTED_MODULE_4__["default"].tweakKey)(internalPubkey, hash);
        if (!outputKey) throw new TypeError('Invalid outputKey for p2tr witness');
        if (pubkey.length && !pubkey.equals(outputKey.x)) throw new TypeError('Pubkey mismatch for p2tr witness');
        if (outputKey.parity !== (controlBlock[0] & 1)) throw new Error('Incorrect parity');
      }
    }
  }
  return Object.assign(o, a);
}
exports.p2tr = p2tr;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/payments/p2wpkh.js"
/*!**********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/payments/p2wpkh.js ***!
  \**********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _ecc_lib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ecc_lib.js */ "./src/analyze/crypto/bitcoin/v6/ecc_lib.js");
/* harmony import */ var _bip341_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bip341.js */ "./src/analyze/crypto/bitcoin/v6/payments/bip341.js");
/* harmony import */ var _lazy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lazy.js */ "./src/analyze/crypto/bitcoin/v6/payments/lazy.js");
/* harmony import */ var _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../v5/bech32@2.0.0.js */ "./src/analyze/crypto/bitcoin/v5/bech32@2.0.0.js");








var exports = {};
var OPS = _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].OPS;
var EMPTY_BUFFER = Buffer.alloc(0);
function p2wpkh(a, opts) {
  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness) throw new TypeError('Not enough data');
  opts = Object.assign({
    validate: true
  }, opts || {});
  (0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce)({
    address: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.String),
    hash: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.BufferN(20)),
    input: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.BufferN(0)),
    network: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.Object),
    output: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.BufferN(22)),
    pubkey: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPoint),
    signature: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isCanonicalScriptSignature),
    witness: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.maybe(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce.Buffer))
  }, a);
  var _address = _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].value(function () {
    var result = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_7__.bech32.decode(a.address);
    var version = result.words.shift();
    var data = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_7__.bech32.fromWords(result.words);
    return {
      version: version,
      prefix: result.prefix,
      data: Buffer.from(data)
    };
  });
  var network = a.network || _networks_js__WEBPACK_IMPORTED_MODULE_1__["default"].bitcoin;
  var o = {
    name: 'p2wpkh',
    network: network
  };
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'address', function () {
    if (!o.hash) return;
    var words = _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_7__.bech32.toWords(o.hash);
    words.unshift(0x00);
    return _v5_bech32_2_0_0_js__WEBPACK_IMPORTED_MODULE_7__.bech32.encode(network.bech32, words);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'hash', function () {
    if (a.output) return a.output.slice(2, 22);
    if (a.address) return _address().data;
    if (a.pubkey || o.pubkey) return _crypto_js__WEBPACK_IMPORTED_MODULE_0__["default"].hash160(a.pubkey || o.pubkey);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'output', function () {
    if (!o.hash) return;
    return _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].compile([OPS.OP_0, o.hash]);
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'pubkey', function () {
    if (a.pubkey) return a.pubkey;
    if (!a.witness) return;
    return a.witness[1];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'signature', function () {
    if (!a.witness) return;
    return a.witness[0];
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'input', function () {
    if (!o.witness) return;
    return EMPTY_BUFFER;
  });
  _lazy_js__WEBPACK_IMPORTED_MODULE_6__["default"].prop(o, 'witness', function () {
    if (!a.pubkey) return;
    if (!a.signature) return;
    return [a.signature, a.pubkey];
  });
  if (opts.validate) {
    var hash = Buffer.from([]);
    if (a.address) {
      if (network && network.bech32 !== _address().prefix) throw new TypeError('Invalid prefix or Network mismatch');
      if (_address().version !== 0x00) throw new TypeError('Invalid address version');
      if (_address().data.length !== 20) throw new TypeError('Invalid address data');
      hash = _address().data;
    }
    if (a.hash) {
      if (hash.length > 0 && !hash.equals(a.hash)) throw new TypeError('Hash mismatch');else hash = a.hash;
    }
    if (a.output) {
      if (a.output.length !== 22 || a.output[0] !== OPS.OP_0 || a.output[1] !== 0x14) throw new TypeError('Output is invalid');
      if (hash.length > 0 && !hash.equals(a.output.slice(2))) throw new TypeError('Hash mismatch');else hash = a.output.slice(2);
    }
    if (a.pubkey) {
      var pkh = _crypto_js__WEBPACK_IMPORTED_MODULE_0__["default"].hash160(a.pubkey);
      if (hash.length > 0 && !hash.equals(pkh)) throw new TypeError('Hash mismatch');else hash = pkh;
      if (!(0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPoint)(a.pubkey) || a.pubkey.length !== 33) throw new TypeError('Invalid pubkey for p2wpkh');
    }
    if (a.witness) {
      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');
      if (!_script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isCanonicalScriptSignature(a.witness[0])) throw new TypeError('Witness has invalid signature');
      if (!(0, _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].isPoint)(a.witness[1]) || a.witness[1].length !== 33) throw new TypeError('Witness has invalid pubkey');
      if (a.signature && !a.signature.equals(a.witness[0])) throw new TypeError('Signature mismatch');
      if (a.pubkey && !a.pubkey.equals(a.witness[1])) throw new TypeError('Pubkey mismatch');
      var _pkh = _crypto_js__WEBPACK_IMPORTED_MODULE_0__["default"].hash160(a.witness[1]);
      if (hash.length > 0 && !hash.equals(_pkh)) throw new TypeError('Hash mismatch');
    }
  }
  return Object.assign(o, a);
}
exports.p2wpkh = p2wpkh;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/psbt.js"
/*!***********************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/psbt.js ***!
  \***********************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v5_bip174_2_1_1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../v5/bip174@2.1.1.js */ "./src/analyze/crypto/bitcoin/v5/bip174@2.1.1.js");
/* harmony import */ var _address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./address.js */ "./src/analyze/crypto/bitcoin/v6/address.js");
/* harmony import */ var _bufferutils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bufferutils.js */ "./src/analyze/crypto/bitcoin/v6/bufferutils.js");
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _payments_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./payments/index.js */ "./src/analyze/crypto/bitcoin/v6/payments/index.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transaction.js */ "./src/analyze/crypto/bitcoin/v6/transaction.js");
/* harmony import */ var _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./psbt/bip371.js */ "./src/analyze/crypto/bitcoin/v6/psbt/bip371.js");
/* harmony import */ var _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./psbt/psbtutils.js */ "./src/analyze/crypto/bitcoin/v6/psbt/psbtutils.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regenerator() { var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }









var exports = {};
var utils_1 = {};
utils_1.checkForOutput = function checkForOutput(outputs, outputIndex) {
  var output = outputs[outputIndex];
  if (output === undefined) throw new Error("No output #".concat(outputIndex));
  return output;
};
utils_1.checkForInput = function checkForInput(inputs, inputIndex) {
  var input = inputs[inputIndex];
  if (input === undefined) throw new Error("No input #".concat(inputIndex));
  return input;
};
var varuint = {};
var MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');
}
varuint.encode = function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, {
      bytes: 1
    });
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, {
      bytes: 3
    });
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, {
      bytes: 5
    });
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE(_number / 0x100000000 | 0, offset + 5);
    Object.assign(encode, {
      bytes: 9
    });
  }
  return buffer;
};
varuint.decode = function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  var first = buffer.readUInt8(offset);
  if (first < 0xfd) {
    Object.assign(decode, {
      bytes: 1
    });
    return first;
  } else if (first === 0xfd) {
    Object.assign(decode, {
      bytes: 3
    });
    return buffer.readUInt16LE(offset + 1);
  } else if (first === 0xfe) {
    Object.assign(decode, {
      bytes: 5
    });
    return buffer.readUInt32LE(offset + 1);
  } else {
    Object.assign(decode, {
      bytes: 9
    });
    var lo = buffer.readUInt32LE(offset + 1);
    var hi = buffer.readUInt32LE(offset + 5);
    var _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
};
varuint.encodingLength = function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd ? 1 : _number <= 0xffff ? 3 : _number <= 0xffffffff ? 5 : 9;
};
var DEFAULT_OPTS = {
  network: _networks_js__WEBPACK_IMPORTED_MODULE_3__["default"].bitcoin,
  maximumFeeRate: 5000
};
var Psbt = function () {
  function Psbt() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _v5_bip174_2_1_1_js__WEBPACK_IMPORTED_MODULE_0__["default"].Psbt(new PsbtTransaction());
    _classCallCheck(this, Psbt);
    this.data = data;
    this.opts = Object.assign({}, DEFAULT_OPTS, opts);
    this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      __UNSAFE_SIGN_NONSEGWIT: false
    };
    if (this.data.inputs.length === 0) this.setVersion(2);
    var dpew = function dpew(obj, attr, enumerable, writable) {
      return Object.defineProperty(obj, attr, {
        enumerable: enumerable,
        writable: writable
      });
    };
    dpew(this, '__CACHE', false, true);
    dpew(this, 'opts', false, true);
  }
  return _createClass(Psbt, [{
    key: "inputCount",
    get: function get() {
      return this.data.inputs.length;
    }
  }, {
    key: "version",
    get: function get() {
      return this.__CACHE.__TX.version;
    },
    set: function set(version) {
      this.setVersion(version);
    }
  }, {
    key: "locktime",
    get: function get() {
      return this.__CACHE.__TX.locktime;
    },
    set: function set(locktime) {
      this.setLocktime(locktime);
    }
  }, {
    key: "txInputs",
    get: function get() {
      return this.__CACHE.__TX.ins.map(function (input) {
        return {
          hash: (0, _bufferutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        };
      });
    }
  }, {
    key: "txOutputs",
    get: function get() {
      var _this = this;
      return this.__CACHE.__TX.outs.map(function (output) {
        var address;
        try {
          address = (0, _address_js__WEBPACK_IMPORTED_MODULE_1__["default"].fromOutputScript)(output.script, _this.opts.network);
        } catch (_) {}
        return {
          script: (0, _bufferutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].cloneBuffer)(output.script),
          value: output.value,
          address: address
        };
      });
    }
  }, {
    key: "combine",
    value: function combine() {
      var _this$data;
      for (var _len = arguments.length, those = new Array(_len), _key = 0; _key < _len; _key++) {
        those[_key] = arguments[_key];
      }
      (_this$data = this.data).combine.apply(_this$data, _toConsumableArray(those.map(function (o) {
        return o.data;
      })));
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var res = Psbt.fromBuffer(this.data.toBuffer());
      res.opts = JSON.parse(JSON.stringify(this.opts));
      return res;
    }
  }, {
    key: "setMaximumFeeRate",
    value: function setMaximumFeeRate(satoshiPerByte) {
      check32Bit(satoshiPerByte);
      this.opts.maximumFeeRate = satoshiPerByte;
    }
  }, {
    key: "setVersion",
    value: function setVersion(version) {
      check32Bit(version);
      checkInputsForPartialSig(this.data.inputs, 'setVersion');
      var c = this.__CACHE;
      c.__TX.version = version;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "setLocktime",
    value: function setLocktime(locktime) {
      check32Bit(locktime);
      checkInputsForPartialSig(this.data.inputs, 'setLocktime');
      var c = this.__CACHE;
      c.__TX.locktime = locktime;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "setInputSequence",
    value: function setInputSequence(inputIndex, sequence) {
      check32Bit(sequence);
      checkInputsForPartialSig(this.data.inputs, 'setInputSequence');
      var c = this.__CACHE;
      if (c.__TX.ins.length <= inputIndex) {
        throw new Error('Input index too high');
      }
      c.__TX.ins[inputIndex].sequence = sequence;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "addInputs",
    value: function addInputs(inputDatas) {
      var _this2 = this;
      inputDatas.forEach(function (inputData) {
        return _this2.addInput(inputData);
      });
      return this;
    }
  }, {
    key: "addInput",
    value: function addInput(inputData) {
      if (arguments.length > 1 || !inputData || inputData.hash === undefined || inputData.index === undefined) {
        throw new Error("Invalid arguments for Psbt.addInput. " + "Requires single object with at least [hash] and [index]");
      }
      (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkTaprootInputFields)(inputData, inputData, 'addInput');
      checkInputsForPartialSig(this.data.inputs, 'addInput');
      if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
      var c = this.__CACHE;
      this.data.addInput(inputData);
      var txIn = c.__TX.ins[c.__TX.ins.length - 1];
      checkTxInputCache(c, txIn);
      var inputIndex = this.data.inputs.length - 1;
      var input = this.data.inputs[inputIndex];
      if (input.nonWitnessUtxo) {
        addNonWitnessTxCache(this.__CACHE, input, inputIndex);
      }
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "addOutputs",
    value: function addOutputs(outputDatas) {
      var _this3 = this;
      outputDatas.forEach(function (outputData) {
        return _this3.addOutput(outputData);
      });
      return this;
    }
  }, {
    key: "addOutput",
    value: function addOutput(outputData) {
      if (arguments.length > 1 || !outputData || outputData.value === undefined || outputData.address === undefined && outputData.script === undefined) {
        throw new Error("Invalid arguments for Psbt.addOutput. " + "Requires single object with at least [script or address] and [value]");
      }
      checkInputsForPartialSig(this.data.inputs, 'addOutput');
      var _outputData = outputData,
        address = _outputData.address;
      if (typeof address === 'string') {
        var network = this.opts.network;
        var script = (0, _address_js__WEBPACK_IMPORTED_MODULE_1__["default"].toOutputScript)(address, network);
        outputData = Object.assign({}, outputData, {
          script: script
        });
      }
      (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkTaprootOutputFields)(outputData, outputData, 'addOutput');
      var c = this.__CACHE;
      this.data.addOutput(outputData);
      c.__FEE = undefined;
      c.__FEE_RATE = undefined;
      c.__EXTRACTED_TX = undefined;
      return this;
    }
  }, {
    key: "extractTransaction",
    value: function extractTransaction(disableFeeCheck) {
      if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');
      var c = this.__CACHE;
      if (!disableFeeCheck) {
        checkFees(this, c, this.opts);
      }
      if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;
      var tx = c.__TX.clone();
      inputFinalizeGetAmts(this.data.inputs, tx, c, true);
      return tx;
    }
  }, {
    key: "getFeeRate",
    value: function getFeeRate() {
      return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);
    }
  }, {
    key: "getFee",
    value: function getFee() {
      return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);
    }
  }, {
    key: "finalizeAllInputs",
    value: function finalizeAllInputs() {
      var _this4 = this;
      (0, utils_1.checkForInput)(this.data.inputs, 0);
      range(this.data.inputs.length).forEach(function (idx) {
        return _this4.finalizeInput(idx);
      });
      return this;
    }
  }, {
    key: "finalizeInput",
    value: function finalizeInput(inputIndex, finalScriptsFunc) {
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, undefined, finalScriptsFunc);
      return this._finalizeInput(inputIndex, input, finalScriptsFunc);
    }
  }, {
    key: "finalizeTaprootInput",
    value: function finalizeTaprootInput(inputIndex, tapLeafHashToFinalize) {
      var finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].tapScriptFinalizer;
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return this._finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc);
      throw new Error("Cannot finalize input #".concat(inputIndex, ". Not Taproot."));
    }
  }, {
    key: "_finalizeInput",
    value: function _finalizeInput(inputIndex, input) {
      var finalScriptsFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getFinalScripts;
      var _getScriptFromInput = getScriptFromInput(inputIndex, input, this.__CACHE),
        script = _getScriptFromInput.script,
        isP2SH = _getScriptFromInput.isP2SH,
        isP2WSH = _getScriptFromInput.isP2WSH,
        isSegwit = _getScriptFromInput.isSegwit;
      if (!script) throw new Error("No script found for input #".concat(inputIndex));
      checkPartialSigSighashes(input);
      var _finalScriptsFunc = finalScriptsFunc(inputIndex, input, script, isSegwit, isP2SH, isP2WSH),
        finalScriptSig = _finalScriptsFunc.finalScriptSig,
        finalScriptWitness = _finalScriptsFunc.finalScriptWitness;
      if (finalScriptSig) this.data.updateInput(inputIndex, {
        finalScriptSig: finalScriptSig
      });
      if (finalScriptWitness) this.data.updateInput(inputIndex, {
        finalScriptWitness: finalScriptWitness
      });
      if (!finalScriptSig && !finalScriptWitness) throw new Error("Unknown error finalizing input #".concat(inputIndex));
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }, {
    key: "_finalizeTaprootInput",
    value: function _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize) {
      var finalScriptsFunc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].tapScriptFinalizer;
      if (!input.witnessUtxo) throw new Error("Cannot finalize input #".concat(inputIndex, ". Missing withness utxo."));
      if (input.tapKeySig) {
        var payment = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2tr({
          output: input.witnessUtxo.script,
          signature: input.tapKeySig
        });
        var finalScriptWitness = (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].witnessStackToScriptWitness)(payment.witness);
        this.data.updateInput(inputIndex, {
          finalScriptWitness: finalScriptWitness
        });
      } else {
        var _finalScriptsFunc2 = finalScriptsFunc(inputIndex, input, tapLeafHashToFinalize),
          _finalScriptWitness = _finalScriptsFunc2.finalScriptWitness;
        this.data.updateInput(inputIndex, {
          finalScriptWitness: _finalScriptWitness
        });
      }
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }, {
    key: "getInputType",
    value: function getInputType(inputIndex) {
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      var script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
      var result = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig), input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness));
      var type = result.type === 'raw' ? '' : result.type + '-';
      var mainType = classifyScript(result.meaningfulScript);
      return type + mainType;
    }
  }, {
    key: "inputHasPubkey",
    value: function inputHasPubkey(inputIndex, pubkey) {
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
    }
  }, {
    key: "inputHasHDKey",
    value: function inputHasHDKey(inputIndex, root) {
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      var derivationIsMine = bip32DerivationIsMine(root);
      return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
    }
  }, {
    key: "outputHasPubkey",
    value: function outputHasPubkey(outputIndex, pubkey) {
      var output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
      return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
    }
  }, {
    key: "outputHasHDKey",
    value: function outputHasHDKey(outputIndex, root) {
      var output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
      var derivationIsMine = bip32DerivationIsMine(root);
      return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
    }
  }, {
    key: "validateSignaturesOfAllInputs",
    value: function validateSignaturesOfAllInputs(validator) {
      var _this5 = this;
      (0, utils_1.checkForInput)(this.data.inputs, 0);
      var results = range(this.data.inputs.length).map(function (idx) {
        return _this5.validateSignaturesOfInput(idx, validator);
      });
      return results.reduce(function (_final, res) {
        return res === true && _final;
      }, true);
    }
  }, {
    key: "validateSignaturesOfInput",
    value: function validateSignaturesOfInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return this.validateSignaturesOfTaprootInput(inputIndex, validator, pubkey);
      return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
    }
  }, {
    key: "_validateSignaturesOfInput",
    value: function _validateSignaturesOfInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      var partialSig = (input || {}).partialSig;
      if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');
      if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');
      var mySigs = pubkey ? partialSig.filter(function (sig) {
        return sig.pubkey.equals(pubkey);
      }) : partialSig;
      if (mySigs.length < 1) throw new Error('No signatures for this pubkey');
      var results = [];
      var hashCache;
      var scriptCache;
      var sighashCache;
      var _iterator = _createForOfIteratorHelper(mySigs),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var pSig = _step.value;
          var sig = _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].signature.decode(pSig.signature);
          var _ref = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {
              sighashType: sig.hashType
            }), this.__CACHE, true) : {
              hash: hashCache,
              script: scriptCache
            },
            hash = _ref.hash,
            script = _ref.script;
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, 'verify');
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return results.every(function (res) {
        return res === true;
      });
    }
  }, {
    key: "validateSignaturesOfTaprootInput",
    value: function validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
      var input = this.data.inputs[inputIndex];
      var tapKeySig = (input || {}).tapKeySig;
      var tapScriptSig = (input || {}).tapScriptSig;
      if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length)) throw new Error('No signatures to validate');
      if (typeof validator !== 'function') throw new Error('Need validator function to validate signatures');
      pubkey = pubkey && (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].toXOnly)(pubkey);
      var allHashses = pubkey ? getTaprootHashesForSig(inputIndex, input, this.data.inputs, pubkey, this.__CACHE) : getAllTaprootHashesForSig(inputIndex, input, this.data.inputs, this.__CACHE);
      if (!allHashses.length) throw new Error('No signatures for this pubkey');
      var tapKeyHash = allHashses.find(function (h) {
        return !h.leafHash;
      });
      var validationResultCount = 0;
      if (tapKeySig && tapKeyHash) {
        var isValidTapkeySig = validator(tapKeyHash.pubkey, tapKeyHash.hash, trimTaprootSig(tapKeySig));
        if (!isValidTapkeySig) return false;
        validationResultCount++;
      }
      if (tapScriptSig) {
        var _iterator2 = _createForOfIteratorHelper(tapScriptSig),
          _step2;
        try {
          var _loop = function _loop() {
              var tapSig = _step2.value;
              var tapSigHash = allHashses.find(function (h) {
                return tapSig.pubkey.equals(h.pubkey);
              });
              if (tapSigHash) {
                var isValidTapScriptSig = validator(tapSig.pubkey, tapSigHash.hash, trimTaprootSig(tapSig.signature));
                if (!isValidTapScriptSig) return {
                  v: false
                };
                validationResultCount++;
              }
            },
            _ret;
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _ret = _loop();
            if (_ret) return _ret.v;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return validationResultCount > 0;
    }
  }, {
    key: "signAllInputsHD",
    value: function signAllInputsHD(hdKeyPair) {
      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      var results = [];
      var _iterator3 = _createForOfIteratorHelper(range(this.data.inputs.length)),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var i = _step3.value;
          try {
            this.signInputHD(i, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      if (results.every(function (v) {
        return v === false;
      })) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
  }, {
    key: "signAllInputsHDAsync",
    value: function signAllInputsHDAsync(hdKeyPair) {
      var _this6 = this;
      var sighashTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      return new Promise(function (resolve, reject) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        var results = [];
        var promises = [];
        var _iterator4 = _createForOfIteratorHelper(range(_this6.data.inputs.length)),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var i = _step4.value;
            promises.push(_this6.signInputHDAsync(i, hdKeyPair, sighashTypes).then(function () {
              results.push(true);
            }, function () {
              results.push(false);
            }));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return Promise.all(promises).then(function () {
          if (results.every(function (v) {
            return v === false;
          })) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
  }, {
    key: "signInputHD",
    value: function signInputHD(inputIndex, hdKeyPair) {
      var _this7 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
        throw new Error('Need HDSigner to sign input');
      }
      var signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
      signers.forEach(function (signer) {
        return _this7.signInput(inputIndex, signer, sighashTypes);
      });
      return this;
    }
  }, {
    key: "signInputHDAsync",
    value: function signInputHDAsync(inputIndex, hdKeyPair) {
      var _this8 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      return new Promise(function (resolve, reject) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          return reject(new Error('Need HDSigner to sign input'));
        }
        var signers = getSignersFromHD(inputIndex, _this8.data.inputs, hdKeyPair);
        var promises = signers.map(function (signer) {
          return _this8.signInputAsync(inputIndex, signer, sighashTypes);
        });
        return Promise.all(promises).then(function () {
          resolve();
        })["catch"](reject);
      });
    }
  }, {
    key: "signAllInputs",
    value: function signAllInputs(keyPair, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      var results = [];
      var _iterator5 = _createForOfIteratorHelper(range(this.data.inputs.length)),
        _step5;
      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var i = _step5.value;
          try {
            this.signInput(i, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
      if (results.every(function (v) {
        return v === false;
      })) {
        throw new Error('No inputs were signed');
      }
      return this;
    }
  }, {
    key: "signAllInputsAsync",
    value: function signAllInputsAsync(keyPair, sighashTypes) {
      var _this9 = this;
      return new Promise(function (resolve, reject) {
        if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input'));
        var results = [];
        var promises = [];
        var _iterator6 = _createForOfIteratorHelper(_this9.data.inputs.entries()),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 1),
              i = _step6$value[0];
            promises.push(_this9.signInputAsync(i, keyPair, sighashTypes).then(function () {
              results.push(true);
            }, function () {
              results.push(false);
            }));
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return Promise.all(promises).then(function () {
          if (results.every(function (v) {
            return v === false;
          })) {
            return reject(new Error('No inputs were signed'));
          }
          resolve();
        });
      });
    }
  }, {
    key: "signInput",
    value: function signInput(inputIndex, keyPair, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) {
        return this._signTaprootInput(inputIndex, input, keyPair, undefined, sighashTypes);
      }
      return this._signInput(inputIndex, keyPair, sighashTypes);
    }
  }, {
    key: "signTaprootInput",
    value: function signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
      if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
      var input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
      if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return this._signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, sighashTypes);
      throw new Error("Input #".concat(inputIndex, " is not of type Taproot."));
    }
  }, {
    key: "_signInput",
    value: function _signInput(inputIndex, keyPair) {
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      var _getHashAndSighashTyp = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),
        hash = _getHashAndSighashTyp.hash,
        sighashType = _getHashAndSighashTyp.sighashType;
      var partialSig = [{
        pubkey: keyPair.publicKey,
        signature: _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].signature.encode(keyPair.sign(hash), sighashType)
      }];
      this.data.updateInput(inputIndex, {
        partialSig: partialSig
      });
      return this;
    }
  }, {
    key: "_signTaprootInput",
    value: function _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign) {
      var allowedSighashTypes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_DEFAULT];
      var hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes);
      var tapKeySig = hashesForSig.filter(function (h) {
        return !h.leafHash;
      }).map(function (h) {
        return (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType);
      })[0];
      var tapScriptSig = hashesForSig.filter(function (h) {
        return !!h.leafHash;
      }).map(function (h) {
        return {
          pubkey: (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].toXOnly)(keyPair.publicKey),
          signature: (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].serializeTaprootSignature)(keyPair.signSchnorr(h.hash), input.sighashType),
          leafHash: h.leafHash
        };
      });
      if (tapKeySig) {
        this.data.updateInput(inputIndex, {
          tapKeySig: tapKeySig
        });
      }
      if (tapScriptSig.length) {
        this.data.updateInput(inputIndex, {
          tapScriptSig: tapScriptSig
        });
      }
      return this;
    }
  }, {
    key: "signInputAsync",
    value: function signInputAsync(inputIndex, keyPair, sighashTypes) {
      var _this0 = this;
      return Promise.resolve().then(function () {
        if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
        var input = (0, utils_1.checkForInput)(_this0.data.inputs, inputIndex);
        if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return _this0._signTaprootInputAsync(inputIndex, input, keyPair, undefined, sighashTypes);
        return _this0._signInputAsync(inputIndex, keyPair, sighashTypes);
      });
    }
  }, {
    key: "signTaprootInputAsync",
    value: function signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
      var _this1 = this;
      return Promise.resolve().then(function () {
        if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');
        var input = (0, utils_1.checkForInput)(_this1.data.inputs, inputIndex);
        if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input)) return _this1._signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
        throw new Error("Input #".concat(inputIndex, " is not of type Taproot."));
      });
    }
  }, {
    key: "_signInputAsync",
    value: function _signInputAsync(inputIndex, keyPair) {
      var _this10 = this;
      var sighashTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL];
      var _getHashAndSighashTyp2 = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),
        hash = _getHashAndSighashTyp2.hash,
        sighashType = _getHashAndSighashTyp2.sighashType;
      return Promise.resolve(keyPair.sign(hash)).then(function (signature) {
        var partialSig = [{
          pubkey: keyPair.publicKey,
          signature: _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].signature.encode(signature, sighashType)
        }];
        _this10.data.updateInput(inputIndex, {
          partialSig: partialSig
        });
      });
    }
  }, {
    key: "_signTaprootInputAsync",
    value: function () {
      var _signTaprootInputAsync2 = _asyncToGenerator(_regenerator().m(function _callee(inputIndex, input, keyPair, tapLeafHash) {
        var _this11 = this;
        var sighashTypes,
          hashesForSig,
          signaturePromises,
          tapKeyHash,
          tapKeySigPromise,
          tapScriptHashes,
          tapScriptSigPromises,
          _args = arguments;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              sighashTypes = _args.length > 4 && _args[4] !== undefined ? _args[4] : [_transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_DEFAULT];
              hashesForSig = this.checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHash, sighashTypes);
              signaturePromises = [];
              tapKeyHash = hashesForSig.filter(function (h) {
                return !h.leafHash;
              })[0];
              if (tapKeyHash) {
                tapKeySigPromise = Promise.resolve(keyPair.signSchnorr(tapKeyHash.hash)).then(function (sig) {
                  return {
                    tapKeySig: (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].serializeTaprootSignature)(sig, input.sighashType)
                  };
                });
                signaturePromises.push(tapKeySigPromise);
              }
              tapScriptHashes = hashesForSig.filter(function (h) {
                return !!h.leafHash;
              });
              if (tapScriptHashes.length) {
                tapScriptSigPromises = tapScriptHashes.map(function (tsh) {
                  return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(function (signature) {
                    var tapScriptSig = [{
                      pubkey: (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].toXOnly)(keyPair.publicKey),
                      signature: (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].serializeTaprootSignature)(signature, input.sighashType),
                      leafHash: tsh.leafHash
                    }];
                    return {
                      tapScriptSig: tapScriptSig
                    };
                  });
                });
                signaturePromises.push.apply(signaturePromises, _toConsumableArray(tapScriptSigPromises));
              }
              return _context.a(2, Promise.all(signaturePromises).then(function (results) {
                results.forEach(function (v) {
                  return _this11.data.updateInput(inputIndex, v);
                });
              }));
          }
        }, _callee, this);
      }));
      function _signTaprootInputAsync(_x, _x2, _x3, _x4) {
        return _signTaprootInputAsync2.apply(this, arguments);
      }
      return _signTaprootInputAsync;
    }()
  }, {
    key: "checkTaprootHashesForSig",
    value: function checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
      if (typeof keyPair.signSchnorr !== 'function') throw new Error("Need Schnorr Signer to sign taproot input #".concat(inputIndex, "."));
      var hashesForSig = getTaprootHashesForSig(inputIndex, input, this.data.inputs, keyPair.publicKey, this.__CACHE, tapLeafHashToSign, allowedSighashTypes);
      if (!hashesForSig || !hashesForSig.length) throw new Error("Can not sign for input #".concat(inputIndex, " with the key ").concat(keyPair.publicKey.toString('hex')));
      return hashesForSig;
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      checkCache(this.__CACHE);
      return this.data.toBuffer();
    }
  }, {
    key: "toHex",
    value: function toHex() {
      checkCache(this.__CACHE);
      return this.data.toHex();
    }
  }, {
    key: "toBase64",
    value: function toBase64() {
      checkCache(this.__CACHE);
      return this.data.toBase64();
    }
  }, {
    key: "updateGlobal",
    value: function updateGlobal(updateData) {
      this.data.updateGlobal(updateData);
      return this;
    }
  }, {
    key: "updateInput",
    value: function updateInput(inputIndex, updateData) {
      if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
      (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkTaprootInputFields)(this.data.inputs[inputIndex], updateData, 'updateInput');
      this.data.updateInput(inputIndex, updateData);
      if (updateData.nonWitnessUtxo) {
        addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);
      }
      return this;
    }
  }, {
    key: "updateOutput",
    value: function updateOutput(outputIndex, updateData) {
      var outputData = this.data.outputs[outputIndex];
      (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkTaprootOutputFields)(outputData, updateData, 'updateOutput');
      this.data.updateOutput(outputIndex, updateData);
      return this;
    }
  }, {
    key: "addUnknownKeyValToGlobal",
    value: function addUnknownKeyValToGlobal(keyVal) {
      this.data.addUnknownKeyValToGlobal(keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToInput",
    value: function addUnknownKeyValToInput(inputIndex, keyVal) {
      this.data.addUnknownKeyValToInput(inputIndex, keyVal);
      return this;
    }
  }, {
    key: "addUnknownKeyValToOutput",
    value: function addUnknownKeyValToOutput(outputIndex, keyVal) {
      this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
      return this;
    }
  }, {
    key: "clearFinalizedInput",
    value: function clearFinalizedInput(inputIndex) {
      this.data.clearFinalizedInput(inputIndex);
      return this;
    }
  }], [{
    key: "fromBase64",
    value: function fromBase64(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var buffer = Buffer.from(data, 'base64');
      return this.fromBuffer(buffer, opts);
    }
  }, {
    key: "fromHex",
    value: function fromHex(data) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var buffer = Buffer.from(data, 'hex');
      return this.fromBuffer(buffer, opts);
    }
  }, {
    key: "fromBuffer",
    value: function fromBuffer(buffer) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var psbtBase = _v5_bip174_2_1_1_js__WEBPACK_IMPORTED_MODULE_0__["default"].Psbt.fromBuffer(buffer, transactionFromBuffer);
      var psbt = new Psbt(opts, psbtBase);
      checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
      return psbt;
    }
  }]);
}();
exports.Psbt = Psbt;
var transactionFromBuffer = function transactionFromBuffer(buffer) {
  return new PsbtTransaction(buffer);
};
var PsbtTransaction = function () {
  function PsbtTransaction() {
    var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    _classCallCheck(this, PsbtTransaction);
    this.tx = _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.fromBuffer(buffer);
    checkTxEmpty(this.tx);
    Object.defineProperty(this, 'tx', {
      enumerable: false,
      writable: true
    });
  }
  return _createClass(PsbtTransaction, [{
    key: "getInputOutputCounts",
    value: function getInputOutputCounts() {
      return {
        inputCount: this.tx.ins.length,
        outputCount: this.tx.outs.length
      };
    }
  }, {
    key: "addInput",
    value: function addInput(input) {
      if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {
        throw new Error('Error adding input.');
      }
      var hash = typeof input.hash === 'string' ? (0, _bufferutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].reverseBuffer)(Buffer.from(input.hash, 'hex')) : input.hash;
      this.tx.addInput(hash, input.index, input.sequence);
    }
  }, {
    key: "addOutput",
    value: function addOutput(output) {
      if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {
        throw new Error('Error adding output.');
      }
      this.tx.addOutput(output.script, output.value);
    }
  }, {
    key: "toBuffer",
    value: function toBuffer() {
      return this.tx.toBuffer();
    }
  }]);
}();
function canFinalize(input, script, scriptType) {
  switch (scriptType) {
    case 'pubkey':
    case 'pubkeyhash':
    case 'witnesspubkeyhash':
      return hasSigs(1, input.partialSig);
    case 'multisig':
      var p2ms = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2ms({
        output: script
      });
      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
    default:
      return false;
  }
}
function checkCache(cache) {
  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
    throw new Error('Not BIP174 compliant, can not export');
  }
}
function hasSigs(neededSigs, partialSig, pubkeys) {
  if (!partialSig) return false;
  var sigs;
  if (pubkeys) {
    sigs = pubkeys.map(function (pkey) {
      var pubkey = compressPubkey(pkey);
      return partialSig.find(function (pSig) {
        return pSig.pubkey.equals(pubkey);
      });
    }).filter(function (v) {
      return !!v;
    });
  } else {
    sigs = partialSig;
  }
  if (sigs.length > neededSigs) throw new Error('Too many signatures');
  return sigs.length === neededSigs;
}
function isFinalized(input) {
  return !!input.finalScriptSig || !!input.finalScriptWitness;
}
function bip32DerivationIsMine(root) {
  return function (d) {
    if (!d.masterFingerprint.equals(root.fingerprint)) return false;
    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;
    return true;
  };
}
function check32Bit(num) {
  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {
    throw new Error('Invalid 32 bit integer');
  }
}
function checkFees(psbt, cache, opts) {
  var feeRate = cache.__FEE_RATE || psbt.getFeeRate();
  var vsize = cache.__EXTRACTED_TX.virtualSize();
  var satoshis = feeRate * vsize;
  if (feeRate >= opts.maximumFeeRate) {
    throw new Error("Warning: You are paying around ".concat((satoshis / 1e8).toFixed(8), " in ") + "fees, which is ".concat(feeRate, " satoshi per byte for a transaction ") + "with a VSize of ".concat(vsize, " bytes (segwit counted as 0.25 byte per ") + "byte). Use setMaximumFeeRate method to raise your threshold, or " + "pass true to the first arg of extractTransaction.");
  }
}
function checkInputsForPartialSig(inputs, action) {
  inputs.forEach(function (input) {
    var _throws = (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].isTaprootInput)(input) ? (0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].checkTaprootInputForSigs)(input, action) : (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].checkInputForSig)(input, action);
    if (_throws) throw new Error('Can not modify transaction, signatures exist.');
  });
}
function checkPartialSigSighashes(input) {
  if (!input.sighashType || !input.partialSig) return;
  var partialSig = input.partialSig,
    sighashType = input.sighashType;
  partialSig.forEach(function (pSig) {
    var _bscript$signature$de = _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].signature.decode(pSig.signature),
      hashType = _bscript$signature$de.hashType;
    if (sighashType !== hashType) {
      throw new Error('Signature sighash does not match input sighash type');
    }
  });
}
function checkScriptForPubkey(pubkey, script, action) {
  if (!(0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].pubkeyInScript)(pubkey, script)) {
    throw new Error("Can not ".concat(action, " for this input with the key ").concat(pubkey.toString('hex')));
  }
}
function checkTxEmpty(tx) {
  var isEmpty = tx.ins.every(function (input) {
    return input.script && input.script.length === 0 && input.witness && input.witness.length === 0;
  });
  if (!isEmpty) {
    throw new Error('Format Error: Transaction ScriptSigs are not empty');
  }
}
function checkTxForDupeIns(tx, cache) {
  tx.ins.forEach(function (input) {
    checkTxInputCache(cache, input);
  });
}
function checkTxInputCache(cache, input) {
  var key = (0, _bufferutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].reverseBuffer)(Buffer.from(input.hash)).toString('hex') + ':' + input.index;
  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');
  cache.__TX_IN_CACHE[key] = 1;
}
function scriptCheckerFactory(payment, paymentScriptName) {
  return function (inputIndex, scriptPubKey, redeemScript, ioType) {
    var redeemScriptOutput = payment({
      redeem: {
        output: redeemScript
      }
    }).output;
    if (!scriptPubKey.equals(redeemScriptOutput)) {
      throw new Error("".concat(paymentScriptName, " for ").concat(ioType, " #").concat(inputIndex, " doesn't match the scriptPubKey in the prevout"));
    }
  };
}
var checkRedeemScript = scriptCheckerFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2sh, 'Redeem script');
var checkWitnessScript = scriptCheckerFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2wsh, 'Witness script');
function getTxCacheValue(key, name, inputs, c) {
  if (!inputs.every(isFinalized)) throw new Error("PSBT must be finalized to calculate ".concat(name));
  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;
  if (key === '__FEE' && c.__FEE) return c.__FEE;
  var tx;
  var mustFinalize = true;
  if (c.__EXTRACTED_TX) {
    tx = c.__EXTRACTED_TX;
    mustFinalize = false;
  } else {
    tx = c.__TX.clone();
  }
  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);
  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;
}
function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
  var scriptType = classifyScript(script);
  if (!canFinalize(input, script, scriptType)) throw new Error("Can not finalize input #".concat(inputIndex));
  return prepareFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH);
}
function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
  var finalScriptSig;
  var finalScriptWitness;
  var payment = getPayment(script, scriptType, partialSig);
  var p2wsh = !isP2WSH ? null : _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2wsh({
    redeem: payment
  });
  var p2sh = !isP2SH ? null : _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2sh({
    redeem: p2wsh || payment
  });
  if (isSegwit) {
    if (p2wsh) {
      finalScriptWitness = (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].witnessStackToScriptWitness)(p2wsh.witness);
    } else {
      finalScriptWitness = (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].witnessStackToScriptWitness)(payment.witness);
    }
    if (p2sh) {
      finalScriptSig = p2sh.input;
    }
  } else {
    if (p2sh) {
      finalScriptSig = p2sh.input;
    } else {
      finalScriptSig = payment.input;
    }
  }
  return {
    finalScriptSig: finalScriptSig,
    finalScriptWitness: finalScriptWitness
  };
}
function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
  var input = (0, utils_1.checkForInput)(inputs, inputIndex);
  var _getHashForSig = getHashForSig(inputIndex, input, cache, false, sighashTypes),
    hash = _getHashForSig.hash,
    sighashType = _getHashForSig.sighashType,
    script = _getHashForSig.script;
  checkScriptForPubkey(pubkey, script, 'sign');
  return {
    hash: hash,
    sighashType: sighashType
  };
}
function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
  var unsignedTx = cache.__TX;
  var sighashType = input.sighashType || _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(sighashType, sighashTypes);
  var hash;
  var prevout;
  if (input.nonWitnessUtxo) {
    var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    var prevoutHash = unsignedTx.ins[inputIndex].hash;
    var utxoHash = nonWitnessUtxoTx.getHash();
    if (!prevoutHash.equals(utxoHash)) {
      throw new Error("Non-witness UTXO hash for input #".concat(inputIndex, " doesn't match the hash specified in the prevout"));
    }
    var prevoutIndex = unsignedTx.ins[inputIndex].index;
    prevout = nonWitnessUtxoTx.outs[prevoutIndex];
  } else if (input.witnessUtxo) {
    prevout = input.witnessUtxo;
  } else {
    throw new Error('Need a Utxo input item for signing');
  }
  var _getMeaningfulScript = getMeaningfulScript(prevout.script, inputIndex, 'input', input.redeemScript, input.witnessScript),
    meaningfulScript = _getMeaningfulScript.meaningfulScript,
    type = _getMeaningfulScript.type;
  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {
    hash = unsignedTx.hashForWitnessV0(inputIndex, meaningfulScript, prevout.value, sighashType);
  } else if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WPKH)(meaningfulScript)) {
    var signingScript = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2pkh({
      hash: meaningfulScript.slice(2)
    }).output;
    hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);
  } else {
    if (input.nonWitnessUtxo === undefined && cache.__UNSAFE_SIGN_NONSEGWIT === false) throw new Error("Input #".concat(inputIndex, " has witnessUtxo but non-segwit script: ") + "".concat(meaningfulScript.toString('hex')));
    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false) console.warn('Warning: Signing non-segwit inputs without the full parent transaction ' + 'means there is a chance that a miner could feed you incorrect information ' + "to trick you into paying large fees. This behavior is the same as Psbt's predecessor " + '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' + 'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' + 'BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n' + '*********************');
    hash = unsignedTx.hashForSignature(inputIndex, meaningfulScript, sighashType);
  }
  return {
    script: meaningfulScript,
    sighashType: sighashType,
    hash: hash
  };
}
function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
  var allPublicKeys = [];
  if (input.tapInternalKey) {
    var key = getPrevoutTaprootKey(inputIndex, input, cache);
    if (key) {
      allPublicKeys.push(key);
    }
  }
  if (input.tapScriptSig) {
    var tapScriptPubkeys = input.tapScriptSig.map(function (tss) {
      return tss.pubkey;
    });
    allPublicKeys.push.apply(allPublicKeys, _toConsumableArray(tapScriptPubkeys));
  }
  var allHashes = allPublicKeys.map(function (pubicKey) {
    return getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache);
  });
  return allHashes.flat();
}
function getPrevoutTaprootKey(inputIndex, input, cache) {
  var _getScriptAndAmountFr = getScriptAndAmountFromUtxo(inputIndex, input, cache),
    script = _getScriptAndAmountFr.script;
  return (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2TR)(script) ? script.subarray(2, 34) : null;
}
function trimTaprootSig(signature) {
  return signature.length === 64 ? signature : signature.subarray(0, 64);
}
function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
  var unsignedTx = cache.__TX;
  var sighashType = input.sighashType || _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(sighashType, allowedSighashTypes);
  var prevOuts = inputs.map(function (i, index) {
    return getScriptAndAmountFromUtxo(index, i, cache);
  });
  var signingScripts = prevOuts.map(function (o) {
    return o.script;
  });
  var values = prevOuts.map(function (o) {
    return o.value;
  });
  var hashes = [];
  if (input.tapInternalKey && !tapLeafHashToSign) {
    var outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
    if ((0, _psbt_bip371_js__WEBPACK_IMPORTED_MODULE_7__["default"].toXOnly)(pubkey).equals(outputKey)) {
      var tapKeyHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType);
      hashes.push({
        pubkey: pubkey,
        hash: tapKeyHash
      });
    }
  }
  var tapLeafHashes = (input.tapLeafScript || []).filter(function (tapLeaf) {
    return (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].pubkeyInScript)(pubkey, tapLeaf.script);
  }).map(function (tapLeaf) {
    var hash = (0, bip341_1.tapleafHash)({
      output: tapLeaf.script,
      version: tapLeaf.leafVersion
    });
    return Object.assign({
      hash: hash
    }, tapLeaf);
  }).filter(function (tapLeaf) {
    return !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash);
  }).map(function (tapLeaf) {
    var tapScriptHash = unsignedTx.hashForWitnessV1(inputIndex, signingScripts, values, sighashType, tapLeaf.hash);
    return {
      pubkey: pubkey,
      hash: tapScriptHash,
      leafHash: tapLeaf.hash
    };
  });
  return hashes.concat(tapLeafHashes);
}
function checkSighashTypeAllowed(sighashType, sighashTypes) {
  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
    var str = sighashTypeToString(sighashType);
    throw new Error("Sighash type is not allowed. Retry the sign method passing the " + "sighashTypes array of whitelisted types. Sighash type: ".concat(str));
  }
}
function getPayment(script, scriptType, partialSig) {
  var payment;
  switch (scriptType) {
    case 'multisig':
      var sigs = getSortedSigs(script, partialSig);
      payment = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2ms({
        output: script,
        signatures: sigs
      });
      break;
    case 'pubkey':
      payment = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2pk({
        output: script,
        signature: partialSig[0].signature
      });
      break;
    case 'pubkeyhash':
      payment = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2pkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
    case 'witnesspubkeyhash':
      payment = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2wpkh({
        output: script,
        pubkey: partialSig[0].pubkey,
        signature: partialSig[0].signature
      });
      break;
  }
  return payment;
}
function getScriptFromInput(inputIndex, input, cache) {
  var unsignedTx = cache.__TX;
  var res = {
    script: null,
    isSegwit: false,
    isP2SH: false,
    isP2WSH: false
  };
  res.isP2SH = !!input.redeemScript;
  res.isP2WSH = !!input.witnessScript;
  if (input.witnessScript) {
    res.script = input.witnessScript;
  } else if (input.redeemScript) {
    res.script = input.redeemScript;
  } else {
    if (input.nonWitnessUtxo) {
      var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
      var prevoutIndex = unsignedTx.ins[inputIndex].index;
      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
    } else if (input.witnessUtxo) {
      res.script = input.witnessUtxo.script;
    }
  }
  if (input.witnessScript || (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WPKH)(res.script)) {
    res.isSegwit = true;
  }
  return res;
}
function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
  var input = (0, utils_1.checkForInput)(inputs, inputIndex);
  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
    throw new Error('Need bip32Derivation to sign with HD');
  }
  var myDerivations = input.bip32Derivation.map(function (bipDv) {
    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
      return bipDv;
    } else {
      return;
    }
  }).filter(function (v) {
    return !!v;
  });
  if (myDerivations.length === 0) {
    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');
  }
  var signers = myDerivations.map(function (bipDv) {
    var node = hdKeyPair.derivePath(bipDv.path);
    if (!bipDv.pubkey.equals(node.publicKey)) {
      throw new Error('pubkey did not match bip32Derivation');
    }
    return node;
  });
  return signers;
}
function getSortedSigs(script, partialSig) {
  var p2ms = _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2ms({
    output: script
  });
  return p2ms.pubkeys.map(function (pk) {
    return (partialSig.filter(function (ps) {
      return ps.pubkey.equals(pk);
    })[0] || {}).signature;
  }).filter(function (v) {
    return !!v;
  });
}
function scriptWitnessToWitnessStack(buffer) {
  var offset = 0;
  function readSlice(n) {
    offset += n;
    return buffer.slice(offset - n, offset);
  }
  function readVarInt() {
    var vi = varuint.decode(buffer, offset);
    offset += varuint.decode.bytes;
    return vi;
  }
  function readVarSlice() {
    return readSlice(readVarInt());
  }
  function readVector() {
    var count = readVarInt();
    var vector = [];
    for (var i = 0; i < count; i++) vector.push(readVarSlice());
    return vector;
  }
  return readVector();
}
function sighashTypeToString(sighashType) {
  var text = sighashType & _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';
  var sigMod = sighashType & 0x1f;
  switch (sigMod) {
    case _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_ALL:
      text += 'SIGHASH_ALL';
      break;
    case _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_SINGLE:
      text += 'SIGHASH_SINGLE';
      break;
    case _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.SIGHASH_NONE:
      text += 'SIGHASH_NONE';
      break;
  }
  return text;
}
function addNonWitnessTxCache(cache, input, inputIndex) {
  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
  var tx = _transaction_js__WEBPACK_IMPORTED_MODULE_6__["default"].Transaction.fromBuffer(input.nonWitnessUtxo);
  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
  var self = cache;
  var selfIndex = inputIndex;
  delete input.nonWitnessUtxo;
  Object.defineProperty(input, 'nonWitnessUtxo', {
    enumerable: true,
    get: function get() {
      var buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
      var txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
      if (buf !== undefined) {
        return buf;
      } else {
        var newBuf = txCache.toBuffer();
        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
        return newBuf;
      }
    },
    set: function set(data) {
      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
    }
  });
}
function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
  var inputAmount = 0;
  inputs.forEach(function (input, idx) {
    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;
    if (mustFinalize && input.finalScriptWitness) {
      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);
    }
    if (input.witnessUtxo) {
      inputAmount += input.witnessUtxo.value;
    } else if (input.nonWitnessUtxo) {
      var nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
      var vout = tx.ins[idx].index;
      var out = nwTx.outs[vout];
      inputAmount += out.value;
    }
  });
  var outputAmount = tx.outs.reduce(function (total, o) {
    return total + o.value;
  }, 0);
  var fee = inputAmount - outputAmount;
  if (fee < 0) {
    throw new Error('Outputs are spending more than Inputs');
  }
  var bytes = tx.virtualSize();
  cache.__FEE = fee;
  cache.__EXTRACTED_TX = tx;
  cache.__FEE_RATE = Math.floor(fee / bytes);
}
function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
  var c = cache.__NON_WITNESS_UTXO_TX_CACHE;
  if (!c[inputIndex]) {
    addNonWitnessTxCache(cache, input, inputIndex);
  }
  return c[inputIndex];
}
function getScriptFromUtxo(inputIndex, input, cache) {
  var _getScriptAndAmountFr2 = getScriptAndAmountFromUtxo(inputIndex, input, cache),
    script = _getScriptAndAmountFr2.script;
  return script;
}
function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
  if (input.witnessUtxo !== undefined) {
    return {
      script: input.witnessUtxo.script,
      value: input.witnessUtxo.value
    };
  } else if (input.nonWitnessUtxo !== undefined) {
    var nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);
    var o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
    return {
      script: o.script,
      value: o.value
    };
  } else {
    throw new Error("Can't find pubkey in input without Utxo data");
  }
}
function pubkeyInInput(pubkey, input, inputIndex, cache) {
  var script = getScriptFromUtxo(inputIndex, input, cache);
  var _getMeaningfulScript2 = getMeaningfulScript(script, inputIndex, 'input', input.redeemScript, input.witnessScript),
    meaningfulScript = _getMeaningfulScript2.meaningfulScript;
  return (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].pubkeyInScript)(pubkey, meaningfulScript);
}
function pubkeyInOutput(pubkey, output, outputIndex, cache) {
  var script = cache.__TX.outs[outputIndex].script;
  var _getMeaningfulScript3 = getMeaningfulScript(script, outputIndex, 'output', output.redeemScript, output.witnessScript),
    meaningfulScript = _getMeaningfulScript3.meaningfulScript;
  return (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].pubkeyInScript)(pubkey, meaningfulScript);
}
function redeemFromFinalScriptSig(finalScript) {
  if (!finalScript) return;
  var decomp = _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].decompile(finalScript);
  if (!decomp) return;
  var lastItem = decomp[decomp.length - 1];
  if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem)) return;
  var sDecomp = _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function redeemFromFinalWitnessScript(finalScript) {
  if (!finalScript) return;
  var decomp = scriptWitnessToWitnessStack(finalScript);
  var lastItem = decomp[decomp.length - 1];
  if (isPubkeyLike(lastItem)) return;
  var sDecomp = _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].decompile(lastItem);
  if (!sDecomp) return;
  return lastItem;
}
function compressPubkey(pubkey) {
  if (pubkey.length === 65) {
    var parity = pubkey[64] & 1;
    var newKey = pubkey.slice(0, 33);
    newKey[0] = 2 | parity;
    return newKey;
  }
  return pubkey.slice();
}
function isPubkeyLike(buf) {
  return buf.length === 33 && _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].isCanonicalPubKey(buf);
}
function isSigLike(buf) {
  return _script_js__WEBPACK_IMPORTED_MODULE_5__["default"].isCanonicalScriptSignature(buf);
}
function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
  var isP2SH = (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2SHScript)(script);
  var isP2SHP2WSH = isP2SH && redeemScript && (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WSHScript)(redeemScript);
  var isP2WSH = (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WSHScript)(script);
  if (isP2SH && redeemScript === undefined) throw new Error('scriptPubkey is P2SH but redeemScript missing');
  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined) throw new Error('scriptPubkey or redeemScript is P2WSH but witnessScript missing');
  var meaningfulScript;
  if (isP2SHP2WSH) {
    meaningfulScript = witnessScript;
    checkRedeemScript(index, script, redeemScript, ioType);
    checkWitnessScript(index, redeemScript, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2WSH) {
    meaningfulScript = witnessScript;
    checkWitnessScript(index, script, witnessScript, ioType);
    checkInvalidP2WSH(meaningfulScript);
  } else if (isP2SH) {
    meaningfulScript = redeemScript;
    checkRedeemScript(index, script, redeemScript, ioType);
  } else {
    meaningfulScript = script;
  }
  return {
    meaningfulScript: meaningfulScript,
    type: isP2SHP2WSH ? 'p2sh-p2wsh' : isP2SH ? 'p2sh' : isP2WSH ? 'p2wsh' : 'raw'
  };
}
function checkInvalidP2WSH(script) {
  if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WPKH)(script) || (0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2SHScript)(script)) {
    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');
  }
}
function classifyScript(script) {
  if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2WPKH)(script)) return 'witnesspubkeyhash';
  if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2PKH)(script)) return 'pubkeyhash';
  if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2MS)(script)) return 'multisig';
  if ((0, _psbt_psbtutils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isP2PK)(script)) return 'pubkey';
  return 'nonstandard';
}
function range(n) {
  return _toConsumableArray(Array(n).keys());
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/psbt/bip371.js"
/*!******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/psbt/bip371.js ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction.js */ "./src/analyze/crypto/bitcoin/v6/transaction.js");
/* harmony import */ var _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./psbtutils.js */ "./src/analyze/crypto/bitcoin/v6/psbt/psbtutils.js");
/* harmony import */ var _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../payments/bip341.js */ "./src/analyze/crypto/bitcoin/v6/payments/bip341.js");
/* harmony import */ var _payments_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../payments/index.js */ "./src/analyze/crypto/bitcoin/v6/payments/index.js");
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }






var exports = {};
var toXOnly = function toXOnly(pubKey) {
  return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
};
exports.toXOnly = toXOnly;
function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
  var tapLeaf = findTapLeafToFinalize(input, inputIndex, tapLeafHashToFinalize);
  try {
    var sigs = sortSignatures(input, tapLeaf);
    var witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
    return {
      finalScriptWitness: (0, _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].witnessStackToScriptWitness)(witness)
    };
  } catch (err) {
    throw new Error("Can not finalize taproot input #".concat(inputIndex, ": ").concat(err));
  }
}
exports.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(sig, sighashType) {
  var sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);
  return Buffer.concat([sig, sighashTypeByte]);
}
exports.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(input) {
  return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isP2TR)(input.witnessUtxo.script));
}
exports.isTaprootInput = isTaprootInput;
function isTaprootOutput(output, script) {
  return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isP2TR)(script));
}
exports.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(inputData, newInputData, action) {
  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
  checkIfTapLeafInTree(inputData, newInputData, action);
}
exports.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(outputData, newOutputData, action) {
  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
  checkTaprootScriptPubkey(outputData, newOutputData);
}
exports.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(outputData, newOutputData) {
  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
  var tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
  var tapTree = newOutputData.tapTree || outputData.tapTree;
  if (tapInternalKey) {
    var scriptPubkey = outputData.script;
    var script = getTaprootScripPubkey(tapInternalKey, tapTree);
    if (scriptPubkey && !scriptPubkey.equals(script)) throw new Error('Error adding output. Script or address missmatch.');
  }
}
function getTaprootScripPubkey(tapInternalKey, tapTree) {
  var scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
  var _ref = (0, _payments_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].p2tr)({
      internalPubkey: tapInternalKey,
      scriptTree: scriptTree
    }),
    output = _ref.output;
  return output;
}
function tweakInternalPubKey(inputIndex, input) {
  var tapInternalKey = input.tapInternalKey;
  var outputKey = tapInternalKey && (0, _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].tweakKey)(tapInternalKey, input.tapMerkleRoot);
  if (!outputKey) throw new Error("Cannot tweak tap internal key for input #".concat(inputIndex, ". Public key: ").concat(tapInternalKey && tapInternalKey.toString('hex')));
  return outputKey.x;
}
exports.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(tree) {
  if (!(0, _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTaptree)(tree)) throw new Error('Cannot convert taptree to tapleaf list. Expecting a tapree structure.');
  return _tapTreeToList(tree);
}
exports.tapTreeToList = tapTreeToList;
function tapTreeFromList() {
  var leaves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  if (leaves.length === 1 && leaves[0].depth === 0) return {
    output: leaves[0].script,
    version: leaves[0].leafVersion
  };
  return instertLeavesInTree(leaves);
}
exports.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(input, action) {
  var sigs = extractTaprootSigs(input);
  return sigs.some(function (sig) {
    return (0, _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].signatureBlocksAction)(sig, decodeSchnorrSignature, action);
  });
}
exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(signature) {
  return {
    signature: signature.slice(0, 64),
    hashType: signature.slice(64)[0] || _transaction_js__WEBPACK_IMPORTED_MODULE_1__["default"].Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(input) {
  var sigs = [];
  if (input.tapKeySig) sigs.push(input.tapKeySig);
  if (input.tapScriptSig) sigs.push.apply(sigs, _toConsumableArray(input.tapScriptSig.map(function (s) {
    return s.signature;
  })));
  if (!sigs.length) {
    var finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
    if (finalTapKeySig) sigs.push(finalTapKeySig);
  }
  return sigs;
}
function getTapKeySigFromWithness(finalScriptWitness) {
  if (!finalScriptWitness) return;
  var witness = finalScriptWitness.slice(2);
  if (witness.length === 64 || witness.length === 65) return witness;
}
function _tapTreeToList(tree) {
  var leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (depth > _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');
  if (!tree) return [];
  if ((0, _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTapleaf)(tree)) {
    leaves.push({
      depth: depth,
      leafVersion: tree.version || _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].LEAF_VERSION_TAPSCRIPT,
      script: tree.output
    });
    return leaves;
  }
  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
  return leaves;
}
function instertLeavesInTree(leaves) {
  var tree;
  var _iterator = _createForOfIteratorHelper(leaves),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var leaf = _step.value;
      tree = instertLeafInTree(leaf, tree);
      if (!tree) throw new Error("No room left to insert tapleaf in tree");
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return tree;
}
function instertLeafInTree(leaf, tree) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  if (depth > _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');
  if (leaf.depth === depth) {
    if (!tree) return {
      output: leaf.script,
      version: leaf.leafVersion
    };
    return;
  }
  if ((0, _types_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTapleaf)(tree)) return;
  var leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
  if (leftSide) return [leftSide, tree && tree[1]];
  var rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
  if (rightSide) return [tree && tree[0], rightSide];
}
function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
  var isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
  var isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
  var hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error("Invalid arguments for Psbt.".concat(action, ". ") + "Cannot use both taproot and non-taproot fields.");
}
function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
  var isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
  var isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
  var hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields) throw new Error("Invalid arguments for Psbt.".concat(action, ". ") + "Cannot use both taproot and non-taproot fields.");
}
function checkIfTapLeafInTree(inputData, newInputData, action) {
  if (newInputData.tapMerkleRoot) {
    var newLeafsInTree = (newInputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, newInputData.tapMerkleRoot);
    });
    var oldLeafsInTree = (inputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, newInputData.tapMerkleRoot);
    });
    if (!newLeafsInTree || !oldLeafsInTree) throw new Error("Invalid arguments for Psbt.".concat(action, ". Tapleaf not part of taptree."));
  } else if (inputData.tapMerkleRoot) {
    var _newLeafsInTree = (newInputData.tapLeafScript || []).every(function (l) {
      return isTapLeafInTree(l, inputData.tapMerkleRoot);
    });
    if (!_newLeafsInTree) throw new Error("Invalid arguments for Psbt.".concat(action, ". Tapleaf not part of taptree."));
  }
}
function isTapLeafInTree(tapLeaf, merkleRoot) {
  if (!merkleRoot) return true;
  var leafHash = (0, _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion
  });
  var rootHash = (0, _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].rootHashFromPath)(tapLeaf.controlBlock, leafHash);
  return rootHash.equals(merkleRoot);
}
function sortSignatures(input, tapLeaf) {
  var leafHash = (0, _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].tapleafHash)({
    output: tapLeaf.script,
    version: tapLeaf.leafVersion
  });
  return (input.tapScriptSig || []).filter(function (tss) {
    return tss.leafHash.equals(leafHash);
  }).map(function (tss) {
    return addPubkeyPositionInScript(tapLeaf.script, tss);
  }).sort(function (t1, t2) {
    return t2.positionInScript - t1.positionInScript;
  }).map(function (t) {
    return t.signature;
  });
}
function addPubkeyPositionInScript(script, tss) {
  return Object.assign({
    positionInScript: (0, _psbtutils_js__WEBPACK_IMPORTED_MODULE_2__["default"].pubkeyPositionInScript)(tss.pubkey, script)
  }, tss);
}
function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
  if (!input.tapScriptSig || !input.tapScriptSig.length) throw new Error("Can not finalize taproot input #".concat(inputIndex, ". No tapleaf script signature provided."));
  var tapLeaf = (input.tapLeafScript || []).sort(function (a, b) {
    return a.controlBlock.length - b.controlBlock.length;
  }).find(function (leaf) {
    return canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize);
  });
  if (!tapLeaf) throw new Error("Can not finalize taproot input #".concat(inputIndex, ". Signature for tapleaf script not found."));
  return tapLeaf;
}
function canFinalizeLeaf(leaf, tapScriptSig, hash) {
  var leafHash = (0, _payments_bip341_js__WEBPACK_IMPORTED_MODULE_3__["default"].tapleafHash)({
    output: leaf.script,
    version: leaf.leafVersion
  });
  var whiteListedHash = !hash || hash.equals(leafHash);
  return whiteListedHash && tapScriptSig.find(function (tss) {
    return tss.leafHash.equals(leafHash);
  }) !== undefined;
}
function hasNonTaprootFields(io) {
  return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/psbt/psbtutils.js"
/*!*********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/psbt/psbtutils.js ***!
  \*********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction.js */ "./src/analyze/crypto/bitcoin/v6/transaction.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");
/* harmony import */ var _payments_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../payments/index.js */ "./src/analyze/crypto/bitcoin/v6/payments/index.js");




var varuint = {};
var MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range');
}
varuint.encode = function encode(_number, buffer, offset) {
  checkUInt53(_number);
  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  if (_number < 0xfd) {
    buffer.writeUInt8(_number, offset);
    Object.assign(encode, {
      bytes: 1
    });
  } else if (_number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset);
    buffer.writeUInt16LE(_number, offset + 1);
    Object.assign(encode, {
      bytes: 3
    });
  } else if (_number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset);
    buffer.writeUInt32LE(_number, offset + 1);
    Object.assign(encode, {
      bytes: 5
    });
  } else {
    buffer.writeUInt8(0xff, offset);
    buffer.writeUInt32LE(_number >>> 0, offset + 1);
    buffer.writeUInt32LE(_number / 0x100000000 | 0, offset + 5);
    Object.assign(encode, {
      bytes: 9
    });
  }
  return buffer;
};
varuint.decode = function decode(buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance');
  if (!offset) offset = 0;
  var first = buffer.readUInt8(offset);
  if (first < 0xfd) {
    Object.assign(decode, {
      bytes: 1
    });
    return first;
  } else if (first === 0xfd) {
    Object.assign(decode, {
      bytes: 3
    });
    return buffer.readUInt16LE(offset + 1);
  } else if (first === 0xfe) {
    Object.assign(decode, {
      bytes: 5
    });
    return buffer.readUInt32LE(offset + 1);
  } else {
    Object.assign(decode, {
      bytes: 9
    });
    var lo = buffer.readUInt32LE(offset + 1);
    var hi = buffer.readUInt32LE(offset + 5);
    var _number = hi * 0x0100000000 + lo;
    checkUInt53(_number);
    return _number;
  }
};
varuint.encodingLength = function encodingLength(_number) {
  checkUInt53(_number);
  return _number < 0xfd ? 1 : _number <= 0xffff ? 3 : _number <= 0xffffffff ? 5 : 9;
};
var exports = {};
function isPaymentFactory(payment) {
  return function (script) {
    try {
      payment({
        output: script
      });
      return true;
    } catch (err) {
      return false;
    }
  };
}
exports.isP2MS = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2ms);
exports.isP2PK = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2pk);
exports.isP2PKH = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2pkh);
exports.isP2WPKH = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2wpkh);
exports.isP2WSHScript = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2wsh);
exports.isP2SHScript = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2sh);
exports.isP2TR = isPaymentFactory(_payments_index_js__WEBPACK_IMPORTED_MODULE_3__["default"].p2tr);
function witnessStackToScriptWitness(witness) {
  var buffer = Buffer.allocUnsafe(0);
  function writeSlice(slice) {
    buffer = Buffer.concat([buffer, Buffer.from(slice)]);
  }
  function writeVarInt(i) {
    var currentLen = buffer.length;
    var varintLen = varuint.encodingLength(i);
    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
    varuint.encode(i, buffer, currentLen);
  }
  function writeVarSlice(slice) {
    writeVarInt(slice.length);
    writeSlice(slice);
  }
  function writeVector(vector) {
    writeVarInt(vector.length);
    vector.forEach(writeVarSlice);
  }
  writeVector(witness);
  return buffer;
}
exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(pubkey, script) {
  var pubkeyHash = (0, _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash160)(pubkey);
  var pubkeyXOnly = pubkey.slice(1, 33);
  var decompiled = _script_js__WEBPACK_IMPORTED_MODULE_0__["default"].decompile(script);
  if (decompiled === null) throw new Error('Unknown script error');
  return decompiled.findIndex(function (element) {
    if (typeof element === 'number') return false;
    return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
  });
}
exports.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(pubkey, script) {
  return pubkeyPositionInScript(pubkey, script) !== -1;
}
exports.pubkeyInScript = pubkeyInScript;
function checkInputForSig(input, action) {
  var pSigs = extractPartialSigs(input);
  return pSigs.some(function (pSig) {
    return signatureBlocksAction(pSig, _script_js__WEBPACK_IMPORTED_MODULE_0__["default"].signature.decode, action);
  });
}
exports.checkInputForSig = checkInputForSig;
function signatureBlocksAction(signature, signatureDecodeFn, action) {
  var _signatureDecodeFn = signatureDecodeFn(signature),
    hashType = _signatureDecodeFn.hashType;
  var whitelist = [];
  var isAnyoneCanPay = hashType & _transaction_js__WEBPACK_IMPORTED_MODULE_1__["default"].Transaction.SIGHASH_ANYONECANPAY;
  if (isAnyoneCanPay) whitelist.push('addInput');
  var hashMod = hashType & 0x1f;
  switch (hashMod) {
    case _transaction_js__WEBPACK_IMPORTED_MODULE_1__["default"].Transaction.SIGHASH_ALL:
      break;
    case _transaction_js__WEBPACK_IMPORTED_MODULE_1__["default"].Transaction.SIGHASH_SINGLE:
    case _transaction_js__WEBPACK_IMPORTED_MODULE_1__["default"].Transaction.SIGHASH_NONE:
      whitelist.push('addOutput');
      whitelist.push('setInputSequence');
      break;
  }
  if (whitelist.indexOf(action) === -1) {
    return true;
  }
  return false;
}
exports.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(input) {
  var pSigs = [];
  if ((input.partialSig || []).length === 0) {
    if (!input.finalScriptSig && !input.finalScriptWitness) return [];
    pSigs = getPsigsFromInputFinalScripts(input);
  } else {
    pSigs = input.partialSig;
  }
  return pSigs.map(function (p) {
    return p.signature;
  });
}
function getPsigsFromInputFinalScripts(input) {
  var scriptItems = !input.finalScriptSig ? [] : _script_js__WEBPACK_IMPORTED_MODULE_0__["default"].decompile(input.finalScriptSig) || [];
  var witnessItems = !input.finalScriptWitness ? [] : _script_js__WEBPACK_IMPORTED_MODULE_0__["default"].decompile(input.finalScriptWitness) || [];
  return scriptItems.concat(witnessItems).filter(function (item) {
    return Buffer.isBuffer(item) && _script_js__WEBPACK_IMPORTED_MODULE_0__["default"].isCanonicalScriptSignature(item);
  }).map(function (sig) {
    return {
      signature: sig
    };
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/push_data.js"
/*!****************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/push_data.js ***!
  \****************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ops_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ops.js */ "./src/analyze/crypto/bitcoin/v6/ops.js");

var exports = {};
function encodingLength(i) {
  return i < _ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;
}
exports.encodingLength = encodingLength;
function encode(buffer, num, offset) {
  var size = encodingLength(num);
  if (size === 1) {
    buffer.writeUInt8(num, offset);
  } else if (size === 2) {
    buffer.writeUInt8(_ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA1, offset);
    buffer.writeUInt8(num, offset + 1);
  } else if (size === 3) {
    buffer.writeUInt8(_ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA2, offset);
    buffer.writeUInt16LE(num, offset + 1);
  } else {
    buffer.writeUInt8(_ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA4, offset);
    buffer.writeUInt32LE(num, offset + 1);
  }
  return size;
}
exports.encode = encode;
function decode(buffer, offset) {
  var opcode = buffer.readUInt8(offset);
  var num;
  var size;
  if (opcode < _ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA1) {
    num = opcode;
    size = 1;
  } else if (opcode === _ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null;
    num = buffer.readUInt8(offset + 1);
    size = 2;
  } else if (opcode === _ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null;
    num = buffer.readUInt16LE(offset + 1);
    size = 3;
  } else {
    if (offset + 5 > buffer.length) return null;
    if (opcode !== _ops_js__WEBPACK_IMPORTED_MODULE_0__.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');
    num = buffer.readUInt32LE(offset + 1);
    size = 5;
  }
  return {
    opcode: opcode,
    number: num,
    size: size
  };
}
exports.decode = decode;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/script.js"
/*!*************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/script.js ***!
  \*************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bip66_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bip66.js */ "./src/analyze/crypto/bitcoin/v6/bip66.js");
/* harmony import */ var _ops_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ops.js */ "./src/analyze/crypto/bitcoin/v6/ops.js");
/* harmony import */ var _push_data_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./push_data.js */ "./src/analyze/crypto/bitcoin/v6/push_data.js");
/* harmony import */ var _script_number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./script_number.js */ "./src/analyze/crypto/bitcoin/v6/script_number.js");
/* harmony import */ var _script_signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./script_signature.js */ "./src/analyze/crypto/bitcoin/v6/script_signature.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");






var exports = {};
Object.defineProperty(exports, 'OPS', {
  enumerable: true,
  get: function get() {
    return _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS;
  }
});
var typeforce = _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].typeforce;
var OP_INT_BASE = _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_RESERVED;
function isOPInt(value) {
  return _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Number(value) && (value === _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_0 || value >= _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_1 && value <= _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_16 || value === _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_1NEGATE);
}
function isPushOnlyChunk(value) {
  return _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Buffer(value) || isOPInt(value);
}
function isPushOnly(value) {
  return _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Array(value) && value.every(isPushOnlyChunk);
}
exports.isPushOnly = isPushOnly;
function countNonPushOnlyOPs(value) {
  return value.length - value.filter(isPushOnlyChunk).length;
}
exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
function asMinimalOP(buffer) {
  if (buffer.length === 0) return _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_0;
  if (buffer.length !== 1) return;
  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
  if (buffer[0] === 0x81) return _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_1NEGATE;
}
function chunksIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function chunksIsArray(buf) {
  return _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Array(buf);
}
function singleChunkIsBuffer(buf) {
  return Buffer.isBuffer(buf);
}
function compile(chunks) {
  if (chunksIsBuffer(chunks)) return chunks;
  typeforce(_types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Array, chunks);
  var bufferSize = chunks.reduce(function (accum, chunk) {
    if (singleChunkIsBuffer(chunk)) {
      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {
        return accum + 1;
      }
      return accum + _push_data_js__WEBPACK_IMPORTED_MODULE_2__["default"].encodingLength(chunk.length) + chunk.length;
    }
    return accum + 1;
  }, 0.0);
  var buffer = Buffer.allocUnsafe(bufferSize);
  var offset = 0;
  chunks.forEach(function (chunk) {
    if (singleChunkIsBuffer(chunk)) {
      var opcode = asMinimalOP(chunk);
      if (opcode !== undefined) {
        buffer.writeUInt8(opcode, offset);
        offset += 1;
        return;
      }
      offset += _push_data_js__WEBPACK_IMPORTED_MODULE_2__["default"].encode(buffer, chunk.length, offset);
      chunk.copy(buffer, offset);
      offset += chunk.length;
    } else {
      buffer.writeUInt8(chunk, offset);
      offset += 1;
    }
  });
  if (offset !== buffer.length) throw new Error('Could not decode chunks');
  return buffer;
}
exports.compile = compile;
function decompile(buffer) {
  if (chunksIsArray(buffer)) return buffer;
  typeforce(_types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Buffer, buffer);
  var chunks = [];
  var i = 0;
  while (i < buffer.length) {
    var opcode = buffer[i];
    if (opcode > _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_0 && opcode <= _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_PUSHDATA4) {
      var d = _push_data_js__WEBPACK_IMPORTED_MODULE_2__["default"].decode(buffer, i);
      if (d === null) return null;
      i += d.size;
      if (i + d.number > buffer.length) return null;
      var data = buffer.slice(i, i + d.number);
      i += d.number;
      var op = asMinimalOP(data);
      if (op !== undefined) {
        chunks.push(op);
      } else {
        chunks.push(data);
      }
    } else {
      chunks.push(opcode);
      i += 1;
    }
  }
  return chunks;
}
exports.decompile = decompile;
function toASM(chunks) {
  if (chunksIsBuffer(chunks)) {
    chunks = decompile(chunks);
  }
  if (!chunks) {
    throw new Error('Could not convert invalid chunks to ASM');
  }
  return chunks.map(function (chunk) {
    if (singleChunkIsBuffer(chunk)) {
      var op = asMinimalOP(chunk);
      if (op === undefined) return chunk.toString('hex');
      chunk = op;
    }
    return _ops_js__WEBPACK_IMPORTED_MODULE_1__.REVERSE_OPS[chunk];
  }).join(' ');
}
exports.toASM = toASM;
function fromASM(asm) {
  typeforce(_types_js__WEBPACK_IMPORTED_MODULE_5__["default"].String, asm);
  return compile(asm.split(' ').map(function (chunkStr) {
    if (_ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS[chunkStr] !== undefined) return _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS[chunkStr];
    typeforce(_types_js__WEBPACK_IMPORTED_MODULE_5__["default"].Hex, chunkStr);
    return Buffer.from(chunkStr, 'hex');
  }));
}
exports.fromASM = fromASM;
function toStack(chunks) {
  chunks = decompile(chunks);
  typeforce(isPushOnly, chunks);
  return chunks.map(function (op) {
    if (singleChunkIsBuffer(op)) return op;
    if (op === _ops_js__WEBPACK_IMPORTED_MODULE_1__.OPS.OP_0) return Buffer.allocUnsafe(0);
    return _script_number_js__WEBPACK_IMPORTED_MODULE_3__["default"].encode(op - OP_INT_BASE);
  });
}
exports.toStack = toStack;
function isCanonicalPubKey(buffer) {
  return _types_js__WEBPACK_IMPORTED_MODULE_5__["default"].isPoint(buffer);
}
exports.isCanonicalPubKey = isCanonicalPubKey;
function isDefinedHashType(hashType) {
  var hashTypeMod = hashType & ~0x80;
  return hashTypeMod > 0x00 && hashTypeMod < 0x04;
}
exports.isDefinedHashType = isDefinedHashType;
function isCanonicalScriptSignature(buffer) {
  if (!Buffer.isBuffer(buffer)) return false;
  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
  return _bip66_js__WEBPACK_IMPORTED_MODULE_0__["default"].check(buffer.slice(0, -1));
}
exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
exports.number = _script_number_js__WEBPACK_IMPORTED_MODULE_3__["default"];
exports.signature = _script_signature_js__WEBPACK_IMPORTED_MODULE_4__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/script_number.js"
/*!********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/script_number.js ***!
  \********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var exports = {};
function decode(buffer, maxLength, minimal) {
  maxLength = maxLength || 4;
  minimal = minimal === undefined ? true : minimal;
  var length = buffer.length;
  if (length === 0) return 0;
  if (length > maxLength) throw new TypeError('Script number overflow');
  if (minimal) {
    if ((buffer[length - 1] & 0x7f) === 0) {
      if (length <= 1 || (buffer[length - 2] & 0x80) === 0) throw new Error('Non-minimally encoded script number');
    }
  }
  if (length === 5) {
    var a = buffer.readUInt32LE(0);
    var b = buffer.readUInt8(4);
    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);
    return b * 0x100000000 + a;
  }
  var result = 0;
  for (var i = 0; i < length; ++i) {
    result |= buffer[i] << 8 * i;
  }
  if (buffer[length - 1] & 0x80) return -(result & ~(0x80 << 8 * (length - 1)));
  return result;
}
exports.decode = decode;
function scriptNumSize(i) {
  return i > 0x7fffffff ? 5 : i > 0x7fffff ? 4 : i > 0x7fff ? 3 : i > 0x7f ? 2 : i > 0x00 ? 1 : 0;
}
function encode(_number) {
  var value = Math.abs(_number);
  var size = scriptNumSize(value);
  var buffer = Buffer.allocUnsafe(size);
  var negative = _number < 0;
  for (var i = 0; i < size; ++i) {
    buffer.writeUInt8(value & 0xff, i);
    value >>= 8;
  }
  if (buffer[size - 1] & 0x80) {
    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);
  } else if (negative) {
    buffer[size - 1] |= 0x80;
  }
  return buffer;
}
exports.encode = encode;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/script_signature.js"
/*!***********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/script_signature.js ***!
  \***********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");
/* harmony import */ var _bip66_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bip66.js */ "./src/analyze/crypto/bitcoin/v6/bip66.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");




var typeforce = _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].typeforce;
var ZERO = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].alloc(1, 0);
var exports = {};
function toDER(x) {
  var i = 0;
  while (x[i] === 0) ++i;
  if (i === x.length) return ZERO;
  x = x.slice(i);
  if (x[0] & 0x80) return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([ZERO, x], 1 + x.length);
  return x;
}
function fromDER(x) {
  if (x[0] === 0x00) x = x.slice(1);
  var buffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].alloc(32, 0);
  var bstart = Math.max(0, 32 - x.length);
  x.copy(buffer, bstart);
  return buffer;
}
function decode(buffer) {
  var hashType = buffer.readUInt8(buffer.length - 1);
  if (!(0, _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  var decoded = _bip66_js__WEBPACK_IMPORTED_MODULE_1__["default"].decode(buffer.slice(0, -1));
  var r = fromDER(decoded.r);
  var s = fromDER(decoded.s);
  var signature = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([r, s], 64);
  return {
    signature: signature,
    hashType: hashType
  };
}
exports.decode = decode;
function encode(signature, hashType) {
  typeforce({
    signature: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].BufferN(64),
    hashType: _types_js__WEBPACK_IMPORTED_MODULE_3__["default"].UInt8
  }, {
    signature: signature,
    hashType: hashType
  });
  if (!(0, _script_js__WEBPACK_IMPORTED_MODULE_2__["default"].isDefinedHashType)(hashType)) {
    throw new Error('Invalid hashType ' + hashType);
  }
  var hashTypeBuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(1);
  hashTypeBuffer.writeUInt8(hashType, 0);
  var r = toDER(signature.slice(0, 32));
  var s = toDER(signature.slice(32, 64));
  return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([_bip66_js__WEBPACK_IMPORTED_MODULE_1__["default"].encode(r, s), hashTypeBuffer]);
}
exports.encode = encode;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/transaction.js"
/*!******************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/transaction.js ***!
  \******************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");
/* harmony import */ var _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bufferutils.js */ "./src/analyze/crypto/bitcoin/v6/bufferutils.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");
/* harmony import */ var _script_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./script.js */ "./src/analyze/crypto/bitcoin/v6/script.js");
/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types.js */ "./src/analyze/crypto/bitcoin/v6/types.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }






var exports = {};
var typeforce = _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].typeforce;
function varSliceSize(someScript) {
  var length = someScript.length;
  return _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].varuint.encodingLength(length) + length;
}
function vectorSize(someVector) {
  var length = someVector.length;
  return _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {
    return sum + varSliceSize(witness);
  }, 0);
}
var EMPTY_BUFFER = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(0);
var EMPTY_WITNESS = [];
var ZERO = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
var ONE = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from('0000000000000000000000000000000000000000000000000000000000000001', 'hex');
var VALUE_UINT64_MAX = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from('ffffffffffffffff', 'hex');
var BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(out) {
  return out.value !== undefined;
}
var Transaction = function () {
  function Transaction() {
    _classCallCheck(this, Transaction);
    this.version = 1;
    this.locktime = 0;
    this.ins = [];
    this.outs = [];
  }
  return _createClass(Transaction, [{
    key: "isCoinbase",
    value: function isCoinbase() {
      return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
    }
  }, {
    key: "addInput",
    value: function addInput(hash, index, sequence, scriptSig) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Hash256bit, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].maybe(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32), _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].maybe(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer)), arguments);
      if (_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Null(sequence)) {
        sequence = Transaction.DEFAULT_SEQUENCE;
      }
      return this.ins.push({
        hash: hash,
        index: index,
        script: scriptSig || EMPTY_BUFFER,
        sequence: sequence,
        witness: EMPTY_WITNESS
      }) - 1;
    }
  }, {
    key: "addOutput",
    value: function addOutput(scriptPubKey, value) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Satoshi), arguments);
      return this.outs.push({
        script: scriptPubKey,
        value: value
      }) - 1;
    }
  }, {
    key: "hasWitnesses",
    value: function hasWitnesses() {
      return this.ins.some(function (x) {
        return x.witness.length !== 0;
      });
    }
  }, {
    key: "stripWitnesses",
    value: function stripWitnesses() {
      this.ins.forEach(function (input) {
        input.witness = EMPTY_WITNESS;
      });
    }
  }, {
    key: "weight",
    value: function weight() {
      var base = this.byteLength(false);
      var total = this.byteLength(true);
      return base * 3 + total;
    }
  }, {
    key: "virtualSize",
    value: function virtualSize() {
      return Math.ceil(this.weight() / 4);
    }
  }, {
    key: "byteLength",
    value: function byteLength() {
      var _ALLOW_WITNESS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      return (hasWitnesses ? 10 : 8) + _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].varuint.encodingLength(this.ins.length) + _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {
        return sum + 40 + varSliceSize(input.script);
      }, 0) + this.outs.reduce(function (sum, output) {
        return sum + 8 + varSliceSize(output.script);
      }, 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {
        return sum + vectorSize(input.witness);
      }, 0) : 0);
    }
  }, {
    key: "clone",
    value: function clone() {
      var newTx = new Transaction();
      newTx.version = this.version;
      newTx.locktime = this.locktime;
      newTx.ins = this.ins.map(function (txIn) {
        return {
          hash: txIn.hash,
          index: txIn.index,
          script: txIn.script,
          sequence: txIn.sequence,
          witness: txIn.witness
        };
      });
      newTx.outs = this.outs.map(function (txOut) {
        return {
          script: txOut.script,
          value: txOut.value
        };
      });
      return newTx;
    }
  }, {
    key: "hashForSignature",
    value: function hashForSignature(inIndex, prevOutScript, hashType) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Number), arguments);
      if (inIndex >= this.ins.length) return ONE;
      var ourScript = _script_js__WEBPACK_IMPORTED_MODULE_3__["default"].compile(_script_js__WEBPACK_IMPORTED_MODULE_3__["default"].decompile(prevOutScript).filter(function (x) {
        return x !== _script_js__WEBPACK_IMPORTED_MODULE_3__["default"].OPS.OP_CODESEPARATOR;
      }));
      var txTmp = this.clone();
      if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {
        txTmp.outs = [];
        txTmp.ins.forEach(function (input, i) {
          if (i === inIndex) return;
          input.sequence = 0;
        });
      } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {
        if (inIndex >= this.outs.length) return ONE;
        txTmp.outs.length = inIndex + 1;
        for (var i = 0; i < inIndex; i++) {
          txTmp.outs[i] = BLANK_OUTPUT;
        }
        txTmp.ins.forEach(function (input, y) {
          if (y === inIndex) return;
          input.sequence = 0;
        });
      }
      if (hashType & Transaction.SIGHASH_ANYONECANPAY) {
        txTmp.ins = [txTmp.ins[inIndex]];
        txTmp.ins[0].script = ourScript;
      } else {
        txTmp.ins.forEach(function (input) {
          input.script = EMPTY_BUFFER;
        });
        txTmp.ins[inIndex].script = ourScript;
      }
      var buffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(txTmp.byteLength(false) + 4);
      buffer.writeInt32LE(hashType, buffer.length - 4);
      txTmp.__toBuffer(buffer, 0, false);
      return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(buffer);
    }
  }, {
    key: "hashForWitnessV1",
    value: function hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32, typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer), typeforce.arrayOf(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Satoshi), _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32), arguments);
      if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
        throw new Error('Must supply prevout script and value for all inputs');
      }
      var outputType = hashType === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : hashType & Transaction.SIGHASH_OUTPUT_MASK;
      var inputType = hashType & Transaction.SIGHASH_INPUT_MASK;
      var isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;
      var isNone = outputType === Transaction.SIGHASH_NONE;
      var isSingle = outputType === Transaction.SIGHASH_SINGLE;
      var hashPrevouts = EMPTY_BUFFER;
      var hashAmounts = EMPTY_BUFFER;
      var hashScriptPubKeys = EMPTY_BUFFER;
      var hashSequences = EMPTY_BUFFER;
      var hashOutputs = EMPTY_BUFFER;
      if (!isAnyoneCanPay) {
        var bufferWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(36 * this.ins.length);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
        });
        hashPrevouts = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(bufferWriter.end());
        bufferWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(8 * this.ins.length);
        values.forEach(function (value) {
          return bufferWriter.writeUInt64(value);
        });
        hashAmounts = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(bufferWriter.end());
        bufferWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(prevOutScripts.map(varSliceSize).reduce(function (a, b) {
          return a + b;
        }));
        prevOutScripts.forEach(function (prevOutScript) {
          return bufferWriter.writeVarSlice(prevOutScript);
        });
        hashScriptPubKeys = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(bufferWriter.end());
        bufferWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(4 * this.ins.length);
        this.ins.forEach(function (txIn) {
          return bufferWriter.writeUInt32(txIn.sequence);
        });
        hashSequences = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(bufferWriter.end());
      }
      if (!(isNone || isSingle)) {
        var txOutsSize = this.outs.map(function (output) {
          return 8 + varSliceSize(output.script);
        }).reduce(function (a, b) {
          return a + b;
        });
        var _bufferWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(txOutsSize);
        this.outs.forEach(function (out) {
          _bufferWriter.writeUInt64(out.value);
          _bufferWriter.writeVarSlice(out.script);
        });
        hashOutputs = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(_bufferWriter.end());
      } else if (isSingle && inIndex < this.outs.length) {
        var output = this.outs[inIndex];
        var _bufferWriter2 = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(8 + varSliceSize(output.script));
        _bufferWriter2.writeUInt64(output.value);
        _bufferWriter2.writeVarSlice(output.script);
        hashOutputs = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(_bufferWriter2.end());
      }
      var spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
      var sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
      var sigMsgWriter = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(sigMsgSize);
      sigMsgWriter.writeUInt8(hashType);
      sigMsgWriter.writeInt32(this.version);
      sigMsgWriter.writeUInt32(this.locktime);
      sigMsgWriter.writeSlice(hashPrevouts);
      sigMsgWriter.writeSlice(hashAmounts);
      sigMsgWriter.writeSlice(hashScriptPubKeys);
      sigMsgWriter.writeSlice(hashSequences);
      if (!(isNone || isSingle)) {
        sigMsgWriter.writeSlice(hashOutputs);
      }
      sigMsgWriter.writeUInt8(spendType);
      if (isAnyoneCanPay) {
        var input = this.ins[inIndex];
        sigMsgWriter.writeSlice(input.hash);
        sigMsgWriter.writeUInt32(input.index);
        sigMsgWriter.writeUInt64(values[inIndex]);
        sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
        sigMsgWriter.writeUInt32(input.sequence);
      } else {
        sigMsgWriter.writeUInt32(inIndex);
      }
      if (annex) {
        var _bufferWriter3 = _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter.withCapacity(varSliceSize(annex));
        _bufferWriter3.writeVarSlice(annex);
        sigMsgWriter.writeSlice(_crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].sha256(_bufferWriter3.end()));
      }
      if (isSingle) {
        sigMsgWriter.writeSlice(hashOutputs);
      }
      if (leafHash) {
        sigMsgWriter.writeSlice(leafHash);
        sigMsgWriter.writeUInt8(0);
        sigMsgWriter.writeUInt32(0xffffffff);
      }
      return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].taggedHash('TapSighash', _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].concat([_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([0x00]), sigMsgWriter.end()]));
    }
  }, {
    key: "hashForWitnessV0",
    value: function hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Satoshi, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].UInt32), arguments);
      var tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from([]);
      var bufferWriter;
      var hashOutputs = ZERO;
      var hashPrevouts = ZERO;
      var hashSequence = ZERO;
      if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {
        tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(36 * this.ins.length);
        bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(tbuffer, 0);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
        });
        hashPrevouts = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(tbuffer);
      }
      if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
        tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(4 * this.ins.length);
        bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(tbuffer, 0);
        this.ins.forEach(function (txIn) {
          bufferWriter.writeUInt32(txIn.sequence);
        });
        hashSequence = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(tbuffer);
      }
      if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {
        var txOutsSize = this.outs.reduce(function (sum, output) {
          return sum + 8 + varSliceSize(output.script);
        }, 0);
        tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(txOutsSize);
        bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(tbuffer, 0);
        this.outs.forEach(function (out) {
          bufferWriter.writeUInt64(out.value);
          bufferWriter.writeVarSlice(out.script);
        });
        hashOutputs = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(tbuffer);
      } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
        var output = this.outs[inIndex];
        tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(8 + varSliceSize(output.script));
        bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(tbuffer, 0);
        bufferWriter.writeUInt64(output.value);
        bufferWriter.writeVarSlice(output.script);
        hashOutputs = _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(tbuffer);
      }
      tbuffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(156 + varSliceSize(prevOutScript));
      bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(tbuffer, 0);
      var input = this.ins[inIndex];
      bufferWriter.writeInt32(this.version);
      bufferWriter.writeSlice(hashPrevouts);
      bufferWriter.writeSlice(hashSequence);
      bufferWriter.writeSlice(input.hash);
      bufferWriter.writeUInt32(input.index);
      bufferWriter.writeVarSlice(prevOutScript);
      bufferWriter.writeUInt64(value);
      bufferWriter.writeUInt32(input.sequence);
      bufferWriter.writeSlice(hashOutputs);
      bufferWriter.writeUInt32(this.locktime);
      bufferWriter.writeUInt32(hashType);
      return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(tbuffer);
    }
  }, {
    key: "getHash",
    value: function getHash(forWitness) {
      if (forWitness && this.isCoinbase()) return _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].alloc(32, 0);
      return _crypto_js__WEBPACK_IMPORTED_MODULE_2__["default"].hash256(this.__toBuffer(undefined, undefined, forWitness));
    }
  }, {
    key: "getId",
    value: function getId() {
      return (0, _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].reverseBuffer)(this.getHash(false)).toString('hex');
    }
  }, {
    key: "toBuffer",
    value: function toBuffer(buffer, initialOffset) {
      return this.__toBuffer(buffer, initialOffset, true);
    }
  }, {
    key: "toHex",
    value: function toHex() {
      return this.toBuffer(undefined, undefined).toString('hex');
    }
  }, {
    key: "setInputScript",
    value: function setInputScript(index, scriptSig) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Number, _types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer), arguments);
      this.ins[index].script = scriptSig;
    }
  }, {
    key: "setWitness",
    value: function setWitness(index, witness) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].tuple(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Number, [_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Buffer]), arguments);
      this.ins[index].witness = witness;
    }
  }, {
    key: "__toBuffer",
    value: function __toBuffer(buffer, initialOffset) {
      var _ALLOW_WITNESS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!buffer) buffer = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].allocUnsafe(this.byteLength(_ALLOW_WITNESS));
      var bufferWriter = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferWriter(buffer, initialOffset || 0);
      bufferWriter.writeInt32(this.version);
      var hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
      if (hasWitnesses) {
        bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);
        bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);
      }
      bufferWriter.writeVarInt(this.ins.length);
      this.ins.forEach(function (txIn) {
        bufferWriter.writeSlice(txIn.hash);
        bufferWriter.writeUInt32(txIn.index);
        bufferWriter.writeVarSlice(txIn.script);
        bufferWriter.writeUInt32(txIn.sequence);
      });
      bufferWriter.writeVarInt(this.outs.length);
      this.outs.forEach(function (txOut) {
        if (isOutput(txOut)) {
          bufferWriter.writeUInt64(txOut.value);
        } else {
          bufferWriter.writeSlice(txOut.valueBuffer);
        }
        bufferWriter.writeVarSlice(txOut.script);
      });
      if (hasWitnesses) {
        this.ins.forEach(function (input) {
          bufferWriter.writeVector(input.witness);
        });
      }
      bufferWriter.writeUInt32(this.locktime);
      if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset);
      return buffer;
    }
  }], [{
    key: "fromBuffer",
    value: function fromBuffer(buffer, _NO_STRICT) {
      var bufferReader = new _bufferutils_js__WEBPACK_IMPORTED_MODULE_1__["default"].BufferReader(buffer);
      var tx = new Transaction();
      tx.version = bufferReader.readInt32();
      var marker = bufferReader.readUInt8();
      var flag = bufferReader.readUInt8();
      var hasWitnesses = false;
      if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG) {
        hasWitnesses = true;
      } else {
        bufferReader.offset -= 2;
      }
      var vinLen = bufferReader.readVarInt();
      for (var i = 0; i < vinLen; ++i) {
        tx.ins.push({
          hash: bufferReader.readSlice(32),
          index: bufferReader.readUInt32(),
          script: bufferReader.readVarSlice(),
          sequence: bufferReader.readUInt32(),
          witness: EMPTY_WITNESS
        });
      }
      var voutLen = bufferReader.readVarInt();
      for (var _i = 0; _i < voutLen; ++_i) {
        tx.outs.push({
          value: bufferReader.readUInt64(),
          script: bufferReader.readVarSlice()
        });
      }
      if (hasWitnesses) {
        for (var _i2 = 0; _i2 < vinLen; ++_i2) {
          tx.ins[_i2].witness = bufferReader.readVector();
        }
        if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');
      }
      tx.locktime = bufferReader.readUInt32();
      if (_NO_STRICT) return tx;
      if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');
      return tx;
    }
  }, {
    key: "fromHex",
    value: function fromHex(hex) {
      return Transaction.fromBuffer(_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from(hex, 'hex'), false);
    }
  }, {
    key: "isCoinbaseHash",
    value: function isCoinbaseHash(buffer) {
      typeforce(_types_js__WEBPACK_IMPORTED_MODULE_4__["default"].Hash256bit, buffer);
      for (var i = 0; i < 32; ++i) {
        if (buffer[i] !== 0) return false;
      }
      return true;
    }
  }]);
}();
exports.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 0xffffffff;
Transaction.SIGHASH_DEFAULT = 0x00;
Transaction.SIGHASH_ALL = 0x01;
Transaction.SIGHASH_NONE = 0x02;
Transaction.SIGHASH_SINGLE = 0x03;
Transaction.SIGHASH_ANYONECANPAY = 0x80;
Transaction.SIGHASH_OUTPUT_MASK = 0x03;
Transaction.SIGHASH_INPUT_MASK = 0x80;
Transaction.ADVANCED_TRANSACTION_MARKER = 0x00;
Transaction.ADVANCED_TRANSACTION_FLAG = 0x01;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/typeforce@1.18.0.js"
/*!***********************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/typeforce@1.18.0.js ***!
  \***********************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TfPropertyTypeError: () => (/* binding */ Ct),
/* harmony export */   TfTypeError: () => (/* binding */ Mt),
/* harmony export */   compile: () => (/* binding */ xt),
/* harmony export */   "default": () => (/* binding */ Lt)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var t = {
  Array: function (_Array) {
    function Array(_x) {
      return _Array.apply(this, arguments);
    }
    Array.toString = function () {
      return _Array.toString();
    };
    return Array;
  }(function (t) {
    return null != t && t.constructor === Array;
  }),
  Boolean: function Boolean(t) {
    return "boolean" == typeof t;
  },
  Function: function Function(t) {
    return "function" == typeof t;
  },
  Nil: function Nil(t) {
    return null == t;
  },
  Number: function Number(t) {
    return "number" == typeof t;
  },
  Object: function Object(t) {
    return "object" == _typeof(t);
  },
  String: function String(t) {
    return "string" == typeof t;
  },
  "": function _() {
    return !0;
  }
};
for (var r in t.Null = t.Nil, t) t[r].toJSON = function (t) {
  return t;
}.bind(null, r);
var n = t,
  e = n;
function o(t) {
  return t.name || t.toString().match(/function (.*?)\s*\(/)[1];
}
function i(t) {
  return e.Nil(t) ? "" : o(t.constructor);
}
function u(t, r) {
  Error.captureStackTrace && Error.captureStackTrace(t, r);
}
function f(t) {
  return e.Function(t) ? t.toJSON ? t.toJSON() : o(t) : e.Array(t) ? "Array" : t && e.Object(t) ? "Object" : void 0 !== t ? t : "";
}
function a(t, r, n) {
  var o = function (t) {
    return e.Function(t) ? "" : e.String(t) ? JSON.stringify(t) : t && e.Object(t) ? "" : t;
  }(r);
  return "Expected " + f(t) + ", got" + ("" !== n ? " " + n : "") + ("" !== o ? " " + o : "");
}
function h(t, r, n) {
  n = n || i(r), this.message = a(t, r, n), u(this, h), this.__type = t, this.__value = r, this.__valueTypeName = n;
}
function s(t, r, n, e, o) {
  t ? (o = o || i(e), this.message = function (t, r, n, e, o) {
    var i = '" of type ';
    return "key" === r && (i = '" with key type '), a('property "' + f(n) + i + f(t), e, o);
  }(t, n, r, e, o)) : this.message = 'Unexpected property "' + r + '"', u(this, h), this.__label = n, this.__property = r, this.__type = t, this.__value = e, this.__valueTypeName = o;
}
h.prototype = Object.create(Error.prototype), h.prototype.constructor = h, s.prototype = Object.create(Error.prototype), s.prototype.constructor = h;
var c = {
    TfTypeError: h,
    TfPropertyTypeError: s,
    tfCustomError: function tfCustomError(t, r) {
      return new h(t, {}, r);
    },
    tfSubError: function tfSubError(t, r, n) {
      return t instanceof s ? (r = r + "." + t.__property, t = new s(t.__type, r, t.__label, t.__value, t.__valueTypeName)) : t instanceof h && (t = new s(t.__type, r, n, t.__value, t.__valueTypeName)), u(t), t;
    },
    tfJSON: f,
    getValueTypeName: i
  },
  l = "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {},
  p = [],
  g = [],
  y = "undefined" != typeof Uint8Array ? Uint8Array : Array,
  w = !1;
function v() {
  w = !0;
  for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0; r < 64; ++r) p[r] = t[r], g[t.charCodeAt(r)] = r;
  g["-".charCodeAt(0)] = 62, g["_".charCodeAt(0)] = 63;
}
function d(t, r, n) {
  for (var e, o, i = [], u = r; u < n; u += 3) e = (t[u] << 16) + (t[u + 1] << 8) + t[u + 2], i.push(p[(o = e) >> 18 & 63] + p[o >> 12 & 63] + p[o >> 6 & 63] + p[63 & o]);
  return i.join("");
}
function E(t) {
  var r;
  w || v();
  for (var n = t.length, e = n % 3, o = "", i = [], u = 16383, f = 0, a = n - e; f < a; f += u) i.push(d(t, f, f + u > a ? a : f + u));
  return 1 === e ? (r = t[n - 1], o += p[r >> 2], o += p[r << 4 & 63], o += "==") : 2 === e && (r = (t[n - 2] << 8) + t[n - 1], o += p[r >> 10], o += p[r >> 4 & 63], o += p[r << 2 & 63], o += "="), i.push(o), i.join("");
}
function m(t, r, n, e, o) {
  var i,
    u,
    f = 8 * o - e - 1,
    a = (1 << f) - 1,
    h = a >> 1,
    s = -7,
    c = n ? o - 1 : 0,
    l = n ? -1 : 1,
    p = t[r + c];
  for (c += l, i = p & (1 << -s) - 1, p >>= -s, s += f; s > 0; i = 256 * i + t[r + c], c += l, s -= 8);
  for (u = i & (1 << -s) - 1, i >>= -s, s += e; s > 0; u = 256 * u + t[r + c], c += l, s -= 8);
  if (0 === i) i = 1 - h;else {
    if (i === a) return u ? NaN : 1 / 0 * (p ? -1 : 1);
    u += Math.pow(2, e), i -= h;
  }
  return (p ? -1 : 1) * u * Math.pow(2, i - e);
}
function b(t, r, n, e, o, i) {
  var u,
    f,
    a,
    h = 8 * i - o - 1,
    s = (1 << h) - 1,
    c = s >> 1,
    l = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    p = e ? 0 : i - 1,
    g = e ? 1 : -1,
    y = r < 0 || 0 === r && 1 / r < 0 ? 1 : 0;
  for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, u = s) : (u = Math.floor(Math.log(r) / Math.LN2), r * (a = Math.pow(2, -u)) < 1 && (u--, a *= 2), (r += u + c >= 1 ? l / a : l * Math.pow(2, 1 - c)) * a >= 2 && (u++, a /= 2), u + c >= s ? (f = 0, u = s) : u + c >= 1 ? (f = (r * a - 1) * Math.pow(2, o), u += c) : (f = r * Math.pow(2, c - 1) * Math.pow(2, o), u = 0)); o >= 8; t[n + p] = 255 & f, p += g, f /= 256, o -= 8);
  for (u = u << o | f, h += o; h > 0; t[n + p] = 255 & u, p += g, u /= 256, h -= 8);
  t[n + p - g] |= 128 * y;
}
var _ = {}.toString,
  A = Array.isArray || function (t) {
    return "[object Array]" == _.call(t);
  };
function T() {
  return S.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function R(t, r) {
  if (T() < r) throw new RangeError("Invalid typed array length");
  return S.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = S.prototype : (null === t && (t = new S(r)), t.length = r), t;
}
function S(t, r, n) {
  if (!(S.TYPED_ARRAY_SUPPORT || this instanceof S)) return new S(t, r, n);
  if ("number" == typeof t) {
    if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string");
    return U(this, t);
  }
  return P(this, t, r, n);
}
function P(t, r, n, e) {
  if ("number" == typeof r) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? function (t, r, n, e) {
    if (r.byteLength, n < 0 || r.byteLength < n) throw new RangeError("'offset' is out of bounds");
    if (r.byteLength < n + (e || 0)) throw new RangeError("'length' is out of bounds");
    r = void 0 === n && void 0 === e ? new Uint8Array(r) : void 0 === e ? new Uint8Array(r, n) : new Uint8Array(r, n, e);
    S.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = S.prototype : t = N(t, r);
    return t;
  }(t, r, n, e) : "string" == typeof r ? function (t, r, n) {
    "string" == typeof n && "" !== n || (n = "utf8");
    if (!S.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding');
    var e = 0 | Y(r, n);
    t = R(t, e);
    var o = t.write(r, n);
    o !== e && (t = t.slice(0, o));
    return t;
  }(t, r, n) : function (t, r) {
    if (I(r)) {
      var n = 0 | B(r.length);
      return 0 === (t = R(t, n)).length || r.copy(t, 0, 0, n), t;
    }
    if (r) {
      if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || (e = r.length) != e ? R(t, 0) : N(t, r);
      if ("Buffer" === r.type && A(r.data)) return N(t, r.data);
    }
    var e;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }(t, r);
}
function O(t) {
  if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
  if (t < 0) throw new RangeError('"size" argument must not be negative');
}
function U(t, r) {
  if (O(r), t = R(t, r < 0 ? 0 : 0 | B(r)), !S.TYPED_ARRAY_SUPPORT) for (var n = 0; n < r; ++n) t[n] = 0;
  return t;
}
function N(t, r) {
  var n = r.length < 0 ? 0 : 0 | B(r.length);
  t = R(t, n);
  for (var e = 0; e < n; e += 1) t[e] = 255 & r[e];
  return t;
}
function B(t) {
  if (t >= T()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + T().toString(16) + " bytes");
  return 0 | t;
}
function I(t) {
  return !(null == t || !t._isBuffer);
}
function Y(t, r) {
  if (I(t)) return t.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
  "string" != typeof t && (t = "" + t);
  var n = t.length;
  if (0 === n) return 0;
  for (var e = !1;;) switch (r) {
    case "ascii":
    case "latin1":
    case "binary":
      return n;
    case "utf8":
    case "utf-8":
    case void 0:
      return ut(t).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n;
    case "hex":
      return n >>> 1;
    case "base64":
      return ft(t).length;
    default:
      if (e) return ut(t).length;
      r = ("" + r).toLowerCase(), e = !0;
  }
}
function L(t, r, n) {
  var e = !1;
  if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
  if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
  if ((n >>>= 0) <= (r >>>= 0)) return "";
  for (t || (t = "utf8");;) switch (t) {
    case "hex":
      return G(this, r, n);
    case "utf8":
    case "utf-8":
      return $(this, r, n);
    case "ascii":
      return H(this, r, n);
    case "latin1":
    case "binary":
      return Z(this, r, n);
    case "base64":
      return V(this, r, n);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return K(this, r, n);
    default:
      if (e) throw new TypeError("Unknown encoding: " + t);
      t = (t + "").toLowerCase(), e = !0;
  }
}
function C(t, r, n) {
  var e = t[r];
  t[r] = t[n], t[n] = e;
}
function M(t, r, n, e, o) {
  if (0 === t.length) return -1;
  if ("string" == typeof n ? (e = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {
    if (o) return -1;
    n = t.length - 1;
  } else if (n < 0) {
    if (!o) return -1;
    n = 0;
  }
  if ("string" == typeof r && (r = S.from(r, e)), I(r)) return 0 === r.length ? -1 : x(t, r, n, e, o);
  if ("number" == typeof r) return r &= 255, S.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, r, n) : Uint8Array.prototype.lastIndexOf.call(t, r, n) : x(t, [r], n, e, o);
  throw new TypeError("val must be string, number or Buffer");
}
function x(t, r, n, e, o) {
  var i,
    u = 1,
    f = t.length,
    a = r.length;
  if (void 0 !== e && ("ucs2" === (e = String(e).toLowerCase()) || "ucs-2" === e || "utf16le" === e || "utf-16le" === e)) {
    if (t.length < 2 || r.length < 2) return -1;
    u = 2, f /= 2, a /= 2, n /= 2;
  }
  function h(t, r) {
    return 1 === u ? t[r] : t.readUInt16BE(r * u);
  }
  if (o) {
    var s = -1;
    for (i = n; i < f; i++) if (h(t, i) === h(r, -1 === s ? 0 : i - s)) {
      if (-1 === s && (s = i), i - s + 1 === a) return s * u;
    } else -1 !== s && (i -= i - s), s = -1;
  } else for (n + a > f && (n = f - a), i = n; i >= 0; i--) {
    for (var c = !0, l = 0; l < a; l++) if (h(t, i + l) !== h(r, l)) {
      c = !1;
      break;
    }
    if (c) return i;
  }
  return -1;
}
function D(t, r, n, e) {
  n = Number(n) || 0;
  var o = t.length - n;
  e ? (e = Number(e)) > o && (e = o) : e = o;
  var i = r.length;
  if (i % 2 != 0) throw new TypeError("Invalid hex string");
  e > i / 2 && (e = i / 2);
  for (var u = 0; u < e; ++u) {
    var f = parseInt(r.substr(2 * u, 2), 16);
    if (isNaN(f)) return u;
    t[n + u] = f;
  }
  return u;
}
function k(t, r, n, e) {
  return at(ut(r, t.length - n), t, n, e);
}
function J(t, r, n, e) {
  return at(function (t) {
    for (var r = [], n = 0; n < t.length; ++n) r.push(255 & t.charCodeAt(n));
    return r;
  }(r), t, n, e);
}
function j(t, r, n, e) {
  return J(t, r, n, e);
}
function F(t, r, n, e) {
  return at(ft(r), t, n, e);
}
function z(t, r, n, e) {
  return at(function (t, r) {
    for (var n, e, o, i = [], u = 0; u < t.length && !((r -= 2) < 0); ++u) e = (n = t.charCodeAt(u)) >> 8, o = n % 256, i.push(o), i.push(e);
    return i;
  }(r, t.length - n), t, n, e);
}
function V(t, r, n) {
  return 0 === r && n === t.length ? E(t) : E(t.slice(r, n));
}
function $(t, r, n) {
  n = Math.min(t.length, n);
  for (var e = [], o = r; o < n;) {
    var i,
      u,
      f,
      a,
      h = t[o],
      s = null,
      c = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
    if (o + c <= n) switch (c) {
      case 1:
        h < 128 && (s = h);
        break;
      case 2:
        128 == (192 & (i = t[o + 1])) && (a = (31 & h) << 6 | 63 & i) > 127 && (s = a);
        break;
      case 3:
        i = t[o + 1], u = t[o + 2], 128 == (192 & i) && 128 == (192 & u) && (a = (15 & h) << 12 | (63 & i) << 6 | 63 & u) > 2047 && (a < 55296 || a > 57343) && (s = a);
        break;
      case 4:
        i = t[o + 1], u = t[o + 2], f = t[o + 3], 128 == (192 & i) && 128 == (192 & u) && 128 == (192 & f) && (a = (15 & h) << 18 | (63 & i) << 12 | (63 & u) << 6 | 63 & f) > 65535 && a < 1114112 && (s = a);
    }
    null === s ? (s = 65533, c = 1) : s > 65535 && (s -= 65536, e.push(s >>> 10 & 1023 | 55296), s = 56320 | 1023 & s), e.push(s), o += c;
  }
  return function (t) {
    var r = t.length;
    if (r <= q) return String.fromCharCode.apply(String, t);
    var n = "",
      e = 0;
    for (; e < r;) n += String.fromCharCode.apply(String, t.slice(e, e += q));
    return n;
  }(e);
}
S.TYPED_ARRAY_SUPPORT = void 0 === l.TYPED_ARRAY_SUPPORT || l.TYPED_ARRAY_SUPPORT, T(), S.poolSize = 8192, S._augment = function (t) {
  return t.__proto__ = S.prototype, t;
}, S.from = function (t, r, n) {
  return P(null, t, r, n);
}, S.TYPED_ARRAY_SUPPORT && (S.prototype.__proto__ = Uint8Array.prototype, S.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && S[Symbol.species]), S.alloc = function (t, r, n) {
  return function (t, r, n, e) {
    return O(r), r <= 0 ? R(t, r) : void 0 !== n ? "string" == typeof e ? R(t, r).fill(n, e) : R(t, r).fill(n) : R(t, r);
  }(null, t, r, n);
}, S.allocUnsafe = function (t) {
  return U(null, t);
}, S.allocUnsafeSlow = function (t) {
  return U(null, t);
}, S.isBuffer = function (t) {
  return null != t && (!!t._isBuffer || ht(t) || function (t) {
    return "function" == typeof t.readFloatLE && "function" == typeof t.slice && ht(t.slice(0, 0));
  }(t));
}, S.compare = function (t, r) {
  if (!I(t) || !I(r)) throw new TypeError("Arguments must be Buffers");
  if (t === r) return 0;
  for (var n = t.length, e = r.length, o = 0, i = Math.min(n, e); o < i; ++o) if (t[o] !== r[o]) {
    n = t[o], e = r[o];
    break;
  }
  return n < e ? -1 : e < n ? 1 : 0;
}, S.isEncoding = function (t) {
  switch (String(t).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
}, S.concat = function (t, r) {
  if (!A(t)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === t.length) return S.alloc(0);
  var n;
  if (void 0 === r) for (r = 0, n = 0; n < t.length; ++n) r += t[n].length;
  var e = S.allocUnsafe(r),
    o = 0;
  for (n = 0; n < t.length; ++n) {
    var i = t[n];
    if (!I(i)) throw new TypeError('"list" argument must be an Array of Buffers');
    i.copy(e, o), o += i.length;
  }
  return e;
}, S.byteLength = Y, S.prototype._isBuffer = !0, S.prototype.swap16 = function () {
  var t = this.length;
  if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r = 0; r < t; r += 2) C(this, r, r + 1);
  return this;
}, S.prototype.swap32 = function () {
  var t = this.length;
  if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r = 0; r < t; r += 4) C(this, r, r + 3), C(this, r + 1, r + 2);
  return this;
}, S.prototype.swap64 = function () {
  var t = this.length;
  if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r = 0; r < t; r += 8) C(this, r, r + 7), C(this, r + 1, r + 6), C(this, r + 2, r + 5), C(this, r + 3, r + 4);
  return this;
}, S.prototype.toString = function () {
  var t = 0 | this.length;
  return 0 === t ? "" : 0 === arguments.length ? $(this, 0, t) : L.apply(this, arguments);
}, S.prototype.equals = function (t) {
  if (!I(t)) throw new TypeError("Argument must be a Buffer");
  return this === t || 0 === S.compare(this, t);
}, S.prototype.inspect = function () {
  var t = "";
  return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">";
}, S.prototype.compare = function (t, r, n, e, o) {
  if (!I(t)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === r && (r = 0), void 0 === n && (n = t ? t.length : 0), void 0 === e && (e = 0), void 0 === o && (o = this.length), r < 0 || n > t.length || e < 0 || o > this.length) throw new RangeError("out of range index");
  if (e >= o && r >= n) return 0;
  if (e >= o) return -1;
  if (r >= n) return 1;
  if (this === t) return 0;
  for (var i = (o >>>= 0) - (e >>>= 0), u = (n >>>= 0) - (r >>>= 0), f = Math.min(i, u), a = this.slice(e, o), h = t.slice(r, n), s = 0; s < f; ++s) if (a[s] !== h[s]) {
    i = a[s], u = h[s];
    break;
  }
  return i < u ? -1 : u < i ? 1 : 0;
}, S.prototype.includes = function (t, r, n) {
  return -1 !== this.indexOf(t, r, n);
}, S.prototype.indexOf = function (t, r, n) {
  return M(this, t, r, n, !0);
}, S.prototype.lastIndexOf = function (t, r, n) {
  return M(this, t, r, n, !1);
}, S.prototype.write = function (t, r, n, e) {
  if (void 0 === r) e = "utf8", n = this.length, r = 0;else if (void 0 === n && "string" == typeof r) e = r, n = this.length, r = 0;else {
    if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    r |= 0, isFinite(n) ? (n |= 0, void 0 === e && (e = "utf8")) : (e = n, n = void 0);
  }
  var o = this.length - r;
  if ((void 0 === n || n > o) && (n = o), t.length > 0 && (n < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  e || (e = "utf8");
  for (var i = !1;;) switch (e) {
    case "hex":
      return D(this, t, r, n);
    case "utf8":
    case "utf-8":
      return k(this, t, r, n);
    case "ascii":
      return J(this, t, r, n);
    case "latin1":
    case "binary":
      return j(this, t, r, n);
    case "base64":
      return F(this, t, r, n);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return z(this, t, r, n);
    default:
      if (i) throw new TypeError("Unknown encoding: " + e);
      e = ("" + e).toLowerCase(), i = !0;
  }
}, S.prototype.toJSON = function () {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
var q = 4096;
function H(t, r, n) {
  var e = "";
  n = Math.min(t.length, n);
  for (var o = r; o < n; ++o) e += String.fromCharCode(127 & t[o]);
  return e;
}
function Z(t, r, n) {
  var e = "";
  n = Math.min(t.length, n);
  for (var o = r; o < n; ++o) e += String.fromCharCode(t[o]);
  return e;
}
function G(t, r, n) {
  var e = t.length;
  (!r || r < 0) && (r = 0), (!n || n < 0 || n > e) && (n = e);
  for (var o = "", i = r; i < n; ++i) o += it(t[i]);
  return o;
}
function K(t, r, n) {
  for (var e = t.slice(r, n), o = "", i = 0; i < e.length; i += 2) o += String.fromCharCode(e[i] + 256 * e[i + 1]);
  return o;
}
function Q(t, r, n) {
  if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
  if (t + r > n) throw new RangeError("Trying to access beyond buffer length");
}
function W(t, r, n, e, o, i) {
  if (!I(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r > o || r < i) throw new RangeError('"value" argument is out of bounds');
  if (n + e > t.length) throw new RangeError("Index out of range");
}
function X(t, r, n, e) {
  r < 0 && (r = 65535 + r + 1);
  for (var o = 0, i = Math.min(t.length - n, 2); o < i; ++o) t[n + o] = (r & 255 << 8 * (e ? o : 1 - o)) >>> 8 * (e ? o : 1 - o);
}
function tt(t, r, n, e) {
  r < 0 && (r = 4294967295 + r + 1);
  for (var o = 0, i = Math.min(t.length - n, 4); o < i; ++o) t[n + o] = r >>> 8 * (e ? o : 3 - o) & 255;
}
function rt(t, r, n, e, o, i) {
  if (n + e > t.length) throw new RangeError("Index out of range");
  if (n < 0) throw new RangeError("Index out of range");
}
function nt(t, r, n, e, o) {
  return o || rt(t, 0, n, 4), b(t, r, n, e, 23, 4), n + 4;
}
function et(t, r, n, e, o) {
  return o || rt(t, 0, n, 8), b(t, r, n, e, 52, 8), n + 8;
}
S.prototype.slice = function (t, r) {
  var n,
    e = this.length;
  if ((t = ~~t) < 0 ? (t += e) < 0 && (t = 0) : t > e && (t = e), (r = void 0 === r ? e : ~~r) < 0 ? (r += e) < 0 && (r = 0) : r > e && (r = e), r < t && (r = t), S.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, r)).__proto__ = S.prototype;else {
    var o = r - t;
    n = new S(o, void 0);
    for (var i = 0; i < o; ++i) n[i] = this[i + t];
  }
  return n;
}, S.prototype.readUIntLE = function (t, r, n) {
  t |= 0, r |= 0, n || Q(t, r, this.length);
  for (var e = this[t], o = 1, i = 0; ++i < r && (o *= 256);) e += this[t + i] * o;
  return e;
}, S.prototype.readUIntBE = function (t, r, n) {
  t |= 0, r |= 0, n || Q(t, r, this.length);
  for (var e = this[t + --r], o = 1; r > 0 && (o *= 256);) e += this[t + --r] * o;
  return e;
}, S.prototype.readUInt8 = function (t, r) {
  return r || Q(t, 1, this.length), this[t];
}, S.prototype.readUInt16LE = function (t, r) {
  return r || Q(t, 2, this.length), this[t] | this[t + 1] << 8;
}, S.prototype.readUInt16BE = function (t, r) {
  return r || Q(t, 2, this.length), this[t] << 8 | this[t + 1];
}, S.prototype.readUInt32LE = function (t, r) {
  return r || Q(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
}, S.prototype.readUInt32BE = function (t, r) {
  return r || Q(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
}, S.prototype.readIntLE = function (t, r, n) {
  t |= 0, r |= 0, n || Q(t, r, this.length);
  for (var e = this[t], o = 1, i = 0; ++i < r && (o *= 256);) e += this[t + i] * o;
  return e >= (o *= 128) && (e -= Math.pow(2, 8 * r)), e;
}, S.prototype.readIntBE = function (t, r, n) {
  t |= 0, r |= 0, n || Q(t, r, this.length);
  for (var e = r, o = 1, i = this[t + --e]; e > 0 && (o *= 256);) i += this[t + --e] * o;
  return i >= (o *= 128) && (i -= Math.pow(2, 8 * r)), i;
}, S.prototype.readInt8 = function (t, r) {
  return r || Q(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
}, S.prototype.readInt16LE = function (t, r) {
  r || Q(t, 2, this.length);
  var n = this[t] | this[t + 1] << 8;
  return 32768 & n ? 4294901760 | n : n;
}, S.prototype.readInt16BE = function (t, r) {
  r || Q(t, 2, this.length);
  var n = this[t + 1] | this[t] << 8;
  return 32768 & n ? 4294901760 | n : n;
}, S.prototype.readInt32LE = function (t, r) {
  return r || Q(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
}, S.prototype.readInt32BE = function (t, r) {
  return r || Q(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
}, S.prototype.readFloatLE = function (t, r) {
  return r || Q(t, 4, this.length), m(this, t, !0, 23, 4);
}, S.prototype.readFloatBE = function (t, r) {
  return r || Q(t, 4, this.length), m(this, t, !1, 23, 4);
}, S.prototype.readDoubleLE = function (t, r) {
  return r || Q(t, 8, this.length), m(this, t, !0, 52, 8);
}, S.prototype.readDoubleBE = function (t, r) {
  return r || Q(t, 8, this.length), m(this, t, !1, 52, 8);
}, S.prototype.writeUIntLE = function (t, r, n, e) {
  (t = +t, r |= 0, n |= 0, e) || W(this, t, r, n, Math.pow(2, 8 * n) - 1, 0);
  var o = 1,
    i = 0;
  for (this[r] = 255 & t; ++i < n && (o *= 256);) this[r + i] = t / o & 255;
  return r + n;
}, S.prototype.writeUIntBE = function (t, r, n, e) {
  (t = +t, r |= 0, n |= 0, e) || W(this, t, r, n, Math.pow(2, 8 * n) - 1, 0);
  var o = n - 1,
    i = 1;
  for (this[r + o] = 255 & t; --o >= 0 && (i *= 256);) this[r + o] = t / i & 255;
  return r + n;
}, S.prototype.writeUInt8 = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 1, 255, 0), S.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1;
}, S.prototype.writeUInt16LE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 2, 65535, 0), S.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : X(this, t, r, !0), r + 2;
}, S.prototype.writeUInt16BE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 2, 65535, 0), S.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : X(this, t, r, !1), r + 2;
}, S.prototype.writeUInt32LE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 4, 4294967295, 0), S.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : tt(this, t, r, !0), r + 4;
}, S.prototype.writeUInt32BE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 4, 4294967295, 0), S.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : tt(this, t, r, !1), r + 4;
}, S.prototype.writeIntLE = function (t, r, n, e) {
  if (t = +t, r |= 0, !e) {
    var o = Math.pow(2, 8 * n - 1);
    W(this, t, r, n, o - 1, -o);
  }
  var i = 0,
    u = 1,
    f = 0;
  for (this[r] = 255 & t; ++i < n && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + i - 1] && (f = 1), this[r + i] = (t / u | 0) - f & 255;
  return r + n;
}, S.prototype.writeIntBE = function (t, r, n, e) {
  if (t = +t, r |= 0, !e) {
    var o = Math.pow(2, 8 * n - 1);
    W(this, t, r, n, o - 1, -o);
  }
  var i = n - 1,
    u = 1,
    f = 0;
  for (this[r + i] = 255 & t; --i >= 0 && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + i + 1] && (f = 1), this[r + i] = (t / u | 0) - f & 255;
  return r + n;
}, S.prototype.writeInt8 = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 1, 127, -128), S.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1;
}, S.prototype.writeInt16LE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 2, 32767, -32768), S.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : X(this, t, r, !0), r + 2;
}, S.prototype.writeInt16BE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 2, 32767, -32768), S.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : X(this, t, r, !1), r + 2;
}, S.prototype.writeInt32LE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 4, 2147483647, -2147483648), S.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : tt(this, t, r, !0), r + 4;
}, S.prototype.writeInt32BE = function (t, r, n) {
  return t = +t, r |= 0, n || W(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), S.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : tt(this, t, r, !1), r + 4;
}, S.prototype.writeFloatLE = function (t, r, n) {
  return nt(this, t, r, !0, n);
}, S.prototype.writeFloatBE = function (t, r, n) {
  return nt(this, t, r, !1, n);
}, S.prototype.writeDoubleLE = function (t, r, n) {
  return et(this, t, r, !0, n);
}, S.prototype.writeDoubleBE = function (t, r, n) {
  return et(this, t, r, !1, n);
}, S.prototype.copy = function (t, r, n, e) {
  if (n || (n = 0), e || 0 === e || (e = this.length), r >= t.length && (r = t.length), r || (r = 0), e > 0 && e < n && (e = n), e === n) return 0;
  if (0 === t.length || 0 === this.length) return 0;
  if (r < 0) throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
  if (e < 0) throw new RangeError("sourceEnd out of bounds");
  e > this.length && (e = this.length), t.length - r < e - n && (e = t.length - r + n);
  var o,
    i = e - n;
  if (this === t && n < r && r < e) for (o = i - 1; o >= 0; --o) t[o + r] = this[o + n];else if (i < 1e3 || !S.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o) t[o + r] = this[o + n];else Uint8Array.prototype.set.call(t, this.subarray(n, n + i), r);
  return i;
}, S.prototype.fill = function (t, r, n, e) {
  if ("string" == typeof t) {
    if ("string" == typeof r ? (e = r, r = 0, n = this.length) : "string" == typeof n && (e = n, n = this.length), 1 === t.length) {
      var o = t.charCodeAt(0);
      o < 256 && (t = o);
    }
    if (void 0 !== e && "string" != typeof e) throw new TypeError("encoding must be a string");
    if ("string" == typeof e && !S.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
  } else "number" == typeof t && (t &= 255);
  if (r < 0 || this.length < r || this.length < n) throw new RangeError("Out of range index");
  if (n <= r) return this;
  var i;
  if (r >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (i = r; i < n; ++i) this[i] = t;else {
    var u = I(t) ? t : ut(new S(t, e).toString()),
      f = u.length;
    for (i = 0; i < n - r; ++i) this[i + r] = u[i % f];
  }
  return this;
};
var ot = /[^+\/0-9A-Za-z-_]/g;
function it(t) {
  return t < 16 ? "0" + t.toString(16) : t.toString(16);
}
function ut(t, r) {
  var n;
  r = r || 1 / 0;
  for (var e = t.length, o = null, i = [], u = 0; u < e; ++u) {
    if ((n = t.charCodeAt(u)) > 55295 && n < 57344) {
      if (!o) {
        if (n > 56319) {
          (r -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        if (u + 1 === e) {
          (r -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        o = n;
        continue;
      }
      if (n < 56320) {
        (r -= 3) > -1 && i.push(239, 191, 189), o = n;
        continue;
      }
      n = 65536 + (o - 55296 << 10 | n - 56320);
    } else o && (r -= 3) > -1 && i.push(239, 191, 189);
    if (o = null, n < 128) {
      if ((r -= 1) < 0) break;
      i.push(n);
    } else if (n < 2048) {
      if ((r -= 2) < 0) break;
      i.push(n >> 6 | 192, 63 & n | 128);
    } else if (n < 65536) {
      if ((r -= 3) < 0) break;
      i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
    } else {
      if (!(n < 1114112)) throw new Error("Invalid code point");
      if ((r -= 4) < 0) break;
      i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
    }
  }
  return i;
}
function ft(t) {
  return function (t) {
    var r, n, e, o, i, u;
    w || v();
    var f = t.length;
    if (f % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    i = "=" === t[f - 2] ? 2 : "=" === t[f - 1] ? 1 : 0, u = new y(3 * f / 4 - i), e = i > 0 ? f - 4 : f;
    var a = 0;
    for (r = 0, n = 0; r < e; r += 4, n += 3) o = g[t.charCodeAt(r)] << 18 | g[t.charCodeAt(r + 1)] << 12 | g[t.charCodeAt(r + 2)] << 6 | g[t.charCodeAt(r + 3)], u[a++] = o >> 16 & 255, u[a++] = o >> 8 & 255, u[a++] = 255 & o;
    return 2 === i ? (o = g[t.charCodeAt(r)] << 2 | g[t.charCodeAt(r + 1)] >> 4, u[a++] = 255 & o) : 1 === i && (o = g[t.charCodeAt(r)] << 10 | g[t.charCodeAt(r + 1)] << 4 | g[t.charCodeAt(r + 2)] >> 2, u[a++] = o >> 8 & 255, u[a++] = 255 & o), u;
  }(function (t) {
    if ((t = function (t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
    }(t).replace(ot, "")).length < 2) return "";
    for (; t.length % 4 != 0;) t += "=";
    return t;
  }(t));
}
function at(t, r, n, e) {
  for (var o = 0; o < e && !(o + n >= r.length || o >= t.length); ++o) r[o + n] = t[o];
  return o;
}
function ht(t) {
  return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);
}
var st = n,
  ct = c;
function lt(t) {
  return S.isBuffer(t);
}
function pt(t) {
  return "string" == typeof t && /^([0-9a-f]{2})+$/i.test(t);
}
function gt(t, r) {
  var n = t.toJSON();
  function e(e) {
    if (!t(e)) return !1;
    if (e.length === r) return !0;
    throw ct.tfCustomError(n + "(Length: " + r + ")", n + "(Length: " + e.length + ")");
  }
  return e.toJSON = function () {
    return n;
  }, e;
}
var yt = gt.bind(null, st.Array),
  wt = gt.bind(null, lt),
  vt = gt.bind(null, pt),
  dt = gt.bind(null, st.String);
var Et = Math.pow(2, 53) - 1;
var mt = {
  ArrayN: yt,
  Buffer: lt,
  BufferN: wt,
  Finite: function Finite(t) {
    return "number" == typeof t && isFinite(t);
  },
  Hex: pt,
  HexN: vt,
  Int8: function Int8(t) {
    return t << 24 >> 24 === t;
  },
  Int16: function Int16(t) {
    return t << 16 >> 16 === t;
  },
  Int32: function Int32(t) {
    return (0 | t) === t;
  },
  Int53: function Int53(t) {
    return "number" == typeof t && t >= -Et && t <= Et && Math.floor(t) === t;
  },
  Range: function Range(t, r, n) {
    function e(e, o) {
      return n(e, o) && e > t && e < r;
    }
    return n = n || st.Number, e.toJSON = function () {
      return "".concat(n.toJSON(), " between [").concat(t, ", ").concat(r, "]");
    }, e;
  },
  StringN: dt,
  UInt8: function UInt8(t) {
    return (255 & t) === t;
  },
  UInt16: function UInt16(t) {
    return (65535 & t) === t;
  },
  UInt32: function UInt32(t) {
    return t >>> 0 === t;
  },
  UInt53: function UInt53(t) {
    return "number" == typeof t && t >= 0 && t <= Et && Math.floor(t) === t;
  }
};
for (var bt in mt) mt[bt].toJSON = function (t) {
  return t;
}.bind(null, bt);
var _t = mt,
  At = n,
  Tt = c.tfJSON,
  Rt = c.TfTypeError,
  St = c.TfPropertyTypeError,
  Pt = c.tfSubError,
  Ot = c.getValueTypeName,
  Ut = {
    arrayOf: function arrayOf(t, r) {
      function n(n, e) {
        return !!At.Array(n) && !At.Nil(n) && !(void 0 !== r.minLength && n.length < r.minLength) && !(void 0 !== r.maxLength && n.length > r.maxLength) && (void 0 === r.length || n.length === r.length) && n.every(function (r, n) {
          try {
            return Bt(t, r, e);
          } catch (t) {
            throw Pt(t, n);
          }
        });
      }
      return t = Nt(t), r = r || {}, n.toJSON = function () {
        var n = "[" + Tt(t) + "]";
        return void 0 !== r.length ? n += "{" + r.length + "}" : void 0 === r.minLength && void 0 === r.maxLength || (n += "{" + (void 0 === r.minLength ? 0 : r.minLength) + "," + (void 0 === r.maxLength ? 1 / 0 : r.maxLength) + "}"), n;
      }, n;
    },
    maybe: function t(r) {
      function n(n, e) {
        return At.Nil(n) || r(n, e, t);
      }
      return r = Nt(r), n.toJSON = function () {
        return "?" + Tt(r);
      }, n;
    },
    map: function map(t, r) {
      function n(n, e) {
        if (!At.Object(n)) return !1;
        if (At.Nil(n)) return !1;
        for (var o in n) {
          try {
            r && Bt(r, o, e);
          } catch (t) {
            throw Pt(t, o, "key");
          }
          try {
            var i = n[o];
            Bt(t, i, e);
          } catch (t) {
            throw Pt(t, o);
          }
        }
        return !0;
      }
      return t = Nt(t), r && (r = Nt(r)), n.toJSON = r ? function () {
        return "{" + Tt(r) + ": " + Tt(t) + "}";
      } : function () {
        return "{" + Tt(t) + "}";
      }, n;
    },
    object: function object(t) {
      var r = {};
      for (var n in t) r[n] = Nt(t[n]);
      function e(t, n) {
        if (!At.Object(t)) return !1;
        if (At.Nil(t)) return !1;
        var e;
        try {
          for (e in r) {
            Bt(r[e], t[e], n);
          }
        } catch (t) {
          throw Pt(t, e);
        }
        if (n) for (e in t) if (!r[e]) throw new St(void 0, e);
        return !0;
      }
      return e.toJSON = function () {
        return Tt(r);
      }, e;
    },
    anyOf: function anyOf() {
      var t = [].slice.call(arguments).map(Nt);
      function r(r, n) {
        return t.some(function (t) {
          try {
            return Bt(t, r, n);
          } catch (t) {
            return !1;
          }
        });
      }
      return r.toJSON = function () {
        return t.map(Tt).join("|");
      }, r;
    },
    allOf: function allOf() {
      var t = [].slice.call(arguments).map(Nt);
      function r(r, n) {
        return t.every(function (t) {
          try {
            return Bt(t, r, n);
          } catch (t) {
            return !1;
          }
        });
      }
      return r.toJSON = function () {
        return t.map(Tt).join(" & ");
      }, r;
    },
    quacksLike: function quacksLike(t) {
      function r(r) {
        return t === Ot(r);
      }
      return r.toJSON = function () {
        return t;
      }, r;
    },
    tuple: function tuple() {
      var t = [].slice.call(arguments).map(Nt);
      function r(r, n) {
        return !At.Nil(r) && !At.Nil(r.length) && (!n || r.length === t.length) && t.every(function (t, e) {
          try {
            return Bt(t, r[e], n);
          } catch (t) {
            throw Pt(t, e);
          }
        });
      }
      return r.toJSON = function () {
        return "(" + t.map(Tt).join(", ") + ")";
      }, r;
    },
    value: function value(t) {
      function r(r) {
        return r === t;
      }
      return r.toJSON = function () {
        return t;
      }, r;
    }
  };
function Nt(t) {
  if (At.String(t)) return "?" === t[0] ? Ut.maybe(t.slice(1)) : At[t] || Ut.quacksLike(t);
  if (t && At.Object(t)) {
    if (At.Array(t)) {
      if (1 !== t.length) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return Ut.arrayOf(t[0]);
    }
    return Ut.object(t);
  }
  return At.Function(t) ? t : Ut.value(t);
}
function Bt(t, r, n, e) {
  if (At.Function(t)) {
    if (t(r, n)) return !0;
    throw new Rt(e || t, r);
  }
  return Bt(Nt(t), r, n);
}
for (var It in Ut.oneOf = Ut.anyOf, At) Bt[It] = At[It];
for (It in Ut) Bt[It] = Ut[It];
var Yt = _t;
for (It in Yt) Bt[It] = Yt[It];
Bt.compile = Nt, Bt.TfTypeError = Rt, Bt.TfPropertyTypeError = St;
var Lt = Bt,
  Ct = Lt.TfPropertyTypeError,
  Mt = Lt.TfTypeError,
  xt = Lt.compile;


/***/ },

/***/ "./src/analyze/crypto/bitcoin/v6/types.js"
/*!************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/types.js ***!
  \************************************************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./src/analyze/crypto/bitcoin/v6/buffer.js");
/* harmony import */ var _typeforce_1_18_0_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typeforce@1.18.0.js */ "./src/analyze/crypto/bitcoin/v6/typeforce@1.18.0.js");


var exports = {};
exports.typeforce = _typeforce_1_18_0_js__WEBPACK_IMPORTED_MODULE_1__["default"];
var ZERO32 = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].alloc(32, 0);
var EC_P = _buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex');
function stacksEqual(a, b) {
  if (a.length !== b.length) return false;
  return a.every(function (x, i) {
    return x.equals(b[i]);
  });
}
exports.stacksEqual = stacksEqual;
function isPoint(p) {
  if (!_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(p)) return false;
  if (p.length < 33) return false;
  var t = p[0];
  var x = p.slice(1, 33);
  if (x.compare(ZERO32) === 0) return false;
  if (x.compare(EC_P) >= 0) return false;
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    return true;
  }
  var y = p.slice(33);
  if (y.compare(ZERO32) === 0) return false;
  if (y.compare(EC_P) >= 0) return false;
  if (t === 0x04 && p.length === 65) return true;
  return false;
}
exports.isPoint = isPoint;
var SATOSHI_MAX = 21 * 1e14;
function Satoshi(value) {
  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
}
exports.Satoshi = Satoshi;
exports.TAPLEAF_VERSION_MASK = 0xfe;
function isTapleaf(o) {
  if (!o || !('output' in o)) return false;
  if (!_buffer_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(o.output)) return false;
  if (o.version !== undefined) return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;
  return true;
}
exports.isTapleaf = isTapleaf;
function isTaptree(scriptTree) {
  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
  if (scriptTree.length !== 2) return false;
  return scriptTree.every(function (t) {
    return isTaptree(t);
  });
}
exports.isTaptree = isTaptree;
exports.Buffer256bit = exports.typeforce.BufferN(32);
exports.Hash160bit = exports.typeforce.BufferN(20);
exports.Hash256bit = exports.typeforce.BufferN(32);
exports.Number = exports.typeforce.Number;
exports.Array = exports.typeforce.Array;
exports.Boolean = exports.typeforce.Boolean;
exports.String = exports.typeforce.String;
exports.Buffer = exports.typeforce.Buffer;
exports.Hex = exports.typeforce.Hex;
exports.maybe = exports.typeforce.maybe;
exports.tuple = exports.typeforce.tuple;
exports.UInt8 = exports.typeforce.UInt8;
exports.UInt32 = exports.typeforce.UInt32;
exports.Function = exports.typeforce.Function;
exports.BufferN = exports.typeforce.BufferN;
exports.Null = exports.typeforce.Null;
exports.oneOf = exports.typeforce.oneOf;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);

/***/ }

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/    // Check if module is in cache
/******/    var cachedModule = __webpack_module_cache__[moduleId];
/******/    if (cachedModule !== undefined) {
/******/        return cachedModule.exports;
/******/    }
/******/    // Check if module exists (development only)
/******/    if (__webpack_modules__[moduleId] === undefined) {
/******/        var e = new Error("Cannot find module '" + moduleId + "'");
/******/        e.code = 'MODULE_NOT_FOUND';
/******/        throw e;
/******/    }
/******/    // Create a new module (and put it into the cache)
/******/    var module = __webpack_module_cache__[moduleId] = {
/******/        // no module.id needed
/******/        // no module.loaded needed
/******/        exports: {}
/******/    };
/******/ 
/******/    // Execute the module function
/******/    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/    // Return the exports of the module
/******/    return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/    // define getter functions for harmony exports
/******/    __webpack_require__.d = (exports, definition) => {
/******/        for(var key in definition) {
/******/            if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/                Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/            }
/******/        }
/******/    };
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/    __webpack_require__.g = (function() {
/******/        if (typeof globalThis === 'object') return globalThis;
/******/        try {
/******/            return this || new Function('return this')();
/******/        } catch (e) {
/******/            if (typeof window === 'object') return window;
/******/        }
/******/    })();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/    __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/    // define __esModule on exports
/******/    __webpack_require__.r = (exports) => {
/******/        if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/            Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/        }
/******/        Object.defineProperty(exports, '__esModule', { value: true });
/******/    };
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!************************************************!*\
  !*** ./src/analyze/crypto/bitcoin/v6/index.js ***!
  \************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _payments_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./payments/index.js */ "./src/analyze/crypto/bitcoin/v6/payments/index.js");
/* harmony import */ var _crypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crypto.js */ "./src/analyze/crypto/bitcoin/v6/crypto.js");
/* harmony import */ var _networks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./networks.js */ "./src/analyze/crypto/bitcoin/v6/networks.js");
/* harmony import */ var _psbt_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./psbt.js */ "./src/analyze/crypto/bitcoin/v6/psbt.js");
/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./transaction.js */ "./src/analyze/crypto/bitcoin/v6/transaction.js");
/* harmony import */ var _ecc_lib_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ecc_lib.js */ "./src/analyze/crypto/bitcoin/v6/ecc_lib.js");






var exports = {};
exports.payments = _payments_index_js__WEBPACK_IMPORTED_MODULE_0__["default"];
exports.networks = _networks_js__WEBPACK_IMPORTED_MODULE_2__["default"];
exports.crypto = _crypto_js__WEBPACK_IMPORTED_MODULE_1__["default"];
Object.defineProperty(exports, 'Psbt', {
  enumerable: true,
  get: function get() {
    return _psbt_js__WEBPACK_IMPORTED_MODULE_3__["default"].Psbt;
  }
});
Object.defineProperty(exports, 'Transaction', {
  enumerable: true,
  get: function get() {
    return _transaction_js__WEBPACK_IMPORTED_MODULE_4__["default"].Transaction;
  }
});
Object.defineProperty(exports, 'initEccLib', {
  enumerable: true,
  get: function get() {
    return _ecc_lib_js__WEBPACK_IMPORTED_MODULE_5__["default"].initEccLib;
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (exports);
})();

bitcoin = __webpack_exports__["default"];

        </script>
        <script type="text/javascript">
            /**
             * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
             * Original file: /npm/ecpair@3.0.0/src/esm/index.js
             *
             * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
             */
            var ECPairFactory = (() => {
                const networks = bitcoin.networks;
                const v = valibot;

                const Uint32Schema = v.pipe(
                    v.number(),
                    v.integer(),
                    v.minValue(0),
                    v.maxValue(0xffffffff),
                );
                const Uint8Schema = v.pipe(
                    v.number(),
                    v.integer(),
                    v.minValue(0),
                    v.maxValue(0xff),
                );
                const types = {
                    NetworkSchema: v.object({
                    messagePrefix: v.union([v.string(), v.instance(Uint8Array)]),
                    bech32: v.string(),
                    bip32: v.object({
                    public: Uint32Schema,
                    private: Uint32Schema,
                    }),
                    pubKeyHash: Uint8Schema,
                    scriptHash: Uint8Schema,
                    wif: Uint8Schema,
                    }),
                    Buffer256Bit: v.pipe(v.instance(Uint8Array), v.length(32))
                };
                const h = (hex) => Buffer.from(hex, 'hex');
                function assert(bool) {
                  if (!bool) throw new Error('ecc library invalid');
                }
                function testEcc(ecc) {
                  assert(
                    ecc.isPoint(
                      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                    ),
                  );
                  assert(
                    !ecc.isPoint(
                      h('030000000000000000000000000000000000000000000000000000000000000005'),
                    ),
                  );
                  assert(
                    ecc.isPrivate(
                      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                    ),
                  );
                  // order - 1
                  assert(
                    ecc.isPrivate(
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
                    ),
                  );
                  // 0
                  assert(
                    !ecc.isPrivate(
                      h('0000000000000000000000000000000000000000000000000000000000000000'),
                    ),
                  );
                  // order
                  assert(
                    !ecc.isPrivate(
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
                    ),
                  );
                  // order + 1
                  assert(
                    !ecc.isPrivate(
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142'),
                    ),
                  );
                  // 1 + 0 == 1
                  assert(
                    Buffer.from(
                      ecc.privateAdd(
                        h('0000000000000000000000000000000000000000000000000000000000000001'),
                        h('0000000000000000000000000000000000000000000000000000000000000000'),
                      ),
                    ).equals(
                      h('0000000000000000000000000000000000000000000000000000000000000001'),
                    ),
                  );
                  // -3 + 3 == 0
                  assert(
                    ecc.privateAdd(
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
                      h('0000000000000000000000000000000000000000000000000000000000000003'),
                    ) === null,
                  );
                  assert(
                    Buffer.from(
                      ecc.privateAdd(
                        h('e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500'),
                        h('b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665'),
                      ),
                    ).equals(
                      h('9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.privateNegate(
                        h('0000000000000000000000000000000000000000000000000000000000000001'),
                      ),
                    ).equals(
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.privateNegate(
                        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'),
                      ),
                    ).equals(
                      h('0000000000000000000000000000000000000000000000000000000000000003'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.privateNegate(
                        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
                      ),
                    ).equals(
                      h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.pointCompress(
                        h(
                          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                        ),
                        true,
                      ),
                    ).equals(
                      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.pointCompress(
                        h(
                          '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                        ),
                        false,
                      ),
                    ).equals(
                      h(
                        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                      ),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.pointCompress(
                        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                        true,
                      ),
                    ).equals(
                      h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.pointCompress(
                        h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                        false,
                      ),
                    ).equals(
                      h(
                        '0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
                      ),
                    ),
                  );
                  assert(
                    Buffer.from(
                      ecc.pointFromScalar(
                        h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af'),
                      ),
                    ).equals(
                      h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99'),
                    ),
                  );
                  assert(
                    ecc.xOnlyPointAddTweak(
                      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                      h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
                    ) === null,
                  );
                  let xOnlyRes = ecc.xOnlyPointAddTweak(
                    h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'),
                    h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'),
                  );
                  assert(
                    Buffer.from(xOnlyRes.xOnlyPubkey).equals(
                      h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf'),
                    ) && xOnlyRes.parity === 1,
                  );
                  xOnlyRes = ecc.xOnlyPointAddTweak(
                    h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'),
                    h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'),
                  );
                  assert(
                    Buffer.from(xOnlyRes.xOnlyPubkey).equals(
                      h('9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c'),
                    ) && xOnlyRes.parity === 0,
                  );
                  assert(
                    Buffer.from(
                      ecc.sign(
                        h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
                        h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140'),
                      ),
                    ).equals(
                      h(
                        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
                      ),
                    ),
                  );
                  assert(
                    ecc.verify(
                      h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'),
                      h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
                      h(
                        '54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5',
                      ),
                    ),
                  );
                  if (ecc.signSchnorr) {
                    assert(
                      Buffer.from(
                        ecc.signSchnorr(
                          h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
                          h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'),
                          h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906'),
                        ),
                      ).equals(
                        h(
                          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
                        ),
                      ),
                    );
                  }
                  if (ecc.verifySchnorr) {
                    assert(
                      ecc.verifySchnorr(
                        h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'),
                        h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'),
                        h(
                          '5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7',
                        ),
                      ),
                    );
                  }
                }

                const tools = {};
                tools.writeUInt32 = function (buffer, offset, value, littleEndian) {
                    if (offset + 4 > buffer.length) {
                        throw new Error("Offset is outside the bounds of Uint8Array");
                    }
                    littleEndian = littleEndian.toUpperCase();
                    const buf = Buffer.alloc(4);
                    if (littleEndian === "LE") {
                        buf.writeUInt32LE(value, 0);
                    }
                    else {
                        buf.writeUInt32BE(value, 0);
                    }
                    buffer.set(Uint8Array.from(buf), offset);
                    return offset + 4;
                };
                tools.concat = function (arrays) {
                    return Uint8Array.from(Buffer.concat(arrays));
                };

                const ECPairOptionsSchema = v.optional(
                  v.object({
                    compressed: v.optional(v.boolean()),
                    network: v.optional(types.NetworkSchema),
                    // https://github.com/fabian-hiller/valibot/issues/243#issuecomment-2182514063
                    rng: v.optional(
                      v.pipe(
                        v.instance(Function),
                        v.transform((func) => {
                          return (arg) => {
                            const parsedArg = v.parse(v.optional(v.number()), arg);
                            const returnedValue = func(parsedArg);
                            const parsedReturn = v.parse(v.instance(Uint8Array), returnedValue);
                            return parsedReturn;
                          };
                        }),
                      ),
                    ),
                  }),
                );
                const toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
                function ECPairFactory(ecc) {
                  testEcc(ecc);
                  function isPoint(maybePoint) {
                    return ecc.isPoint(maybePoint);
                  }
                  function fromPrivateKey(buffer, options) {
                    v.parse(types.Buffer256Bit, buffer);
                    if (!ecc.isPrivate(buffer))
                      throw new TypeError('Private key not in range [1, n)');
                    v.parse(ECPairOptionsSchema, options);
                    return new ECPair(buffer, undefined, options);
                  }
                  function fromPublicKey(buffer, options) {
                    if (!ecc.isPoint(buffer)) {
                      throw new Error('Point not on the curve');
                    }
                    v.parse(ECPairOptionsSchema, options);
                    return new ECPair(undefined, buffer, options);
                  }
                  function fromWIF(wifString, network) {
                    const decoded = wif.decode(wifString);
                    const version = decoded.version;
                    // list of networks?
                    if (Array.isArray(network)) {
                      network = network
                        .filter((x) => {
                          return version === x.wif;
                        })
                        .pop();
                      if (!network) throw new Error('Unknown network version');
                      // otherwise, assume a network object (or default to bitcoin)
                    } else {
                      network = network || networks.bitcoin;
                      if (version !== network.wif) throw new Error('Invalid network version');
                    }
                    return fromPrivateKey(decoded.privateKey, {
                      compressed: decoded.compressed,
                      network: network,
                    });
                  }
                  /**
                   * Generates a random ECPairInterface.
                   *
                   * Uses `crypto.getRandomValues` under the hood for options.rng function, which is still an experimental feature as of Node.js 18.19.0. To work around this you can do one of the following:
                   * 1. Use a polyfill for crypto.getRandomValues()
                   * 2. Use the `--experimental-global-webcrypto` flag when running node.js.
                   * 3. Pass in a custom rng function to generate random values.
                   *
                   * @param {ECPairOptions} options - Options for the ECPairInterface.
                   * @return {ECPairInterface} A random ECPairInterface.
                   */
                  function makeRandom(options) {
                    v.parse(ECPairOptionsSchema, options);
                    if (options === undefined) options = {};
                    const rng =
                      options.rng || ((size) => crypto.getRandomValues(new Uint8Array(size)));
                    let d;
                    do {
                      d = rng(32);
                      v.parse(types.Buffer256Bit, d);
                    } while (!ecc.isPrivate(d));
                    return fromPrivateKey(d, options);
                  }
                  class ECPair {
                    __D;
                    __Q;
                    compressed;
                    network;
                    lowR;
                    constructor(__D, __Q, options) {
                      this.__D = __D;
                      this.__Q = __Q;
                      this.lowR = false;
                      if (options === undefined) options = {};
                      this.compressed =
                        options.compressed === undefined ? true : options.compressed;
                      this.network = options.network || networks.bitcoin;
                      if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);
                    }
                    get privateKey() {
                      return this.__D;
                    }
                    get publicKey() {
                      if (!this.__Q) {
                        // It is not possible for both `__Q` and `__D` to be `undefined` at the same time.
                        // The factory methods guard for this.
                        const p = ecc.pointFromScalar(this.__D, this.compressed);
                        // It is not possible for `p` to be null.
                        // `fromPrivateKey()` checks that `__D` is a valid scalar.
                        this.__Q = p;
                      }
                      return Buffer.from(this.__Q);
                    }
                    toWIF() {
                      if (!this.__D) throw new Error('Missing private key');
                      return wif.encode({
                        compressed: this.compressed,
                        privateKey: this.__D,
                        version: this.network.wif,
                      });
                    }
                    tweak(t) {
                      if (this.privateKey) return this.tweakFromPrivateKey(t);
                      return this.tweakFromPublicKey(t);
                    }
                    sign(hash, lowR) {
                      if (!this.__D) throw new Error('Missing private key');
                      if (lowR === undefined) lowR = this.lowR;
                      if (lowR === false) {
                        return ecc.sign(hash, this.__D);
                      } else {
                        let sig = ecc.sign(hash, this.__D);
                        const extraData = new Uint8Array(32);
                        let counter = 0;
                        // if first try is lowR, skip the loop
                        // for second try and on, add extra entropy counting up
                        while (sig[0] > 0x7f) {
                          counter++;
                          tools.writeUInt32(extraData, 0, counter, 'LE');
                          sig = ecc.sign(hash, this.__D, extraData);
                        }
                        return sig;
                      }
                    }
                    signSchnorr(hash) {
                      if (!this.privateKey) throw new Error('Missing private key');
                      if (!ecc.signSchnorr)
                        throw new Error('signSchnorr not supported by ecc library');
                      return ecc.signSchnorr(hash, this.privateKey);
                    }
                    verify(hash, signature) {
                      return ecc.verify(hash, this.publicKey, signature);
                    }
                    verifySchnorr(hash, signature) {
                      if (!ecc.verifySchnorr)
                        throw new Error('verifySchnorr not supported by ecc library');
                      return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
                    }
                    tweakFromPublicKey(t) {
                      const xOnlyPubKey = toXOnly(this.publicKey);
                      const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
                      if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
                        throw new Error('Cannot tweak public key!');
                      const parityByte = Uint8Array.from([
                        tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
                      ]);
                      return fromPublicKey(
                        tools.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
                        {
                          network: this.network,
                          compressed: this.compressed,
                        },
                      );
                    }
                    tweakFromPrivateKey(t) {
                      const hasOddY =
                        this.publicKey[0] === 3 ||
                        (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
                      const privateKey = hasOddY
                        ? ecc.privateNegate(this.privateKey)
                        : this.privateKey;
                      const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
                      if (!tweakedPrivateKey) throw new Error('Invalid tweaked private key!');
                      return fromPrivateKey(tweakedPrivateKey, {
                        network: this.network,
                        compressed: this.compressed,
                      });
                    }
                  }
                  return {
                    isPoint,
                    fromPrivateKey,
                    fromPublicKey,
                    fromWIF,
                    makeRandom,
                  };
                }
                return ECPairFactory;
            })();
        </script>
        <script type="text/javascript">
            var sha256 = (() => {
                function anumber(n) {
                    if (!Number.isSafeInteger(n) || n < 0)
                        throw new Error('positive integer expected, got ' + n);
                }
                // copied from utils
                function isBytes(a) {
                    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
                }
                function abytes(b, ...lengths) {
                    if (!isBytes(b))
                        throw new Error('Uint8Array expected');
                    if (lengths.length > 0 && !lengths.includes(b.length))
                        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
                }
                function ahash(h) {
                    if (typeof h !== 'function' || typeof h.create !== 'function')
                        throw new Error('Hash should be wrapped by utils.wrapConstructor');
                    anumber(h.outputLen);
                    anumber(h.blockLen);
                }
                function aexists(instance, checkFinished = true) {
                    if (instance.destroyed)
                        throw new Error('Hash instance has been destroyed');
                    if (checkFinished && instance.finished)
                        throw new Error('Hash#digest() has already been called');
                }
                function aoutput(out, instance) {
                    abytes(out);
                    const min = instance.outputLen;
                    if (out.length < min) {
                        throw new Error('digestInto() expects output buffer of length at least ' + min);
                    }
                }
                //export { anumber, anumber as number, abytes, abytes as bytes, ahash, aexists, aoutput };
                const assert = {
                    number: anumber,
                    bytes: abytes,
                    hash: ahash,
                    exists: aexists,
                    output: aoutput,
                };

                //# sourceMappingURL=_assert.js.map
                /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
                // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
                // node.js versions earlier than v19 don't declare it in global scope.
                // For node.js, package.json#exports field mapping rewrites import
                // from `crypto` to `cryptoNode`, which imports native module.
                // Makes the utils un-importable in browsers without a bundler.
                // Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
                // export { isBytes } from './_assert.js';
                // We can't reuse isBytes from _assert, because somehow this causes huge perf issues
                // Cast array to different type
                const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
                const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
                // Cast array to view
                const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
                // The rotate right (circular right shift) operation for uint32
                const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
                // The rotate left (circular left shift) operation for uint32
                const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
                const isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
                // The byte swap operation for uint32
                const byteSwap = (word) => ((word << 24) & 0xff000000) |
                    ((word << 8) & 0xff0000) |
                    ((word >>> 8) & 0xff00) |
                    ((word >>> 24) & 0xff);
                // Conditionally byte swap if on a big-endian platform
                const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);
                // In place byte swap for Uint32Array
                function byteSwap32(arr) {
                    for (let i = 0; i < arr.length; i++) {
                        arr[i] = byteSwap(arr[i]);
                    }
                }
                // Array where index 0xf0 (240) is mapped to string 'f0'
                const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
                /**
                 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
                 */
                function bytesToHex(bytes) {
                    abytes(bytes);
                    // pre-caching improves the speed 6x
                    let hex = '';
                    for (let i = 0; i < bytes.length; i++) {
                        hex += hexes[bytes[i]];
                    }
                    return hex;
                }
                // We use optimized technique to convert hex string to byte array
                const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
                function asciiToBase16(ch) {
                    if (ch >= asciis._0 && ch <= asciis._9)
                        return ch - asciis._0; // '2' => 50-48
                    if (ch >= asciis.A && ch <= asciis.F)
                        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
                    if (ch >= asciis.a && ch <= asciis.f)
                        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
                    return;
                }
                /**
                 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
                 */
                function hexToBytes(hex) {
                    if (typeof hex !== 'string')
                        throw new Error('hex string expected, got ' + typeof hex);
                    const hl = hex.length;
                    const al = hl / 2;
                    if (hl % 2)
                        throw new Error('hex string expected, got unpadded hex of length ' + hl);
                    const array = new Uint8Array(al);
                    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
                        const n1 = asciiToBase16(hex.charCodeAt(hi));
                        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
                        if (n1 === undefined || n2 === undefined) {
                            const char = hex[hi] + hex[hi + 1];
                            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
                        }
                        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
                    }
                    return array;
                }
                // There is no setImmediate in browser and setTimeout is slow.
                // call of async fn will return Promise, which will be fullfiled only on
                // next scheduler queue processing step and this is exactly what we need.
                const nextTick = async () => { };
                // Returns control to thread each 'tick' ms to avoid blocking
                async function asyncLoop(iters, tick, cb) {
                    let ts = Date.now();
                    for (let i = 0; i < iters; i++) {
                        cb(i);
                        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
                        const diff = Date.now() - ts;
                        if (diff >= 0 && diff < tick)
                            continue;
                        await nextTick();
                        ts += diff;
                    }
                }
                /**
                 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
                 */
                function utf8ToBytes(str) {
                    if (typeof str !== 'string')
                        throw new Error('utf8ToBytes expected string, got ' + typeof str);
                    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
                }
                /**
                 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
                 * Warning: when Uint8Array is passed, it would NOT get copied.
                 * Keep in mind for future mutable operations.
                 */
                function toBytes(data) {
                    if (typeof data === 'string')
                        data = utf8ToBytes(data);
                    abytes(data);
                    return data;
                }
                /**
                 * Copies several Uint8Arrays into one.
                 */
                function concatBytes(...arrays) {
                    let sum = 0;
                    for (let i = 0; i < arrays.length; i++) {
                        const a = arrays[i];
                        abytes(a);
                        sum += a.length;
                    }
                    const res = new Uint8Array(sum);
                    for (let i = 0, pad = 0; i < arrays.length; i++) {
                        const a = arrays[i];
                        res.set(a, pad);
                        pad += a.length;
                    }
                    return res;
                }
                // For runtime check if class implements interface
                class Hash {
                    // Safe version that clones internal state
                    clone() {
                        return this._cloneInto();
                    }
                }
                function checkOpts(defaults, opts) {
                    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
                        throw new Error('Options should be object or undefined');
                    const merged = Object.assign(defaults, opts);
                    return merged;
                }
                function wrapConstructor(hashCons) {
                    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
                    const tmp = hashCons();
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = () => hashCons();
                    return hashC;
                }
                function wrapConstructorWithOpts(hashCons) {
                    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
                    const tmp = hashCons({});
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = (opts) => hashCons(opts);
                    return hashC;
                }
                function wrapXOFConstructorWithOpts(hashCons) {
                    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
                    const tmp = hashCons({});
                    hashC.outputLen = tmp.outputLen;
                    hashC.blockLen = tmp.blockLen;
                    hashC.create = (opts) => hashCons(opts);
                    return hashC;
                }
                /**
                 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
                 */
                function randomBytes(bytesLength = 32) {
                    if (crypto && typeof crypto.getRandomValues === 'function') {
                        return crypto.getRandomValues(new Uint8Array(bytesLength));
                    }
                    // Legacy Node.js compatibility
                    if (crypto && typeof crypto.randomBytes === 'function') {
                        return crypto.randomBytes(bytesLength);
                    }
                    throw new Error('crypto.getRandomValues must be defined');
                }
                //# sourceMappingURL=utils.js.map

                /**
                 * Polyfill for Safari 14
                 */
                function setBigUint64(view, byteOffset, value, isLE) {
                    if (typeof view.setBigUint64 === 'function')
                        return view.setBigUint64(byteOffset, value, isLE);
                    const _32n = BigInt(32);
                    const _u32_max = BigInt(0xffffffff);
                    const wh = Number((value >> _32n) & _u32_max);
                    const wl = Number(value & _u32_max);
                    const h = isLE ? 4 : 0;
                    const l = isLE ? 0 : 4;
                    view.setUint32(byteOffset + h, wh, isLE);
                    view.setUint32(byteOffset + l, wl, isLE);
                }
                /**
                 * Choice: a ? b : c
                 */
                const Chi = (a, b, c) => (a & b) ^ (~a & c);
                /**
                 * Majority function, true if any two inputs is true
                 */
                const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);

                /**
                 * Merkle-Damgard hash construction base class.
                 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
                 */
                class HashMD extends Hash {
                    constructor(blockLen, outputLen, padOffset, isLE) {
                        super();
                        this.blockLen = blockLen;
                        this.outputLen = outputLen;
                        this.padOffset = padOffset;
                        this.isLE = isLE;
                        this.finished = false;
                        this.length = 0;
                        this.pos = 0;
                        this.destroyed = false;
                        this.buffer = new Uint8Array(blockLen);
                        this.view = createView(this.buffer);
                    }
                    update(data) {
                        aexists(this);
                        const { view, buffer, blockLen } = this;
                        data = toBytes(data);
                        const len = data.length;
                        for (let pos = 0; pos < len;) {
                            const take = Math.min(blockLen - this.pos, len - pos);
                            // Fast path: we have at least one block in input, cast it to view and process
                            if (take === blockLen) {
                                const dataView = createView(data);
                                for (; blockLen <= len - pos; pos += blockLen)
                                    this.process(dataView, pos);
                                continue;
                            }
                            buffer.set(data.subarray(pos, pos + take), this.pos);
                            this.pos += take;
                            pos += take;
                            if (this.pos === blockLen) {
                                this.process(view, 0);
                                this.pos = 0;
                            }
                        }
                        this.length += data.length;
                        this.roundClean();
                        return this;
                    }
                    digestInto(out) {
                        aexists(this);
                        aoutput(out, this);
                        this.finished = true;
                        // Padding
                        // We can avoid allocation of buffer for padding completely if it
                        // was previously not allocated here. But it won't change performance.
                        const { buffer, view, blockLen, isLE } = this;
                        let { pos } = this;
                        // append the bit '1' to the message
                        buffer[pos++] = 0b10000000;
                        this.buffer.subarray(pos).fill(0);
                        // we have less than padOffset left in buffer, so we cannot put length in
                        // current block, need process it and pad again
                        if (this.padOffset > blockLen - pos) {
                            this.process(view, 0);
                            pos = 0;
                        }
                        // Pad until full block byte with zeros
                        for (let i = pos; i < blockLen; i++)
                            buffer[i] = 0;
                        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
                        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
                        // So we just write lowest 64 bits of that value.
                        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
                        this.process(view, 0);
                        const oview = createView(out);
                        const len = this.outputLen;
                        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
                        if (len % 4)
                            throw new Error('_sha2: outputLen should be aligned to 32bit');
                        const outLen = len / 4;
                        const state = this.get();
                        if (outLen > state.length)
                            throw new Error('_sha2: outputLen bigger than state');
                        for (let i = 0; i < outLen; i++)
                            oview.setUint32(4 * i, state[i], isLE);
                    }
                    digest() {
                        const { buffer, outputLen } = this;
                        this.digestInto(buffer);
                        const res = buffer.slice(0, outputLen);
                        this.destroy();
                        return res;
                    }
                    _cloneInto(to) {
                        to || (to = new this.constructor());
                        to.set(...this.get());
                        const { blockLen, buffer, length, finished, destroyed, pos } = this;
                        to.length = length;
                        to.pos = pos;
                        to.finished = finished;
                        to.destroyed = destroyed;
                        if (length % blockLen)
                            to.buffer.set(buffer);
                        return to;
                    }
                }
                // https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
                // https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
                const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
                const Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_, i) => i));
                const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
                let idxL = [Id];
                let idxR = [Pi];
                for (let i = 0; i < 4; i++)
                    for (let j of [idxL, idxR])
                        j.push(j[i].map((k) => Rho[k]));
                const shifts = /* @__PURE__ */ [
                    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
                    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
                    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
                    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
                    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
                ].map((i) => new Uint8Array(i));
                const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
                const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
                const Kl = /* @__PURE__ */ new Uint32Array([
                    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
                ]);
                const Kr = /* @__PURE__ */ new Uint32Array([
                    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
                ]);
                // It's called f() in spec.
                function f(group, x, y, z) {
                    if (group === 0)
                        return x ^ y ^ z;
                    else if (group === 1)
                        return (x & y) | (~x & z);
                    else if (group === 2)
                        return (x | ~y) ^ z;
                    else if (group === 3)
                        return (x & z) | (y & ~z);
                    else
                        return x ^ (y | ~z);
                }
                // Temporary buffer, not used to store anything between runs
                const R_BUF = /* @__PURE__ */ new Uint32Array(16);
                // SHA2-256 need to try 2^128 hashes to execute birthday attack.
                // BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.
                // Round constants:
                // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
                // prettier-ignore
                const SHA256_K = /* @__PURE__ */ new Uint32Array([
                    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
                ]);
                // Initial state:
                // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
                // prettier-ignore
                const SHA256_IV = /* @__PURE__ */ new Uint32Array([
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                ]);
                // Temporary buffer, not used to store anything between runs
                // Named this way because it matches specification.
                const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
                class SHA256 extends HashMD {
                    constructor() {
                        super(64, 32, 8, false);
                        // We cannot use array here since array allows indexing by variable
                        // which means optimizer/compiler cannot use registers.
                        this.A = SHA256_IV[0] | 0;
                        this.B = SHA256_IV[1] | 0;
                        this.C = SHA256_IV[2] | 0;
                        this.D = SHA256_IV[3] | 0;
                        this.E = SHA256_IV[4] | 0;
                        this.F = SHA256_IV[5] | 0;
                        this.G = SHA256_IV[6] | 0;
                        this.H = SHA256_IV[7] | 0;
                    }
                    get() {
                        const { A, B, C, D, E, F, G, H } = this;
                        return [A, B, C, D, E, F, G, H];
                    }
                    // prettier-ignore
                    set(A, B, C, D, E, F, G, H) {
                        this.A = A | 0;
                        this.B = B | 0;
                        this.C = C | 0;
                        this.D = D | 0;
                        this.E = E | 0;
                        this.F = F | 0;
                        this.G = G | 0;
                        this.H = H | 0;
                    }
                    process(view, offset) {
                        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
                        for (let i = 0; i < 16; i++, offset += 4)
                            SHA256_W[i] = view.getUint32(offset, false);
                        for (let i = 16; i < 64; i++) {
                            const W15 = SHA256_W[i - 15];
                            const W2 = SHA256_W[i - 2];
                            const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
                            const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
                            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
                        }
                        // Compression function main loop, 64 rounds
                        let { A, B, C, D, E, F, G, H } = this;
                        for (let i = 0; i < 64; i++) {
                            const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
                            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
                            const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
                            const T2 = (sigma0 + Maj(A, B, C)) | 0;
                            H = G;
                            G = F;
                            F = E;
                            E = (D + T1) | 0;
                            D = C;
                            C = B;
                            B = A;
                            A = (T1 + T2) | 0;
                        }
                        // Add the compressed chunk to the current hash value
                        A = (A + this.A) | 0;
                        B = (B + this.B) | 0;
                        C = (C + this.C) | 0;
                        D = (D + this.D) | 0;
                        E = (E + this.E) | 0;
                        F = (F + this.F) | 0;
                        G = (G + this.G) | 0;
                        H = (H + this.H) | 0;
                        this.set(A, B, C, D, E, F, G, H);
                    }
                    roundClean() {
                        SHA256_W.fill(0);
                    }
                    destroy() {
                        this.set(0, 0, 0, 0, 0, 0, 0, 0);
                        this.buffer.fill(0);
                    }
                }
                const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

                return sha256;
            })();
        </script>
        <script type="text/javascript">
          var sha512 = (() => {
              function toBuffer (thing, encoding, name) {
                if (Buffer.isBuffer(thing)) {
                  return thing
                } else if (typeof thing === 'string') {
                  return Buffer.from(thing, encoding)
                } else if (ArrayBuffer.isView(thing)) {
                  return Buffer.from(thing.buffer)
                } else {
                  throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
                }
              }
              // prototype class for hash functions
              function Hash(blockSize, finalSize) {
                  this._block = Buffer.alloc(blockSize);
                  this._finalSize = finalSize;
                  this._blockSize = blockSize;
                  this._len = 0;
              }

              Hash.prototype.update = function (data, enc) {
                  /* eslint no-param-reassign: 0 */
                  data = toBuffer(data, enc || 'utf8');

                  var block = this._block;
                  var blockSize = this._blockSize;
                  var length = data.length;
                  var accum = this._len;

                  for (var offset = 0; offset < length;) {
                      var assigned = accum % blockSize;
                      var remainder = Math.min(length - offset, blockSize - assigned);

                      for (var i = 0; i < remainder; i++) {
                          block[assigned + i] = data[offset + i];
                      }

                      accum += remainder;
                      offset += remainder;

                      if ((accum % blockSize) === 0) {
                          this._update(block);
                      }
                  }

                  this._len += length;
                  return this;
              };

              Hash.prototype.digest = function (enc) {
                  var rem = this._len % this._blockSize;

                  this._block[rem] = 0x80;

                  /*
                   * zero (rem + 1) trailing bits, where (rem + 1) is the smallest
                   * non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
                   */
                  this._block.fill(0, rem + 1);

                  if (rem >= this._finalSize) {
                      this._update(this._block);
                      this._block.fill(0);
                  }

                  var bits = this._len * 8;

                  // uint32
                  if (bits <= 0xffffffff) {
                      this._block.writeUInt32BE(bits, this._blockSize - 4);

                      // uint64
                  } else {
                      var lowBits = (bits & 0xffffffff) >>> 0;
                      var highBits = (bits - lowBits) / 0x100000000;

                      this._block.writeUInt32BE(highBits, this._blockSize - 8);
                      this._block.writeUInt32BE(lowBits, this._blockSize - 4);
                  }

                  this._update(this._block);
                  var hash = this._hash();

                  return enc ? hash.toString(enc) : hash;
              };

              Hash.prototype._update = function () {
                  throw new Error('_update must be implemented by subclass');
              };

              var K = [0x428a2f98,0xd728ae22,0x71374491,0x23ef65cd,0xb5c0fbcf,0xec4d3b2f,0xe9b5dba5,0x8189dbbc,0x3956c25b,0xf348b538,0x59f111f1,0xb605d019,0x923f82a4,0xaf194f9b,0xab1c5ed5,0xda6d8118,0xd807aa98,0xa3030242,0x12835b01,0x45706fbe,0x243185be,0x4ee4b28c,0x550c7dc3,0xd5ffb4e2,0x72be5d74,0xf27b896f,0x80deb1fe,0x3b1696b1,0x9bdc06a7,0x25c71235,0xc19bf174,0xcf692694,0xe49b69c1,0x9ef14ad2,0xefbe4786,0x384f25e3,0x0fc19dc6,0x8b8cd5b5,0x240ca1cc,0x77ac9c65,0x2de92c6f,0x592b0275,0x4a7484aa,0x6ea6e483,0x5cb0a9dc,0xbd41fbd4,0x76f988da,0x831153b5,0x983e5152,0xee66dfab,0xa831c66d,0x2db43210,0xb00327c8,0x98fb213f,0xbf597fc7,0xbeef0ee4,0xc6e00bf3,0x3da88fc2,0xd5a79147,0x930aa725,0x06ca6351,0xe003826f,0x14292967,0x0a0e6e70,0x27b70a85,0x46d22ffc,0x2e1b2138,0x5c26c926,0x4d2c6dfc,0x5ac42aed,0x53380d13,0x9d95b3df,0x650a7354,0x8baf63de,0x766a0abb,0x3c77b2a8,0x81c2c92e,0x47edaee6,0x92722c85,0x1482353b,0xa2bfe8a1,0x4cf10364,0xa81a664b,0xbc423001,0xc24b8b70,0xd0f89791,0xc76c51a3,0x0654be30,0xd192e819,0xd6ef5218,0xd6990624,0x5565a910,0xf40e3585,0x5771202a,0x106aa070,0x32bbd1b8,0x19a4c116,0xb8d2d0c8,0x1e376c08,0x5141ab53,0x2748774c,0xdf8eeb99,0x34b0bcb5,0xe19b48a8,0x391c0cb3,0xc5c95a63,0x4ed8aa4a,0xe3418acb,0x5b9cca4f,0x7763e373,0x682e6ff3,0xd6b2b8a3,0x748f82ee,0x5defb2fc,0x78a5636f,0x43172f60,0x84c87814,0xa1f0ab72,0x8cc70208,0x1a6439ec,0x90befffa,0x23631e28,0xa4506ceb,0xde82bde9,0xbef9a3f7,0xb2c67915,0xc67178f2,0xe372532b,0xca273ece,0xea26619c,0xd186b8c7,0x21c0c207,0xeada7dd6,0xcde0eb1e,0xf57d4f7f,0xee6ed178,0x06f067aa,0x72176fba,0x0a637dc5,0xa2c898a6,0x113f9804,0xbef90dae,0x1b710b35,0x131c471b,0x28db77f5,0x23047d84,0x32caab7b,0x40c72493,0x3c9ebe0a,0x15c9bebc,0x431d67c4,0x9c100d4c,0x4cc5d4be,0xcb3e42b6,0x597f299c,0xfc657e2a,0x5fcb6fab,0x3ad6faec,0x6c44198c,0x4a475817];

              var W = new Array(160);

              class Sha512 extends Hash {
                  constructor () {
                      super(128, 112);
                      this.init();
                      this._w = W;
                  }
                  init () {
                      this._ah = 0x6a09e667;
                      this._bh = 0xbb67ae85;
                      this._ch = 0x3c6ef372;
                      this._dh = 0xa54ff53a;
                      this._eh = 0x510e527f;
                      this._fh = 0x9b05688c;
                      this._gh = 0x1f83d9ab;
                      this._hh = 0x5be0cd19;

                      this._al = 0xf3bcc908;
                      this._bl = 0x84caa73b;
                      this._cl = 0xfe94f82b;
                      this._dl = 0x5f1d36f1;
                      this._el = 0xade682d1;
                      this._fl = 0x2b3e6c1f;
                      this._gl = 0xfb41bd6b;
                      this._hl = 0x137e2179;
                  }
                  _update (M) {
                      var w = this._w;

                      var ah = this._ah | 0;
                      var bh = this._bh | 0;
                      var ch = this._ch | 0;
                      var dh = this._dh | 0;
                      var eh = this._eh | 0;
                      var fh = this._fh | 0;
                      var gh = this._gh | 0;
                      var hh = this._hh | 0;

                      var al = this._al | 0;
                      var bl = this._bl | 0;
                      var cl = this._cl | 0;
                      var dl = this._dl | 0;
                      var el = this._el | 0;
                      var fl = this._fl | 0;
                      var gl = this._gl | 0;
                      var hl = this._hl | 0;

                      for (var i = 0; i < 32; i += 2) {
                          w[i] = M.readInt32BE(i * 4);
                          w[i + 1] = M.readInt32BE((i * 4) + 4);
                      }
                      for (; i < 160; i += 2) {
                          var xh = w[i - (15 * 2)];
                          var xl = w[i - (15 * 2) + 1];
                          var gamma0 = Gamma0(xh, xl);
                          var gamma0l = Gamma0l(xl, xh);

                          xh = w[i - (2 * 2)];
                          xl = w[i - (2 * 2) + 1];
                          var gamma1 = Gamma1(xh, xl);
                          var gamma1l = Gamma1l(xl, xh);

                          // w[i] = gamma0 + w[i - 7] + gamma1 + w[i - 16]
                          var Wi7h = w[i - (7 * 2)];
                          var Wi7l = w[i - (7 * 2) + 1];

                          var Wi16h = w[i - (16 * 2)];
                          var Wi16l = w[i - (16 * 2) + 1];

                          var Wil = (gamma0l + Wi7l) | 0;
                          var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
                          Wil = (Wil + gamma1l) | 0;
                          Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
                          Wil = (Wil + Wi16l) | 0;
                          Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

                          w[i] = Wih;
                          w[i + 1] = Wil;
                      }

                      for (var j = 0; j < 160; j += 2) {
                          Wih = w[j];
                          Wil = w[j + 1];

                          var majh = maj(ah, bh, ch);
                          var majl = maj(al, bl, cl);

                          var sigma0h = sigma0(ah, al);
                          var sigma0l = sigma0(al, ah);
                          var sigma1h = sigma1(eh, el);
                          var sigma1l = sigma1(el, eh);

                          // t1 = h + sigma1 + ch + K[j] + w[j]
                          var Kih = K[j];
                          var Kil = K[j + 1];

                          var chh = Ch(eh, fh, gh);
                          var chl = Ch(el, fl, gl);

                          var t1l = (hl + sigma1l) | 0;
                          var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
                          t1l = (t1l + chl) | 0;
                          t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
                          t1l = (t1l + Kil) | 0;
                          t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
                          t1l = (t1l + Wil) | 0;
                          t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

                          // t2 = sigma0 + maj
                          var t2l = (sigma0l + majl) | 0;
                          var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

                          hh = gh;
                          hl = gl;
                          gh = fh;
                          gl = fl;
                          fh = eh;
                          fl = el;
                          el = (dl + t1l) | 0;
                          eh = (dh + t1h + getCarry(el, dl)) | 0;
                          dh = ch;
                          dl = cl;
                          ch = bh;
                          cl = bl;
                          bh = ah;
                          bl = al;
                          al = (t1l + t2l) | 0;
                          ah = (t1h + t2h + getCarry(al, t1l)) | 0;
                      }

                      this._al = (this._al + al) | 0;
                      this._bl = (this._bl + bl) | 0;
                      this._cl = (this._cl + cl) | 0;
                      this._dl = (this._dl + dl) | 0;
                      this._el = (this._el + el) | 0;
                      this._fl = (this._fl + fl) | 0;
                      this._gl = (this._gl + gl) | 0;
                      this._hl = (this._hl + hl) | 0;

                      this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
                      this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
                      this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
                      this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
                      this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
                      this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
                      this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
                      this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
                  }
                  _hash () {
                      var H = Buffer.allocUnsafe(64);

                      function writeInt64BE(h, l, offset) {
                          H.writeInt32BE(h, offset);
                          H.writeInt32BE(l, offset + 4);
                      }

                      writeInt64BE(this._ah, this._al, 0);
                      writeInt64BE(this._bh, this._bl, 8);
                      writeInt64BE(this._ch, this._cl, 16);
                      writeInt64BE(this._dh, this._dl, 24);
                      writeInt64BE(this._eh, this._el, 32);
                      writeInt64BE(this._fh, this._fl, 40);
                      writeInt64BE(this._gh, this._gl, 48);
                      writeInt64BE(this._hh, this._hl, 56);

                      return H;
                  }
              };
              function Ch(x, y, z) {
                  return z ^ (x & (y ^ z));
              }
              function maj(x, y, z) {
                  return (x & y) | (z & (x | y));
              }
              function sigma0(x, xl) {
                  return ((x >>> 28) | (xl << 4)) ^ ((xl >>> 2) | (x << 30)) ^ ((xl >>> 7) | (x << 25));
              }
              function sigma1(x, xl) {
                  return ((x >>> 14) | (xl << 18)) ^ ((x >>> 18) | (xl << 14)) ^ ((xl >>> 9) | (x << 23));
              }
              function Gamma0(x, xl) {
                  return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ (x >>> 7);
              }
              function Gamma0l(x, xl) {
                  return ((x >>> 1) | (xl << 31)) ^ ((x >>> 8) | (xl << 24)) ^ ((x >>> 7) | (xl << 25));
              }
              function Gamma1(x, xl) {
                  return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ (x >>> 6);
              }
              function Gamma1l(x, xl) {
                  return ((x >>> 19) | (xl << 13)) ^ ((xl >>> 29) | (x << 3)) ^ ((x >>> 6) | (xl << 26));
              }
              function getCarry(a, b) {
                  return (a >>> 0) < (b >>> 0) ? 1 : 0;
              }

              return Sha512;
          })();
        </script>
        <script type="text/javascript">
            var ecc = (() => {
                const secp256k1 = (() => {
                    const t = {};
                        let a, o;
                        /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        }),
                        t.utils = t.schnorr = t.verify = t.signSync = t.sign = t.getSharedSecret = t.recoverPublicKey = t.getPublicKey = t.Signature = t.Point = t.CURVE = void 0;
                        //let i = r(9159)
                        let n = BigInt(0)
                          , s = BigInt(1)
                          , u = BigInt(2)
                          , l = BigInt(3)
                          , c = BigInt(8)
                          , f = Object.freeze({
                            a: n,
                            b: BigInt(7),
                            P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
                            n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
                            h: s,
                            Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                            Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
                        });
                        t.CURVE = f;
                        let h = (e, t) => (e + t / u) / t
                          , d = {
                            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                            splitScalar(e) {
                                let {n: t} = f
                                  , r = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
                                  , a = -s * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
                                  , o = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
                                  , i = BigInt("0x100000000000000000000000000000000")
                                  , n = h(r * e, t)
                                  , u = h(-a * e, t)
                                  , l = L(e - n * r - u * o, t)
                                  , c = L(-n * a - u * r, t)
                                  , d = l > i
                                  , p = c > i;
                                if (d && (l = t - l),
                                p && (c = t - c),
                                l > i || c > i)
                                    throw Error("splitScalarEndo: Endomorphism failed, k=" + e);
                                return {
                                    k1neg: d,
                                    k1: l,
                                    k2neg: p,
                                    k2: c
                                }
                            }
                        };
                        function p(e) {
                            let {a: t, b: r} = f
                              , a = L(e * e)
                              , o = L(a * e);
                            return L(o + t * e + r)
                        }
                        let b = f.a === n;
                        class m extends Error {
                            constructor(e) {
                                super(e)
                            }
                        }
                        function g(e) {
                            if (!(e instanceof y))
                                throw TypeError("JacobianPoint expected")
                        }
                        class y {
                            static fromAffine(e) {
                                if (!(e instanceof k))
                                    throw TypeError("JacobianPoint#fromAffine: expected Point");
                                return e.equals(k.ZERO) ? y.ZERO : new y(e.x,e.y,s)
                            }
                            static toAffineBatch(e) {
                                let t = function(e) {
                                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f.P
                                      , r = Array(e.length)
                                      , a = C(e.reduce( (e, a, o) => a === n ? e : (r[o] = e,
                                    L(e * a, t)), s), t);
                                    return e.reduceRight( (e, a, o) => a === n ? e : (r[o] = L(e * r[o], t),
                                    L(e * a, t)), a),
                                    r
                                }(e.map(e => e.z));
                                return e.map( (e, r) => e.toAffine(t[r]))
                            }
                            static normalizeZ(e) {
                                return y.toAffineBatch(e).map(y.fromAffine)
                            }
                            equals(e) {
                                g(e);
                                let {x: t, y: r, z: a} = this
                                  , {x: o, y: i, z: n} = e
                                  , s = L(a * a)
                                  , u = L(n * n)
                                  , l = L(t * u)
                                  , c = L(o * s)
                                  , f = L(L(r * n) * u)
                                  , h = L(L(i * a) * s);
                                return l === c && f === h
                            }
                            negate() {
                                return new y(this.x,L(-this.y),this.z)
                            }
                            double() {
                                let {x: e, y: t, z: r} = this
                                  , a = L(e * e)
                                  , o = L(t * t)
                                  , i = L(o * o)
                                  , n = e + o
                                  , s = L(u * (L(n * n) - a - i))
                                  , f = L(l * a)
                                  , h = L(f * f)
                                  , d = L(h - u * s)
                                  , p = L(f * (s - d) - c * i);
                                return new y(d,p,L(u * t * r))
                            }
                            add(e) {
                                g(e);
                                let {x: t, y: r, z: a} = this
                                  , {x: o, y: i, z: s} = e;
                                if (o === n || i === n)
                                    return this;
                                if (t === n || r === n)
                                    return e;
                                let l = L(a * a)
                                  , c = L(s * s)
                                  , f = L(t * c)
                                  , h = L(o * l)
                                  , d = L(L(r * s) * c)
                                  , p = L(L(i * a) * l)
                                  , b = L(h - f)
                                  , m = L(p - d);
                                if (b === n)
                                    return m === n ? this.double() : y.ZERO;
                                let v = L(b * b)
                                  , w = L(b * v)
                                  , k = L(f * v)
                                  , _ = L(m * m - w - u * k)
                                  , E = L(m * (k - _) - d * w);
                                return new y(_,E,L(a * s * b))
                            }
                            subtract(e) {
                                return this.add(e.negate())
                            }
                            multiplyUnsafe(e) {
                                let t = y.ZERO;
                                if ("bigint" == typeof e && e === n)
                                    return t;
                                let r = R(e);
                                if (r === s)
                                    return this;
                                if (!b) {
                                    let e = t
                                      , a = this;
                                    for (; r > n; )
                                        r & s && (e = e.add(a)),
                                        a = a.double(),
                                        r >>= s;
                                    return e
                                }
                                let {k1neg: a, k1: o, k2neg: i, k2: u} = d.splitScalar(r)
                                  , l = t
                                  , c = t
                                  , f = this;
                                for (; o > n || u > n; )
                                    o & s && (l = l.add(f)),
                                    u & s && (c = c.add(f)),
                                    f = f.double(),
                                    o >>= s,
                                    u >>= s;
                                return a && (l = l.negate()),
                                i && (c = c.negate()),
                                c = new y(L(c.x * d.beta),c.y,c.z),
                                l.add(c)
                            }
                            precomputeWindow(e) {
                                let t = b ? 128 / e + 1 : 256 / e + 1
                                  , r = []
                                  , a = this
                                  , o = a;
                                for (let i = 0; i < t; i++) {
                                    o = a,
                                    r.push(o);
                                    for (let t = 1; t < 2 ** (e - 1); t++)
                                        o = o.add(a),
                                        r.push(o);
                                    a = o.double()
                                }
                                return r
                            }
                            wNAF(e, t) {
                                !t && this.equals(y.BASE) && (t = k.BASE);
                                let r = t && t._WINDOW_SIZE || 1;
                                if (256 % r)
                                    throw Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                                let a = t && w.get(t);
                                !a && (a = this.precomputeWindow(r),
                                t && 1 !== r && (a = y.normalizeZ(a),
                                w.set(t, a)));
                                let o = y.ZERO
                                  , i = y.BASE
                                  , n = 1 + (b ? 128 / r : 256 / r)
                                  , u = 2 ** (r - 1)
                                  , l = BigInt(2 ** r - 1)
                                  , c = 2 ** r
                                  , f = BigInt(r);
                                for (let t = 0; t < n; t++) {
                                    let r = t * u
                                      , n = Number(e & l);
                                    e >>= f,
                                    n > u && (n -= c,
                                    e += s);
                                    let h = r + Math.abs(n) - 1
                                      , d = t % 2 != 0
                                      , p = n < 0;
                                    0 === n ? i = i.add(v(d, a[r])) : o = o.add(v(p, a[h]))
                                }
                                return {
                                    p: o,
                                    f: i
                                }
                            }
                            multiply(e, t) {
                                let r, a, o = R(e);
                                if (b) {
                                    let {k1neg: e, k1: i, k2neg: n, k2: s} = d.splitScalar(o)
                                      , {p: u, f: l} = this.wNAF(i, t)
                                      , {p: c, f: f} = this.wNAF(s, t);
                                    u = v(e, u),
                                    c = new y(L((c = v(n, c)).x * d.beta),c.y,c.z),
                                    r = u.add(c),
                                    a = l.add(f)
                                } else {
                                    let {p: e, f: i} = this.wNAF(o, t);
                                    r = e,
                                    a = i
                                }
                                return y.normalizeZ([r, a])[0]
                            }
                            toAffine(e) {
                                let {x: t, y: r, z: a} = this
                                  , o = this.equals(y.ZERO);
                                null == e && (e = o ? c : C(a));
                                let i = e
                                  , n = L(i * i)
                                  , u = L(n * i)
                                  , l = L(t * n)
                                  , f = L(r * u)
                                  , h = L(a * i);
                                if (o)
                                    return k.ZERO;
                                if (h !== s)
                                    throw Error("invZ was invalid");
                                return new k(l,f)
                            }
                            constructor(e, t, r) {
                                this.x = e,
                                this.y = t,
                                this.z = r
                            }
                        }
                        function v(e, t) {
                            let r = t.negate();
                            return e ? r : t
                        }
                        y.BASE = new y(f.Gx,f.Gy,s),
                        y.ZERO = new y(n,s,n);
                        let w = new WeakMap;
                        class k {
                            _setWindowSize(e) {
                                this._WINDOW_SIZE = e,
                                w.delete(this)
                            }
                            hasEvenY() {
                                return this.y % u === n
                            }
                            static fromCompressedHex(e) {
                                let t = 32 === e.length
                                  , r = U(t ? e : e.subarray(1));
                                if (!K(r))
                                    throw Error("Point is not on curve");
                                let a = function(e) {
                                    let {P: t} = f
                                      , r = BigInt(6)
                                      , a = BigInt(11)
                                      , o = BigInt(22)
                                      , i = BigInt(23)
                                      , n = BigInt(44)
                                      , s = BigInt(88)
                                      , c = e * e * e % t
                                      , h = c * c * e % t
                                      , d = H(h, l) * h % t
                                      , p = H(d, l) * h % t
                                      , b = H(p, u) * c % t
                                      , m = H(b, a) * b % t
                                      , g = H(m, o) * m % t
                                      , y = H(g, n) * g % t
                                      , v = H(y, s) * y % t
                                      , w = H(v, n) * g % t
                                      , k = H(w, l) * h % t
                                      , _ = H(k, i) * m % t
                                      , E = H(_, r) * c % t
                                      , S = H(E, u);
                                    if (S * S % t !== e)
                                        throw Error("Cannot find square root");
                                    return S
                                }(p(r))
                                  , o = (a & s) === s;
                                t ? o && (a = L(-a)) : (1 & e[0]) == 1 !== o && (a = L(-a));
                                let i = new k(r,a);
                                return i.assertValidity(),
                                i
                            }
                            static fromUncompressedHex(e) {
                                let t = new k(U(e.subarray(1, 33)),U(e.subarray(33, 65)));
                                return t.assertValidity(),
                                t
                            }
                            static fromHex(e) {
                                let t = N(e)
                                  , r = t.length
                                  , a = t[0];
                                if (32 === r || 33 === r && (2 === a || 3 === a))
                                    return this.fromCompressedHex(t);
                                if (65 === r && 4 === a)
                                    return this.fromUncompressedHex(t);
                                throw Error("Point.fromHex: received invalid point. Expected 32-".concat(33, " compressed bytes or ").concat(65, " uncompressed bytes, not ").concat(r))
                            }
                            static fromPrivateKey(e) {
                                return k.BASE.multiply(V(e))
                            }
                            static fromSignature(e, t, r) {
                                let {r: a, s: o} = G(t);
                                if (![0, 1, 2, 3].includes(r))
                                    throw Error("Cannot recover: invalid recovery bit");
                                let i = M(N(e))
                                  , {n} = f
                                  , s = 2 === r || 3 === r ? a + n : a
                                  , u = C(s, n)
                                  , l = L(-i * u, n)
                                  , c = L(o * u, n)
                                  , h = 1 & r ? "03" : "02"
                                  , d = k.fromHex(h + P(s))
                                  , p = k.BASE.multiplyAndAddUnsafe(d, l, c);
                                if (!p)
                                    throw Error("Cannot recover signature: point at infinify");
                                return p.assertValidity(),
                                p
                            }
                            toRawBytes() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                return j(this.toHex(e))
                            }
                            toHex() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
                                  , t = P(this.x);
                                if (!e)
                                    return "04".concat(t).concat(P(this.y));
                                {
                                    let e = this.hasEvenY() ? "02" : "03";
                                    return "".concat(e).concat(t)
                                }
                            }
                            toHexX() {
                                return this.toHex(!0).slice(2)
                            }
                            toRawX() {
                                return this.toRawBytes(!0).slice(1)
                            }
                            assertValidity() {
                                let e = "Point is not on elliptic curve"
                                  , {x: t, y: r} = this;
                                if (!K(t) || !K(r))
                                    throw Error(e);
                                let a = L(r * r);
                                if (L(a - p(t)) !== n)
                                    throw Error(e)
                            }
                            equals(e) {
                                return this.x === e.x && this.y === e.y
                            }
                            negate() {
                                return new k(this.x,L(-this.y))
                            }
                            double() {
                                return y.fromAffine(this).double().toAffine()
                            }
                            add(e) {
                                return y.fromAffine(this).add(y.fromAffine(e)).toAffine()
                            }
                            subtract(e) {
                                return this.add(e.negate())
                            }
                            multiply(e) {
                                return y.fromAffine(this).multiply(e, this).toAffine()
                            }
                            multiplyAndAddUnsafe(e, t, r) {
                                let a = y.fromAffine(this)
                                  , o = t === n || t === s || this !== k.BASE ? a.multiplyUnsafe(t) : a.multiply(t)
                                  , i = y.fromAffine(e).multiplyUnsafe(r)
                                  , u = o.add(i);
                                return u.equals(y.ZERO) ? void 0 : u.toAffine()
                            }
                            constructor(e, t) {
                                this.x = e,
                                this.y = t
                            }
                        }
                        function _(e) {
                            return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e
                        }
                        function E(e) {
                            if (e.length < 2 || 2 !== e[0])
                                throw Error("Invalid signature integer tag: ".concat(I(e)));
                            let t = e[1]
                              , r = e.subarray(2, t + 2);
                            if (!t || r.length !== t)
                                throw Error("Invalid signature integer: wrong length");
                            if (0 === r[0] && r[1] <= 127)
                                throw Error("Invalid signature integer: trailing length");
                            return {
                                data: U(r),
                                left: e.subarray(t + 2)
                            }
                        }
                        t.Point = k,
                        k.BASE = new k(f.Gx,f.Gy),
                        k.ZERO = new k(n,n);
                        class S {
                            static fromCompact(e) {
                                let t = e instanceof Uint8Array
                                  , r = "Signature.fromCompact";
                                if ("string" != typeof e && !t)
                                    throw TypeError("".concat(r, ": Expected string or Uint8Array"));
                                let a = t ? I(e) : e;
                                if (128 !== a.length)
                                    throw Error("".concat(r, ": Expected 64-byte hex"));
                                return new S(B(a.slice(0, 64)),B(a.slice(64, 128)))
                            }
                            static fromDER(e) {
                                let t = e instanceof Uint8Array;
                                if ("string" != typeof e && !t)
                                    throw TypeError("Signature.fromDER: Expected string or Uint8Array");
                                let {r, s: a} = function(e) {
                                    if (e.length < 2 || 48 != e[0])
                                        throw Error("Invalid signature tag: ".concat(I(e)));
                                    if (e[1] !== e.length - 2)
                                        throw Error("Invalid signature: incorrect length");
                                    let {data: t, left: r} = E(e.subarray(2))
                                      , {data: a, left: o} = E(r);
                                    if (o.length)
                                        throw Error("Invalid signature: left bytes after parsing: ".concat(I(o)));
                                    return {
                                        r: t,
                                        s: a
                                    }
                                }(t ? e : j(e));
                                return new S(r,a)
                            }
                            static fromHex(e) {
                                return this.fromDER(e)
                            }
                            assertValidity() {
                                let {r: e, s: t} = this;
                                if (!D(e))
                                    throw Error("Invalid Signature: r must be 0 < r < n");
                                if (!D(t))
                                    throw Error("Invalid Signature: s must be 0 < s < n")
                            }
                            hasHighS() {
                                let e = f.n >> s;
                                return this.s > e
                            }
                            normalizeS() {
                                return this.hasHighS() ? new S(this.r,L(-this.s, f.n)) : this
                            }
                            toDERRawBytes() {
                                return j(this.toDERHex())
                            }
                            toDERHex() {
                                let e = _(z(this.s))
                                  , t = _(z(this.r))
                                  , r = e.length / 2
                                  , a = t.length / 2
                                  , o = z(r)
                                  , i = z(a)
                                  , n = z(a + r + 4);
                                return "30".concat(n, "02").concat(i).concat(t, "02").concat(o).concat(e)
                            }
                            toRawBytes() {
                                return this.toDERRawBytes()
                            }
                            toHex() {
                                return this.toDERHex()
                            }
                            toCompactRawBytes() {
                                return j(this.toCompactHex())
                            }
                            toCompactHex() {
                                return P(this.r) + P(this.s)
                            }
                            constructor(e, t) {
                                this.r = e,
                                this.s = t,
                                this.assertValidity()
                            }
                        }
                        function T() {
                            for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
                                t[r] = arguments[r];
                            if (!t.every(e => e instanceof Uint8Array))
                                throw Error("Uint8Array list expected");
                            if (1 === t.length)
                                return t[0];
                            let a = t.reduce( (e, t) => e + t.length, 0)
                              , o = new Uint8Array(a);
                            for (let e = 0, r = 0; e < t.length; e++) {
                                let a = t[e];
                                o.set(a, r),
                                r += a.length
                            }
                            return o
                        }
                        t.Signature = S;
                        let x = Array.from({
                            length: 256
                        }, (e, t) => t.toString(16).padStart(2, "0"));
                        function I(e) {
                            if (!(e instanceof Uint8Array))
                                throw Error("Expected Uint8Array");
                            let t = "";
                            for (let r = 0; r < e.length; r++)
                                t += x[e[r]];
                            return t
                        }
                        let A = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
                        function P(e) {
                            if ("bigint" != typeof e)
                                throw Error("Expected bigint");
                            if (!(n <= e && e < A))
                                throw Error("Expected number 0 <= n < 2^256");
                            return e.toString(16).padStart(64, "0")
                        }
                        function O(e) {
                            let t = j(P(e));
                            if (32 !== t.length)
                                throw Error("Error: expected 32 bytes");
                            return t
                        }
                        function z(e) {
                            let t = e.toString(16);
                            return 1 & t.length ? "0".concat(t) : t
                        }
                        function B(e) {
                            if ("string" != typeof e)
                                throw TypeError("hexToNumber: expected string, got " + typeof e);
                            return BigInt("0x".concat(e))
                        }
                        function j(e) {
                            if ("string" != typeof e)
                                throw TypeError("hexToBytes: expected string, got " + typeof e);
                            if (e.length % 2)
                                throw Error("hexToBytes: received invalid unpadded hex" + e.length);
                            let t = new Uint8Array(e.length / 2);
                            for (let r = 0; r < t.length; r++) {
                                let a = 2 * r
                                  , o = Number.parseInt(e.slice(a, a + 2), 16);
                                if (Number.isNaN(o) || o < 0)
                                    throw Error("Invalid byte sequence");
                                t[r] = o
                            }
                            return t
                        }
                        function U(e) {
                            return B(I(e))
                        }
                        function N(e) {
                            return e instanceof Uint8Array ? Uint8Array.from(e) : j(e)
                        }
                        function R(e) {
                            if ("number" == typeof e && Number.isSafeInteger(e) && e > 0)
                                return BigInt(e);
                            if ("bigint" == typeof e && D(e))
                                return e;
                            throw TypeError("Expected valid private scalar: 0 < scalar < curve.n")
                        }
                        function L(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f.P
                              , r = e % t;
                            return r >= n ? r : t + r
                        }
                        function H(e, t) {
                            let {P: r} = f
                              , a = e;
                            for (; t-- > n; )
                                a *= a,
                                a %= r;
                            return a
                        }
                        function C(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : f.P;
                            if (e === n || t <= n)
                                throw Error("invert: expected positive integers, got n=".concat(e, " mod=").concat(t));
                            let r = L(e, t)
                              , a = t
                              , o = n
                              , i = s
                              , u = s
                              , l = n;
                            for (; r !== n; ) {
                                let e = a / r
                                  , t = a % r
                                  , n = o - u * e
                                  , s = i - l * e;
                                a = r,
                                r = t,
                                o = u,
                                i = l,
                                u = n,
                                l = s
                            }
                            if (a !== s)
                                throw Error("invert: does not exist");
                            return L(o, t)
                        }
                        function M(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                              , r = function(e) {
                                let t = 8 * e.length - 256
                                  , r = U(e);
                                return t > 0 ? r >> BigInt(t) : r
                            }(e);
                            if (t)
                                return r;
                            let {n: a} = f;
                            return r >= a ? r - a : r
                        }
                        class q {
                            hmac() {
                                for (var e = arguments.length, r = Array(e), a = 0; a < e; a++)
                                    r[a] = arguments[a];
                                return t.utils.hmacSha256(this.k, ...r)
                            }
                            hmacSync() {
                                for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
                                    t[r] = arguments[r];
                                return o(this.k, ...t)
                            }
                            checkSync() {
                                if ("function" != typeof o)
                                    throw new m("hmacSha256Sync needs to be set")
                            }
                            incr() {
                                if (this.counter >= 1e3)
                                    throw Error("Tried 1,000 k values for sign(), all were invalid");
                                this.counter += 1
                            }
                            async reseed() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array;
                                this.k = await this.hmac(this.v, Uint8Array.from([0]), e),
                                this.v = await this.hmac(this.v),
                                0 !== e.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e),
                                this.v = await this.hmac(this.v))
                            }
                            reseedSync() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array;
                                this.checkSync(),
                                this.k = this.hmacSync(this.v, Uint8Array.from([0]), e),
                                this.v = this.hmacSync(this.v),
                                0 !== e.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e),
                                this.v = this.hmacSync(this.v))
                            }
                            async generate() {
                                this.incr();
                                let e = 0
                                  , t = [];
                                for (; e < this.qByteLen; ) {
                                    this.v = await this.hmac(this.v);
                                    let r = this.v.slice();
                                    t.push(r),
                                    e += this.v.length
                                }
                                return T(...t)
                            }
                            generateSync() {
                                this.checkSync(),
                                this.incr();
                                let e = 0
                                  , t = [];
                                for (; e < this.qByteLen; ) {
                                    this.v = this.hmacSync(this.v);
                                    let r = this.v.slice();
                                    t.push(r),
                                    e += this.v.length
                                }
                                return T(...t)
                            }
                            constructor(e, t) {
                                if (this.hashLen = e,
                                this.qByteLen = t,
                                "number" != typeof e || e < 2)
                                    throw Error("hashLen must be a number");
                                if ("number" != typeof t || t < 2)
                                    throw Error("qByteLen must be a number");
                                this.v = new Uint8Array(e).fill(1),
                                this.k = new Uint8Array(e).fill(0),
                                this.counter = 0
                            }
                        }
                        function D(e) {
                            return n < e && e < f.n
                        }
                        function K(e) {
                            return n < e && e < f.P
                        }
                        function F(e, t, r) {
                            let a = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3]
                              , {n: o} = f
                              , i = M(e, !0);
                            if (!D(i))
                                return;
                            let u = C(i, o)
                              , l = k.BASE.multiply(i)
                              , c = L(l.x, o);
                            if (c === n)
                                return;
                            let h = L(u * L(t + r * c, o), o);
                            if (h === n)
                                return;
                            let d = new S(c,h)
                              , p = (l.x === d.r ? 0 : 2) | Number(l.y & s);
                            return a && d.hasHighS() && (d = d.normalizeS(),
                            p ^= 1),
                            {
                                sig: d,
                                recovery: p
                            }
                        }
                        function V(e) {
                            let t;
                            if ("bigint" == typeof e)
                                t = e;
                            else if ("number" == typeof e && Number.isSafeInteger(e) && e > 0)
                                t = BigInt(e);
                            else if ("string" == typeof e) {
                                if (64 !== e.length)
                                    throw Error("Expected 32 bytes of private key");
                                t = B(e)
                            } else if (e instanceof Uint8Array) {
                                if (32 !== e.length)
                                    throw Error("Expected 32 bytes of private key");
                                t = U(e)
                            } else
                                throw TypeError("Expected valid private key");
                            if (!D(t))
                                throw Error("Expected private key: 0 < key < n");
                            return t
                        }
                        function W(e) {
                            return e instanceof k ? (e.assertValidity(),
                            e) : k.fromHex(e)
                        }
                        function G(e) {
                            if (e instanceof S)
                                return e.assertValidity(),
                                e;
                            try {
                                return S.fromDER(e)
                            } catch (t) {
                                return S.fromCompact(e)
                            }
                        }
                        function X(e) {
                            let t = e instanceof Uint8Array
                              , r = "string" == typeof e
                              , a = (t || r) && e.length;
                            return t ? 33 === a || 65 === a : r ? 66 === a || 130 === a : e instanceof k
                        }
                        function Y(e) {
                            return U(e.length > 32 ? e.slice(0, 32) : e)
                        }
                        function J(e, r, a) {
                            if (null == e)
                                throw Error('sign: expected valid message hash, not "'.concat(e, '"'));
                            let o = N(e)
                              , i = V(r)
                              , s = [O(i), function(e) {
                                let t = Y(e)
                                  , r = L(t, f.n);
                                return O(r < n ? t : r)
                            }(o)];
                            if (null != a) {
                                !0 === a && (a = t.utils.randomBytes(32));
                                let e = N(a);
                                if (32 !== e.length)
                                    throw Error("sign: Expected ".concat(32, " bytes of extra data"));
                                s.push(e)
                            }
                            return {
                                seed: T(...s),
                                m: Y(o),
                                d: i
                            }
                        }
                        function Q(e, t) {
                            let {sig: r, recovery: a} = e
                              , {der: o, recovered: i} = Object.assign({
                                canonical: !0,
                                der: !0
                            }, t)
                              , n = Buffer.from(o ? r.toDERRawBytes() : r.toCompactRawBytes());
                            return i ? [n, a] : n
                        }
                        async function Z(e, t) {
                            let r, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, {seed: o, m: i, d: n} = J(e, t, a.extraEntropy), s = new q(32,32);
                            for (await s.reseed(o); !(r = F(await s.generate(), i, n, a.canonical)); )
                                await s.reseed();
                            return Q(r, a)
                        }
                        t.getPublicKey = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            return k.fromPrivateKey(e).toRawBytes(t)
                        }
                        ,
                        t.recoverPublicKey = function(e, t, r) {
                            let a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                            return k.fromSignature(e, t, r).toRawBytes(a)
                        }
                        ,
                        t.getSharedSecret = function(e, t) {
                            let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                            if (X(e))
                                throw TypeError("getSharedSecret: first arg must be private key");
                            if (!X(t))
                                throw TypeError("getSharedSecret: second arg must be public key");
                            let a = W(t);
                            return a.assertValidity(),
                            a.multiply(V(e)).toRawBytes(r)
                        }
                        ,
                        t.sign = Z,
                        t.signSync = function(e, t) {
                            let r, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, {seed: o, m: i, d: n} = J(e, t, a.extraEntropy), s = new q(32,32);
                            for (s.reseedSync(o); !(r = F(s.generateSync(), i, n, a.canonical)); )
                                s.reseedSync();
                            return Q(r, a)
                        }
                        ;
                        let $ = {
                            strict: !0
                        };
                        function ee(e) {
                            return L(U(e), f.n)
                        }
                        t.verify = function(e, t, r) {
                            let a, o, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : $;
                            try {
                                a = G(e),
                                t = N(t)
                            } catch (e) {
                                return !1
                            }
                            let {r: n, s} = a;
                            if (i.strict && a.hasHighS())
                                return !1;
                            let u = M(t);
                            try {
                                o = W(r)
                            } catch (e) {
                                return !1
                            }
                            let {n: l} = f
                              , c = C(s, l)
                              , h = L(u * c, l)
                              , d = L(n * c, l)
                              , p = k.BASE.multiplyAndAddUnsafe(o, h, d);
                            return !!p && L(p.x, l) === n
                        }
                        ;
                        class et {
                            static fromHex(e) {
                                let t = N(e);
                                if (64 !== t.length)
                                    throw TypeError("SchnorrSignature.fromHex: expected 64 bytes, not ".concat(t.length));
                                return new et(U(t.subarray(0, 32)),U(t.subarray(32, 64)))
                            }
                            assertValidity() {
                                let {r: e, s: t} = this;
                                if (!K(e) || !D(t))
                                    throw Error("Invalid signature")
                            }
                            toHex() {
                                return P(this.r) + P(this.s)
                            }
                            toRawBytes() {
                                return j(this.toHex())
                            }
                            constructor(e, t) {
                                this.r = e,
                                this.s = t,
                                this.assertValidity()
                            }
                        }
                        class er {
                            getScalar(e) {
                                let t = k.fromPrivateKey(e)
                                  , r = t.hasEvenY() ? e : f.n - e;
                                return {
                                    point: t,
                                    scalar: r,
                                    x: t.toRawX()
                                }
                            }
                            initNonce(e, t) {
                                return O(e ^ U(t))
                            }
                            finalizeNonce(e) {
                                let t = L(U(e), f.n);
                                if (t === n)
                                    throw Error("sign: Creation of signature failed. k is zero");
                                let {point: r, x: a, scalar: o} = this.getScalar(t);
                                return {
                                    R: r,
                                    rx: a,
                                    k: o
                                }
                            }
                            finalizeSig(e, t, r, a) {
                                return new et(e.x,L(t + r * a, f.n)).toRawBytes()
                            }
                            error() {
                                throw Error("sign: Invalid signature produced")
                            }
                            async calc() {
                                let {m: e, d: r, px: a, rand: o} = this
                                  , i = t.utils.taggedHash
                                  , n = this.initNonce(r, await i(el.aux, o))
                                  , {R: s, rx: u, k: l} = this.finalizeNonce(await i(el.nonce, n, a, e))
                                  , c = ee(await i(el.challenge, u, a, e))
                                  , f = this.finalizeSig(s, l, c, r);
                                return await en(f, e, a) || this.error(),
                                f
                            }
                            calcSync() {
                                let {m: e, d: r, px: a, rand: o} = this
                                  , i = t.utils.taggedHashSync
                                  , n = this.initNonce(r, i(el.aux, o))
                                  , {R: s, rx: u, k: l} = this.finalizeNonce(i(el.nonce, n, a, e))
                                  , c = ee(i(el.challenge, u, a, e))
                                  , f = this.finalizeSig(s, l, c, r);
                                return es(f, e, a) || this.error(),
                                f
                            }
                            constructor(e, r, a=t.utils.randomBytes()) {
                                if (null == e)
                                    throw TypeError('sign: Expected valid message, not "'.concat(e, '"'));
                                this.m = N(e);
                                let {x: o, scalar: i} = this.getScalar(V(r));
                                if (this.px = o,
                                this.d = i,
                                this.rand = N(a),
                                32 !== this.rand.length)
                                    throw TypeError("sign: Expected 32 bytes of aux randomness")
                            }
                        }
                        async function ea(e, t, r) {
                            return new er(e,t,r).calc()
                        }
                        function eo(e, t, r) {
                            let a = e instanceof et
                              , o = a ? e : et.fromHex(e);
                            return a && o.assertValidity(),
                            {
                                ...o,
                                m: N(t),
                                P: W(r)
                            }
                        }
                        function ei(e, t, r, a) {
                            let o = k.BASE.multiplyAndAddUnsafe(t, V(r), L(-a, f.n));
                            return !!(o && o.hasEvenY()) && o.x === e
                        }
                        async function en(e, r, a) {
                            try {
                                let {r: o, s: i, m: n, P: s} = eo(e, r, a)
                                  , u = ee(await t.utils.taggedHash(el.challenge, O(o), s.toRawX(), n));
                                return ei(o, s, i, u)
                            } catch (e) {
                                return !1
                            }
                        }
                        function es(e, r, a) {
                            try {
                                let {r: o, s: i, m: n, P: s} = eo(e, r, a)
                                  , u = ee(t.utils.taggedHashSync(el.challenge, O(o), s.toRawX(), n));
                                return ei(o, s, i, u)
                            } catch (e) {
                                if (e instanceof m)
                                    throw e;
                                return !1
                            }
                        }
                        t.schnorr = {
                            Signature: et,
                            getPublicKey: function(e) {
                                return k.fromPrivateKey(e).toRawX()
                            },
                            sign: ea,
                            verify: en,
                            signSync: function(e, t, r) {
                                return new er(e,t,r).calcSync()
                            },
                            verifySync: es
                        },
                        k.BASE._setWindowSize(8);
                        let eu = {
                            node: i,
                            web: "object" == typeof self && "crypto"in self ? self.crypto : void 0
                        }
                          , el = {
                            challenge: "BIP0340/challenge",
                            aux: "BIP0340/aux",
                            nonce: "BIP0340/nonce"
                        }
                          , ec = {};
                        t.utils = {
                            bytesToHex: I,
                            hexToBytes: j,
                            concatBytes: T,
                            mod: L,
                            invert: C,
                            isValidPrivateKey(e) {
                                try {
                                    return V(e),
                                    !0
                                } catch (e) {
                                    return !1
                                }
                            },
                            _bigintTo32Bytes: O,
                            _normalizePrivateKey: V,
                            hashToPrivateKey: e => {
                                if ((e = N(e)).length < 40 || e.length > 1024)
                                    throw Error("Expected valid bytes of private key as per FIPS 186");
                                return O(L(U(e), f.n - s) + s)
                            }
                            ,
                            randomBytes: function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
                                if (eu.web)
                                    return eu.web.getRandomValues(new Uint8Array(e));
                                if (eu.node) {
                                    let {randomBytes: t} = eu.node;
                                    return Uint8Array.from(t(e))
                                }
                                throw Error("The environment doesn't have randomBytes function")
                            },
                            randomPrivateKey: () => t.utils.hashToPrivateKey(t.utils.randomBytes(40)),
                            precompute() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8
                                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : k.BASE
                                  , r = t === k.BASE ? t : new k(t.x,t.y);
                                return r._setWindowSize(e),
                                r.multiply(l),
                                r
                            },
                            sha256: async function() {
                                for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
                                    t[r] = arguments[r];
                                if (eu.web) {
                                    let e = await eu.web.subtle.digest("SHA-256", T(...t));
                                    return new Uint8Array(e)
                                }
                                if (eu.node) {
                                    let {createHash: e} = eu.node
                                      , r = e("sha256");
                                    return t.forEach(e => r.update(e)),
                                    Uint8Array.from(r.digest())
                                }
                                throw Error("The environment doesn't have sha256 function")
                            },
                            hmacSha256: async function(e) {
                                for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
                                    r[a - 1] = arguments[a];
                                if (eu.web) {
                                    let t = await eu.web.subtle.importKey("raw", e, {
                                        name: "HMAC",
                                        hash: {
                                            name: "SHA-256"
                                        }
                                    }, !1, ["sign"])
                                      , a = T(...r)
                                      , o = await eu.web.subtle.sign("HMAC", t, a);
                                    return new Uint8Array(o)
                                }
                                if (eu.node) {
                                    let {createHmac: t} = eu.node
                                      , a = t("sha256", e);
                                    return r.forEach(e => a.update(e)),
                                    Uint8Array.from(a.digest())
                                }
                                throw Error("The environment doesn't have hmac-sha256 function")
                            },
                            sha256Sync: void 0,
                            hmacSha256Sync: void 0,
                            taggedHash: async function(e) {
                                for (var r = arguments.length, a = Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                                    a[o - 1] = arguments[o];
                                let i = ec[e];
                                if (void 0 === i) {
                                    let r = await t.utils.sha256(Uint8Array.from(e, e => e.charCodeAt(0)));
                                    i = T(r, r),
                                    ec[e] = i
                                }
                                return t.utils.sha256(i, ...a)
                            },
                            taggedHashSync: function(e) {
                                for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
                                    r[o - 1] = arguments[o];
                                if ("function" != typeof a)
                                    throw new m("sha256Sync is undefined, you need to set it");
                                let i = ec[e];
                                if (void 0 === i) {
                                    let t = a(Uint8Array.from(e, e => e.charCodeAt(0)));
                                    i = T(t, t),
                                    ec[e] = i
                                }
                                return a(i, ...r)
                            },
                            _JacobianPoint: y
                        },
                        Object.defineProperties(t.utils, {
                            sha256Sync: {
                                configurable: !1,
                                get: () => a,
                                set(e) {
                                    a || (a = e)
                                }
                            },
                            hmacSha256Sync: {
                                configurable: !1,
                                get: () => o,
                                set(e) {
                                    o || (o = e)
                                }
                            }
                        })
                    return t;
                })();

                const hmac = (() => {
                    const aa = {};
                    function utf8ToBytes(str) {
                        if (typeof str !== 'string')
                            throw new Error('string expected');
                        return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
                    }
                    function isBytes(a) {
                        return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
                    }
                    function abytes(item) {
                        if (!isBytes(item))
                            throw new Error('Uint8Array expected');
                    }
                    function toBytes(data) {
                      if (typeof data === 'string') data = utf8ToBytes(data);
                      abytes(data);
                      return data;
                    }
                    function r(e) {
                        if (!Number.isSafeInteger(e) || e < 0)
                            throw Error("Wrong positive integer: ".concat(e))
                    }
                    function a(e) {
                        if ("boolean" != typeof e)
                            throw Error("Expected boolean, not ".concat(e))
                    }
                    function o(e) {
                        for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
                            r[a - 1] = arguments[a];
                        if (!(e instanceof Uint8Array || null != e && "object" == typeof e && "Uint8Array" === e.constructor.name))
                            throw Error("Expected Uint8Array");
                        if (r.length > 0 && !r.includes(e.length))
                            throw Error("Expected Uint8Array of length ".concat(r, ", not of length=").concat(e.length))
                    }
                    function i(e) {
                        if ("function" != typeof e || "function" != typeof e.create)
                            throw Error("Hash should be wrapped by utils.wrapConstructor");
                        r(e.outputLen),
                        r(e.blockLen)
                    }
                    function n(e) {
                        let t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
                        if (e.destroyed)
                            throw Error("Hash instance has been destroyed");
                        if (t && e.finished)
                            throw Error("Hash#digest() has already been called")
                    }
                    function s(e, t) {
                        o(e);
                        let r = t.outputLen;
                        if (e.length < r)
                            throw Error("digestInto() expects output buffer of length at least ".concat(r))
                    }
                    aa.number = r;
                    aa.bool = a;
                    aa.bytes = o;
                    aa.hash = i;
                    aa.exists = n;
                    aa.output = s;
                    aa.default = {
                        number: r,
                        bool: a,
                        bytes: o,
                        hash: i,
                        exists: n,
                        output: s
                    }

                    class Hash {
                        // Safe version that clones internal state
                        clone() {
                            return this._cloneInto();
                        }
                    }

                    const t = {};
                    class Hmac extends Hash {
                        update(e) {
                            return (0,aa.exists)(this),
                            this.iHash.update(e),
                            this
                        }
                        digestInto(e) {
                            (0,
                            aa.exists)(this),
                            (0,
                            aa.bytes)(e, this.outputLen),
                            this.finished = !0,
                            this.iHash.digestInto(e),
                            this.oHash.update(e),
                            this.oHash.digestInto(e),
                            this.destroy()
                        }
                        digest() {
                            let e = new Uint8Array(this.oHash.outputLen);
                            return this.digestInto(e),
                            e
                        }
                        _cloneInto(e) {
                            e || (e = Object.create(Object.getPrototypeOf(this), {}));
                            let {oHash: t, iHash: r, finished: a, destroyed: o, blockLen: i, outputLen: n} = this;
                            return e.finished = a,
                            e.destroyed = o,
                            e.blockLen = i,
                            e.outputLen = n,
                            e.oHash = t._cloneInto(e.oHash),
                            e.iHash = r._cloneInto(e.iHash),
                            e
                        }
                        destroy() {
                            this.destroyed = !0,
                            this.oHash.destroy(),
                            this.iHash.destroy()
                        }
                        constructor(e, t) {
                            super(),
                            this.finished = !1,
                            this.destroyed = !1,
                            (0,
                            aa.hash)(e);
                            let r = toBytes(t);
                            if (this.iHash = e.create(),
                            "function" != typeof this.iHash.update)
                                throw Error("Expected instance of class which extends utils.Hash");
                            this.blockLen = this.iHash.blockLen,
                            this.outputLen = this.iHash.outputLen;
                            let i = this.blockLen
                              , n = new Uint8Array(i);
                            n.set(r.length > i ? e.create().update(r).digest() : r);
                            for (let e = 0; e < n.length; e++)
                                n[e] ^= 54;
                            this.iHash.update(n),
                            this.oHash = e.create();
                            for (let e = 0; e < n.length; e++)
                                n[e] ^= 106;
                            this.oHash.update(n),
                            n.fill(0)
                        }
                    }
                    t.HMAC = Hmac,
                    t.hmac = (e, t, r) => new Hmac(e,t).update(r).digest(),
                    t.hmac.create = (e, t) => new Hmac(e,t);
                    return t;
                })();

                var a, o = Buffer, i = secp256k1, n = hmac/*r(5543)*/, u = (a = Object.create(null),
                i && Object.keys(i).forEach(function(e) {
                    if ("default" !== e) {
                        var t = Object.getOwnPropertyDescriptor(i, e);
                        Object.defineProperty(a, e, t.get ? t : {
                            enumerable: !0,
                            get: function() {
                                return i[e]
                            }
                        })
                    }
                }),
                a.default = i, Object.freeze(a));
                let l = "Expected Private"
                  , c = "Expected Point"
                  , f = "Expected Tweak"
                  , h = "Expected Signature"
                  , d = "Expected Extra Data (32 bytes)"
                  , p = "Expected Scalar";
                u.utils.hmacSha256Sync = function(e) {
                    for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
                        r[a - 1] = arguments[a];
                    return n.hmac(sha256, e, u.utils.concatBytes(...r))
                }
                ,
                u.utils.sha256Sync = function() {
                    for (var e = arguments.length, t = Array(e), r = 0; r < e; r++)
                        t[r] = arguments[r];
                    return sha256(u.utils.concatBytes(...t))
                }
                ;
                let b = u.utils._normalizePrivateKey
                  , m = new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65])
                  , g = new Uint8Array(32)
                  , y = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95, 196, 64, 45, 161, 114, 47, 201, 186, 238]);
                function v(e, t) {
                    for (let r = 0; r < 32; ++r)
                        if (e[r] !== t[r])
                            return e[r] < t[r] ? -1 : 1;
                    return 0
                }
                function w(e) {
                    return !(!(e instanceof Uint8Array) || 32 !== e.length || v(e, m) >= 0)
                }
                function k(e) {
                    return e instanceof Uint8Array && 64 === e.length && 0 > v(e.subarray(0, 32), m) && 0 > v(e.subarray(32, 64), m)
                }
                function _(e) {
                    return e instanceof Uint8Array && 32 === e.length
                }
                function E(e) {
                    return void 0 === e || e instanceof Uint8Array && 32 === e.length
                }
                function S(e) {
                    if ("string" != typeof e)
                        throw TypeError("hexToNumber: expected string, got " + typeof e);
                    return BigInt("0x".concat(e))
                }
                function T(e) {
                    let t;
                    if ("bigint" == typeof e)
                        t = e;
                    else if ("number" == typeof e && Number.isSafeInteger(e) && e >= 0)
                        t = BigInt(e);
                    else if ("string" == typeof e) {
                        if (64 !== e.length)
                            throw Error("Expected 32 bytes of private scalar");
                        t = S(e)
                    } else if (e instanceof Uint8Array) {
                        if (32 !== e.length)
                            throw Error("Expected 32 bytes of private scalar");
                        t = S(u.utils.bytesToHex(e))
                    } else
                        throw TypeError("Expected valid private scalar");
                    if (t < 0)
                        throw Error("Expected private scalar >= 0");
                    return t
                }
                let x = (e, t) => {
                    let r = b(e)
                      , a = T(t)
                      , o = u.utils._bigintTo32Bytes(u.utils.mod(r + a, u.CURVE.n));
                    return u.utils.isValidPrivateKey(o) ? o : null
                }
                  , I = (e, t) => {
                    let r = b(e)
                      , a = T(t)
                      , o = u.utils._bigintTo32Bytes(u.utils.mod(r - a, u.CURVE.n));
                    return u.utils.isValidPrivateKey(o) ? o : null
                }
                  , A = e => {
                    let t = b(e)
                      , r = u.utils._bigintTo32Bytes(u.CURVE.n - t);
                    return u.utils.isValidPrivateKey(r) ? r : null
                }
                  , P = (e, t, r) => {
                    let a = u.Point.fromHex(e)
                      , o = T(t)
                      , i = u.Point.BASE.multiplyAndAddUnsafe(a, o, BigInt(1));
                    if (!i)
                        throw Error("Tweaked point at infinity");
                    return i.toRawBytes(r)
                }
                  , O = (e, t, r) => {
                    let a = u.Point.fromHex(e)
                      , o = "string" == typeof t ? t : u.utils.bytesToHex(t)
                      , i = BigInt("0x".concat(o));
                    return a.multiply(i).toRawBytes(r)
                }
                ;
                function z(e, t) {
                    return void 0 === e ? void 0 === t || N(t) : !!e
                }
                function B(e) {
                    try {
                        return e()
                    } catch (e) {
                        return null
                    }
                }
                function j(e, t) {
                    if (32 === e.length !== t)
                        return !1;
                    try {
                        return !!u.Point.fromHex(e)
                    } catch (e) {
                        return !1
                    }
                }
                function U(e) {
                    return j(e, !1)
                }
                function N(e) {
                    return j(e, !1) && 33 === e.length
                }
                function R(e) {
                    return u.utils.isValidPrivateKey(e)
                }
                function L(e) {
                    return j(e, !0)
                }
                function H(e) {
                    if (!U(e))
                        throw Error(c);
                    return e.slice(1, 33)
                }
                function C(e, t) {
                    if (!R(e))
                        throw Error(l);
                    return B( () => u.getPublicKey(e, z(t)))
                }

                const t = {};
                t.isPoint = U,
                t.isPointCompressed = N,
                t.isPrivate = R,
                t.isXOnlyPoint = L,
                t.pointAdd = function(e, t, r) {
                    if (!U(e) || !U(t))
                        throw Error(c);
                    return B( () => {
                        let a = u.Point.fromHex(e)
                          , o = u.Point.fromHex(t);
                        return a.equals(o.negate()) ? null : a.add(o).toRawBytes(z(r, e))
                    }
                    )
                }
                ,
                t.pointAddScalar = function(e, t, r) {
                    if (!U(e))
                        throw Error(c);
                    if (!w(t))
                        throw Error(f);
                    return B( () => P(e, t, z(r, e)))
                }
                ,
                t.pointCompress = function(e, t) {
                    if (!U(e))
                        throw Error(c);
                    return u.Point.fromHex(e).toRawBytes(z(t, e))
                }
                ,
                t.pointFromScalar = C,
                t.pointMultiply = function(e, t, r) {
                    if (!U(e))
                        throw Error(c);
                    if (!w(t))
                        throw Error(f);
                    return B( () => O(e, t, z(r, e)))
                }
                ,
                t.privateAdd = function(e, t) {
                    if (!1 === R(e))
                        throw Error(l);
                    if (!1 === w(t))
                        throw Error(f);
                    return B( () => x(e, t))
                }
                ,
                t.privateNegate = function(e) {
                    if (!1 === R(e))
                        throw Error(l);
                    return A(e)
                }
                ,
                t.privateSub = function(e, t) {
                    if (!1 === R(e))
                        throw Error(l);
                    if (!1 === w(t))
                        throw Error(f);
                    return B( () => I(e, t))
                }
                ,
                t.recover = function(e, t, r, a) {
                    if (!_(e))
                        throw Error("Expected Hash");
                    if (!k(t) || 0 === v(t.subarray(0, 32), g) || 0 === v(t.subarray(32, 64), g))
                        throw Error(h);
                    if (2 & r && !(t instanceof Uint8Array && 64 === t.length && 0 > v(t.subarray(0, 32), y)))
                        throw Error("Bad Recovery Id");
                    if (!L(t.subarray(0, 32)))
                        throw Error(h);
                    return u.recoverPublicKey(e, t, r, z(a))
                }
                ,
                t.sign = function(e, t, r) {
                    if (!R(t))
                        throw Error(l);
                    if (!_(e))
                        throw Error(p);
                    if (!E(r))
                        throw Error(d);
                    return u.signSync(e, t, {
                        der: !1,
                        extraEntropy: r
                    })
                }
                ,
                t.signRecoverable = function(e, t, r) {
                    if (!R(t))
                        throw Error(l);
                    if (!_(e))
                        throw Error(p);
                    if (!E(r))
                        throw Error(d);
                    let[a,o] = u.signSync(e, t, {
                        der: !1,
                        extraEntropy: r,
                        recovered: !0
                    });
                    return {
                        signature: a,
                        recoveryId: o
                    }
                }
                ,
                t.signSchnorr = function(e, t) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : o.alloc(32, 0);
                    if (!R(t))
                        throw Error(l);
                    if (!_(e))
                        throw Error(p);
                    if (!E(r))
                        throw Error(d);
                    return u.schnorr.signSync(e, t, r)
                }
                ,
                t.verify = function(e, t, r, a) {
                    if (!U(t))
                        throw Error(c);
                    if (!k(r))
                        throw Error(h);
                    if (!_(e))
                        throw Error(p);
                    return u.verify(r, e, t, {
                        strict: a
                    })
                }
                ,
                t.verifySchnorr = function(e, t, r) {
                    if (!L(t))
                        throw Error(c);
                    if (!k(r))
                        throw Error(h);
                    if (!_(e))
                        throw Error(p);
                    return u.schnorr.verifySync(r, e, t)
                }
                ,
                t.xOnlyPointAddTweak = function(e, t) {
                    if (!L(e))
                        throw Error(c);
                    if (!w(t))
                        throw Error(f);
                    return B( () => {
                        let r = P(e, t, !0);
                        return {
                            parity: r[0] % 2 == 1 ? 1 : 0,
                            xOnlyPubkey: r.slice(1)
                        }
                    }
                    )
                }
                ,
                t.xOnlyPointFromPoint = H,
                t.xOnlyPointFromScalar = function(e) {
                    if (!R(e))
                        throw Error(l);
                    return H(C(e))
                }
                t.secp256k1 = secp256k1;
                const ecc = t;

                return ecc;
            })();
        </script>
        <script type="text/javascript">
            /**
             * Minified by jsDelivr using Terser v5.39.0.
             * Original file: /npm/bip39@3.0.0/src/index.js
             *
             * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
             */
            var bip39 = (() => {
                const _wordlists_1 = (() => {
                    const _wordlists_1 = {};
                    // browserify by default only pulls in files that are hard coded in requires
                    // In order of last to first in this file, the default wordlist will be chosen
                    // based on what is present. (Bundles may remove wordlists they don't need)
                    const wordlistFilenames = [
                        /*'chinese_simplified',
                        'chinese_traditional',
                        'korean',
                        'french',
                        'italian',
                        'spanish',
                        'japanese',*/
                        'english',
                    ];
                    const wordlists = {};
                    _wordlists_1.wordlists = wordlists;
                    let _default;
                    _wordlists_1._default = _default;
                    wordlistFilenames.forEach(lang => {
                        try {
                            _wordlists_1._default = _default = ["abandon","ability","able","about","above","absent","absorb","abstract","absurd","abuse","access","accident","account","accuse","achieve","acid","acoustic","acquire","across","act","action","actor","actress","actual","adapt","add","addict","address","adjust","admit","adult","advance","advice","aerobic","affair","afford","afraid","again","age","agent","agree","ahead","aim","air","airport","aisle","alarm","album","alcohol","alert","alien","all","alley","allow","almost","alone","alpha","already","also","alter","always","amateur","amazing","among","amount","amused","analyst","anchor","ancient","anger","angle","angry","animal","ankle","announce","annual","another","answer","antenna","antique","anxiety","any","apart","apology","appear","apple","approve","april","arch","arctic","area","arena","argue","arm","armed","armor","army","around","arrange","arrest","arrive","arrow","art","artefact","artist","artwork","ask","aspect","assault","asset","assist","assume","asthma","athlete","atom","attack","attend","attitude","attract","auction","audit","august","aunt","author","auto","autumn","average","avocado","avoid","awake","aware","away","awesome","awful","awkward","axis","baby","bachelor","bacon","badge","bag","balance","balcony","ball","bamboo","banana","banner","bar","barely","bargain","barrel","base","basic","basket","battle","beach","bean","beauty","because","become","beef","before","begin","behave","behind","believe","below","belt","bench","benefit","best","betray","better","between","beyond","bicycle","bid","bike","bind","biology","bird","birth","bitter","black","blade","blame","blanket","blast","bleak","bless","blind","blood","blossom","blouse","blue","blur","blush","board","boat","body","boil","bomb","bone","bonus","book","boost","border","boring","borrow","boss","bottom","bounce","box","boy","bracket","brain","brand","brass","brave","bread","breeze","brick","bridge","brief","bright","bring","brisk","broccoli","broken","bronze","broom","brother","brown","brush","bubble","buddy","budget","buffalo","build","bulb","bulk","bullet","bundle","bunker","burden","burger","burst","bus","business","busy","butter","buyer","buzz","cabbage","cabin","cable","cactus","cage","cake","call","calm","camera","camp","can","canal","cancel","candy","cannon","canoe","canvas","canyon","capable","capital","captain","car","carbon","card","cargo","carpet","carry","cart","case","cash","casino","castle","casual","cat","catalog","catch","category","cattle","caught","cause","caution","cave","ceiling","celery","cement","census","century","cereal","certain","chair","chalk","champion","change","chaos","chapter","charge","chase","chat","cheap","check","cheese","chef","cherry","chest","chicken","chief","child","chimney","choice","choose","chronic","chuckle","chunk","churn","cigar","cinnamon","circle","citizen","city","civil","claim","clap","clarify","claw","clay","clean","clerk","clever","click","client","cliff","climb","clinic","clip","clock","clog","close","cloth","cloud","clown","club","clump","cluster","clutch","coach","coast","coconut","code","coffee","coil","coin","collect","color","column","combine","come","comfort","comic","common","company","concert","conduct","confirm","congress","connect","consider","control","convince","cook","cool","copper","copy","coral","core","corn","correct","cost","cotton","couch","country","couple","course","cousin","cover","coyote","crack","cradle","craft","cram","crane","crash","crater","crawl","crazy","cream","credit","creek","crew","cricket","crime","crisp","critic","crop","cross","crouch","crowd","crucial","cruel","cruise","crumble","crunch","crush","cry","crystal","cube","culture","cup","cupboard","curious","current","curtain","curve","cushion","custom","cute","cycle","dad","damage","damp","dance","danger","daring","dash","daughter","dawn","day","deal","debate","debris","decade","december","decide","decline","decorate","decrease","deer","defense","define","defy","degree","delay","deliver","demand","demise","denial","dentist","deny","depart","depend","deposit","depth","deputy","derive","describe","desert","design","desk","despair","destroy","detail","detect","develop","device","devote","diagram","dial","diamond","diary","dice","diesel","diet","differ","digital","dignity","dilemma","dinner","dinosaur","direct","dirt","disagree","discover","disease","dish","dismiss","disorder","display","distance","divert","divide","divorce","dizzy","doctor","document","dog","doll","dolphin","domain","donate","donkey","donor","door","dose","double","dove","draft","dragon","drama","drastic","draw","dream","dress","drift","drill","drink","drip","drive","drop","drum","dry","duck","dumb","dune","during","dust","dutch","duty","dwarf","dynamic","eager","eagle","early","earn","earth","easily","east","easy","echo","ecology","economy","edge","edit","educate","effort","egg","eight","either","elbow","elder","electric","elegant","element","elephant","elevator","elite","else","embark","embody","embrace","emerge","emotion","employ","empower","empty","enable","enact","end","endless","endorse","enemy","energy","enforce","engage","engine","enhance","enjoy","enlist","enough","enrich","enroll","ensure","enter","entire","entry","envelope","episode","equal","equip","era","erase","erode","erosion","error","erupt","escape","essay","essence","estate","eternal","ethics","evidence","evil","evoke","evolve","exact","example","excess","exchange","excite","exclude","excuse","execute","exercise","exhaust","exhibit","exile","exist","exit","exotic","expand","expect","expire","explain","expose","express","extend","extra","eye","eyebrow","fabric","face","faculty","fade","faint","faith","fall","false","fame","family","famous","fan","fancy","fantasy","farm","fashion","fat","fatal","father","fatigue","fault","favorite","feature","february","federal","fee","feed","feel","female","fence","festival","fetch","fever","few","fiber","fiction","field","figure","file","film","filter","final","find","fine","finger","finish","fire","firm","first","fiscal","fish","fit","fitness","fix","flag","flame","flash","flat","flavor","flee","flight","flip","float","flock","floor","flower","fluid","flush","fly","foam","focus","fog","foil","fold","follow","food","foot","force","forest","forget","fork","fortune","forum","forward","fossil","foster","found","fox","fragile","frame","frequent","fresh","friend","fringe","frog","front","frost","frown","frozen","fruit","fuel","fun","funny","furnace","fury","future","gadget","gain","galaxy","gallery","game","gap","garage","garbage","garden","garlic","garment","gas","gasp","gate","gather","gauge","gaze","general","genius","genre","gentle","genuine","gesture","ghost","giant","gift","giggle","ginger","giraffe","girl","give","glad","glance","glare","glass","glide","glimpse","globe","gloom","glory","glove","glow","glue","goat","goddess","gold","good","goose","gorilla","gospel","gossip","govern","gown","grab","grace","grain","grant","grape","grass","gravity","great","green","grid","grief","grit","grocery","group","grow","grunt","guard","guess","guide","guilt","guitar","gun","gym","habit","hair","half","hammer","hamster","hand","happy","harbor","hard","harsh","harvest","hat","have","hawk","hazard","head","health","heart","heavy","hedgehog","height","hello","helmet","help","hen","hero","hidden","high","hill","hint","hip","hire","history","hobby","hockey","hold","hole","holiday","hollow","home","honey","hood","hope","horn","horror","horse","hospital","host","hotel","hour","hover","hub","huge","human","humble","humor","hundred","hungry","hunt","hurdle","hurry","hurt","husband","hybrid","ice","icon","idea","identify","idle","ignore","ill","illegal","illness","image","imitate","immense","immune","impact","impose","improve","impulse","inch","include","income","increase","index","indicate","indoor","industry","infant","inflict","inform","inhale","inherit","initial","inject","injury","inmate","inner","innocent","input","inquiry","insane","insect","inside","inspire","install","intact","interest","into","invest","invite","involve","iron","island","isolate","issue","item","ivory","jacket","jaguar","jar","jazz","jealous","jeans","jelly","jewel","job","join","joke","journey","joy","judge","juice","jump","jungle","junior","junk","just","kangaroo","keen","keep","ketchup","key","kick","kid","kidney","kind","kingdom","kiss","kit","kitchen","kite","kitten","kiwi","knee","knife","knock","know","lab","label","labor","ladder","lady","lake","lamp","language","laptop","large","later","latin","laugh","laundry","lava","law","lawn","lawsuit","layer","lazy","leader","leaf","learn","leave","lecture","left","leg","legal","legend","leisure","lemon","lend","length","lens","leopard","lesson","letter","level","liar","liberty","library","license","life","lift","light","like","limb","limit","link","lion","liquid","list","little","live","lizard","load","loan","lobster","local","lock","logic","lonely","long","loop","lottery","loud","lounge","love","loyal","lucky","luggage","lumber","lunar","lunch","luxury","lyrics","machine","mad","magic","magnet","maid","mail","main","major","make","mammal","man","manage","mandate","mango","mansion","manual","maple","marble","march","margin","marine","market","marriage","mask","mass","master","match","material","math","matrix","matter","maximum","maze","meadow","mean","measure","meat","mechanic","medal","media","melody","melt","member","memory","mention","menu","mercy","merge","merit","merry","mesh","message","metal","method","middle","midnight","milk","million","mimic","mind","minimum","minor","minute","miracle","mirror","misery","miss","mistake","mix","mixed","mixture","mobile","model","modify","mom","moment","monitor","monkey","monster","month","moon","moral","more","morning","mosquito","mother","motion","motor","mountain","mouse","move","movie","much","muffin","mule","multiply","muscle","museum","mushroom","music","must","mutual","myself","mystery","myth","naive","name","napkin","narrow","nasty","nation","nature","near","neck","need","negative","neglect","neither","nephew","nerve","nest","net","network","neutral","never","news","next","nice","night","noble","noise","nominee","noodle","normal","north","nose","notable","note","nothing","notice","novel","now","nuclear","number","nurse","nut","oak","obey","object","oblige","obscure","observe","obtain","obvious","occur","ocean","october","odor","off","offer","office","often","oil","okay","old","olive","olympic","omit","once","one","onion","online","only","open","opera","opinion","oppose","option","orange","orbit","orchard","order","ordinary","organ","orient","original","orphan","ostrich","other","outdoor","outer","output","outside","oval","oven","over","own","owner","oxygen","oyster","ozone","pact","paddle","page","pair","palace","palm","panda","panel","panic","panther","paper","parade","parent","park","parrot","party","pass","patch","path","patient","patrol","pattern","pause","pave","payment","peace","peanut","pear","peasant","pelican","pen","penalty","pencil","people","pepper","perfect","permit","person","pet","phone","photo","phrase","physical","piano","picnic","picture","piece","pig","pigeon","pill","pilot","pink","pioneer","pipe","pistol","pitch","pizza","place","planet","plastic","plate","play","please","pledge","pluck","plug","plunge","poem","poet","point","polar","pole","police","pond","pony","pool","popular","portion","position","possible","post","potato","pottery","poverty","powder","power","practice","praise","predict","prefer","prepare","present","pretty","prevent","price","pride","primary","print","priority","prison","private","prize","problem","process","produce","profit","program","project","promote","proof","property","prosper","protect","proud","provide","public","pudding","pull","pulp","pulse","pumpkin","punch","pupil","puppy","purchase","purity","purpose","purse","push","put","puzzle","pyramid","quality","quantum","quarter","question","quick","quit","quiz","quote","rabbit","raccoon","race","rack","radar","radio","rail","rain","raise","rally","ramp","ranch","random","range","rapid","rare","rate","rather","raven","raw","razor","ready","real","reason","rebel","rebuild","recall","receive","recipe","record","recycle","reduce","reflect","reform","refuse","region","regret","regular","reject","relax","release","relief","rely","remain","remember","remind","remove","render","renew","rent","reopen","repair","repeat","replace","report","require","rescue","resemble","resist","resource","response","result","retire","retreat","return","reunion","reveal","review","reward","rhythm","rib","ribbon","rice","rich","ride","ridge","rifle","right","rigid","ring","riot","ripple","risk","ritual","rival","river","road","roast","robot","robust","rocket","romance","roof","rookie","room","rose","rotate","rough","round","route","royal","rubber","rude","rug","rule","run","runway","rural","sad","saddle","sadness","safe","sail","salad","salmon","salon","salt","salute","same","sample","sand","satisfy","satoshi","sauce","sausage","save","say","scale","scan","scare","scatter","scene","scheme","school","science","scissors","scorpion","scout","scrap","screen","script","scrub","sea","search","season","seat","second","secret","section","security","seed","seek","segment","select","sell","seminar","senior","sense","sentence","series","service","session","settle","setup","seven","shadow","shaft","shallow","share","shed","shell","sheriff","shield","shift","shine","ship","shiver","shock","shoe","shoot","shop","short","shoulder","shove","shrimp","shrug","shuffle","shy","sibling","sick","side","siege","sight","sign","silent","silk","silly","silver","similar","simple","since","sing","siren","sister","situate","six","size","skate","sketch","ski","skill","skin","skirt","skull","slab","slam","sleep","slender","slice","slide","slight","slim","slogan","slot","slow","slush","small","smart","smile","smoke","smooth","snack","snake","snap","sniff","snow","soap","soccer","social","sock","soda","soft","solar","soldier","solid","solution","solve","someone","song","soon","sorry","sort","soul","sound","soup","source","south","space","spare","spatial","spawn","speak","special","speed","spell","spend","sphere","spice","spider","spike","spin","spirit","split","spoil","sponsor","spoon","sport","spot","spray","spread","spring","spy","square","squeeze","squirrel","stable","stadium","staff","stage","stairs","stamp","stand","start","state","stay","steak","steel","stem","step","stereo","stick","still","sting","stock","stomach","stone","stool","story","stove","strategy","street","strike","strong","struggle","student","stuff","stumble","style","subject","submit","subway","success","such","sudden","suffer","sugar","suggest","suit","summer","sun","sunny","sunset","super","supply","supreme","sure","surface","surge","surprise","surround","survey","suspect","sustain","swallow","swamp","swap","swarm","swear","sweet","swift","swim","swing","switch","sword","symbol","symptom","syrup","system","table","tackle","tag","tail","talent","talk","tank","tape","target","task","taste","tattoo","taxi","teach","team","tell","ten","tenant","tennis","tent","term","test","text","thank","that","theme","then","theory","there","they","thing","this","thought","three","thrive","throw","thumb","thunder","ticket","tide","tiger","tilt","timber","time","tiny","tip","tired","tissue","title","toast","tobacco","today","toddler","toe","together","toilet","token","tomato","tomorrow","tone","tongue","tonight","tool","tooth","top","topic","topple","torch","tornado","tortoise","toss","total","tourist","toward","tower","town","toy","track","trade","traffic","tragic","train","transfer","trap","trash","travel","tray","treat","tree","trend","trial","tribe","trick","trigger","trim","trip","trophy","trouble","truck","true","truly","trumpet","trust","truth","try","tube","tuition","tumble","tuna","tunnel","turkey","turn","turtle","twelve","twenty","twice","twin","twist","two","type","typical","ugly","umbrella","unable","unaware","uncle","uncover","under","undo","unfair","unfold","unhappy","uniform","unique","unit","universe","unknown","unlock","until","unusual","unveil","update","upgrade","uphold","upon","upper","upset","urban","urge","usage","use","used","useful","useless","usual","utility","vacant","vacuum","vague","valid","valley","valve","van","vanish","vapor","various","vast","vault","vehicle","velvet","vendor","venture","venue","verb","verify","version","very","vessel","veteran","viable","vibrant","vicious","victory","video","view","village","vintage","violin","virtual","virus","visa","visit","visual","vital","vivid","vocal","voice","void","volcano","volume","vote","voyage","wage","wagon","wait","walk","wall","walnut","want","warfare","warm","warrior","wash","wasp","waste","water","wave","way","wealth","weapon","wear","weasel","weather","web","wedding","weekend","weird","welcome","west","wet","whale","what","wheat","wheel","when","where","whip","whisper","wide","width","wife","wild","will","win","window","wine","wing","wink","winner","winter","wire","wisdom","wise","wish","witness","wolf","woman","wonder","wood","wool","word","work","world","worry","worth","wrap","wreck","wrestle","wrist","write","wrong","yard","year","yellow","you","young","youth","zebra","zero","zone","zoo"];
                            wordlists[lang] = _default;
                            if (lang === 'japanese') wordlists.JA = _default;
                            if (lang === 'english') wordlists.EN = _default;
                        }
                        catch (err) { }
                    });

                    return _wordlists_1;
                })();

                function toBuffer (thing, encoding, name) {
                  if (Buffer.isBuffer(thing)) {
                    return thing
                  } else if (typeof thing === 'string') {
                    return Buffer.from(thing, encoding)
                  } else if (ArrayBuffer.isView(thing)) {
                    return Buffer.from(thing.buffer)
                  } else {
                    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
                  }
                }

                
                var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

                var checkParameters = function (iterations, keylen) {
                  if (typeof iterations !== 'number') {
                    throw new TypeError('Iterations not a number')
                  }

                  if (iterations < 0) {
                    throw new TypeError('Bad iterations')
                  }

                  if (typeof keylen !== 'number') {
                    throw new TypeError('Key length not a number')
                  }

                  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
                    throw new TypeError('Bad key length')
                  }
                }
                var defaultEncoding = 'utf-8';

                var ZEROS = Buffer.alloc(128)
                var sizes = {
                  md5: 16,
                  sha1: 20,
                  sha224: 28,
                  sha256: 32,
                  sha384: 48,
                  sha512: 64,
                  rmd160: 20,
                  ripemd160: 20
                }
                function Hmac (alg, key, saltLen) {
                  var hash = getDigest(alg)
                  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

                  if (key.length > blocksize) {
                    key = hash(key)
                  } else if (key.length < blocksize) {
                    key = Buffer.concat([key, ZEROS], blocksize)
                  }

                  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
                  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
                  for (var i = 0; i < blocksize; i++) {
                    ipad[i] = key[i] ^ 0x36
                    opad[i] = key[i] ^ 0x5C
                  }

                  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
                  ipad.copy(ipad1, 0, 0, blocksize)
                  this.ipad1 = ipad1
                  this.ipad2 = ipad
                  this.opad = opad
                  this.alg = alg
                  this.blocksize = blocksize
                  this.hash = hash
                  this.size = sizes[alg]
                }

                Hmac.prototype.run = function (data, ipad) {
                  data.copy(ipad, this.blocksize)
                  var h = this.hash(ipad)
                  h.copy(this.opad, this.blocksize)
                  return this.hash(this.opad)
                }

                function getDigest (alg) {
                  function shaFunc (data) {
                    return new sha512().update(data).digest()
                  }
                  return shaFunc
                }

                function pbkdf2 (password, salt, iterations, keylen, digest) {
                  checkParameters(iterations, keylen)
                  password = toBuffer(password, defaultEncoding, 'Password')
                  salt = toBuffer(salt, defaultEncoding, 'Salt')

                  digest = digest || 'sha1'

                  var hmac = new Hmac(digest, password, salt.length)

                  var DK = Buffer.allocUnsafe(keylen)
                  var block1 = Buffer.allocUnsafe(salt.length + 4)
                  salt.copy(block1, 0, 0, salt.length)

                  var destPos = 0
                  var hLen = sizes[digest]
                  var l = Math.ceil(keylen / hLen)

                  for (var i = 1; i <= l; i++) {
                    block1.writeUInt32BE(i, salt.length)

                    var T = hmac.run(block1, hmac.ipad1)
                    var U = T

                    for (var j = 1; j < iterations; j++) {
                      U = hmac.run(U, hmac.ipad2)
                      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
                    }

                    T.copy(DK, destPos)
                    destPos += hLen
                  }

                  return DK
                }

                const exports = {};
                let DEFAULT_WORDLIST = _wordlists_1._default;
                const INVALID_MNEMONIC = 'Invalid mnemonic';
                const INVALID_ENTROPY = 'Invalid entropy';
                const INVALID_CHECKSUM = 'Invalid mnemonic checksum';
                const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\n' +
                    'Please explicitly pass a 2048 word array explicitly.';

                function lpad(str, padString, length) {
                    while (str.length < length)
                        str = padString + str;
                    return str;
                }
                function binaryToByte(bin) {
                    return parseInt(bin, 2);
                }
                function bytesToBinary(bytes) {
                    return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');
                }
                function deriveChecksumBits(entropyBuffer) {
                    const ENT = entropyBuffer.length * 8;
                    const CS = ENT / 32;
                    //const hash = createHash('sha256').update(entropyBuffer).digest();
                    const hash = bitcoin.crypto.sha256(entropyBuffer);
                    return bytesToBinary([...hash]).slice(0, CS);
                }
                function salt(password) {
                    return 'mnemonic' + (password || '');
                }
                function mnemonicToSeedSync(mnemonic, password) {
                    const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
                    const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
                    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');
                }
                // exports.mnemonicToSeedSync = mnemonicToSeedSync;
                async function mnemonicToSeed(mnemonic, password) {
                    return new Promise((resolve, reject) => {
                        try {
                            const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');
                            const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');
                            const data = pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');

                            return resolve(data);
                            /*pbkdf2_1.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {
                                if (err)
                                    return reject(err);
                                else
                                    return resolve(data);
                            });*/
                        }
                        catch (error) {
                            return reject(error);
                        }
                    });
                }
                exports.mnemonicToSeed = mnemonicToSeed;
                function mnemonicToEntropy(mnemonic, wordlist) {
                    wordlist = wordlist || DEFAULT_WORDLIST;
                    if (!wordlist) {
                        throw new Error(WORDLIST_REQUIRED);
                    }
                    const words = (mnemonic || '').normalize('NFKD').split(' ');
                    if (words.length % 3 !== 0)
                        throw new Error(INVALID_MNEMONIC);
                    // convert word indices to 11 bit binary strings
                    const bits = words
                        .map(word => {
                        const index = wordlist.indexOf(word);
                        if (index === -1)
                            throw new Error(INVALID_MNEMONIC);
                        return lpad(index.toString(2), '0', 11);
                    }).join('');
                    // split the binary string into ENT/CS
                    const dividerIndex = Math.floor(bits.length / 33) * 32;
                    const entropyBits = bits.slice(0, dividerIndex);
                    const checksumBits = bits.slice(dividerIndex);
                    // calculate the checksum and compare
                    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
                    if (entropyBytes.length < 16)
                        throw new Error(INVALID_ENTROPY);
                    if (entropyBytes.length > 32)
                        throw new Error(INVALID_ENTROPY);
                    if (entropyBytes.length % 4 !== 0)
                        throw new Error(INVALID_ENTROPY);
                    const entropy = Buffer.from(entropyBytes);
                    const newChecksum = deriveChecksumBits(entropy);
                    if (newChecksum !== checksumBits)
                        throw new Error(INVALID_CHECKSUM);
                    return entropy.toString('hex');
                }
                exports.mnemonicToEntropy = mnemonicToEntropy;
                function entropyToMnemonic(entropy, wordlist) {
                    if (!Buffer.isBuffer(entropy))
                        entropy = Buffer.from(entropy, 'hex');
                    wordlist = wordlist || DEFAULT_WORDLIST;
                    if (!wordlist) {
                        throw new Error(WORDLIST_REQUIRED);
                    }
                    // 128 <= ENT <= 256
                    if (entropy.length < 16)
                        throw new TypeError(INVALID_ENTROPY);
                    if (entropy.length > 32)
                        throw new TypeError(INVALID_ENTROPY);
                    if (entropy.length % 4 !== 0)
                        throw new TypeError(INVALID_ENTROPY);
                    const entropyBits = bytesToBinary([...entropy]);
                    const checksumBits = deriveChecksumBits(entropy);
                    const bits = entropyBits + checksumBits;
                    const chunks = bits.match(/(.{1,11})/g);
                    const words = chunks.map(binary => {
                        const index = binaryToByte(binary);
                        return wordlist[index];
                    });
                    return wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093' // Japanese wordlist
                        ? words.join('\u3000')
                        : words.join(' ');
                }
                exports.entropyToMnemonic = entropyToMnemonic;
                function generateMnemonic(strength, rng, wordlist) {
                    strength = strength || 128;
                    if (strength % 32 !== 0)
                        throw new TypeError(INVALID_ENTROPY);
                    if (!rng)
                        rng = x => crypto.getRandomValues(new Uint8Array(x));
                    return entropyToMnemonic(rng(strength / 8), wordlist);
                }
                exports.generateMnemonic = generateMnemonic;
                function validateMnemonic(mnemonic, wordlist) {
                    try {
                        mnemonicToEntropy(mnemonic, wordlist);
                    }
                    catch (e) {
                        return false;
                    }
                    return true;
                }
                exports.validateMnemonic = validateMnemonic;
                function setDefaultWordlist(language) {
                    const result = _wordlists_1.wordlists[language];
                    if (result)
                        DEFAULT_WORDLIST = result;
                    else
                        throw new Error('Could not find wordlist for language "' + language + '"');
                }
                exports.setDefaultWordlist = setDefaultWordlist;
                function getDefaultWordlist() {
                    if (!DEFAULT_WORDLIST)
                        throw new Error('No Default Wordlist set');
                    return Object.keys(_wordlists_1.wordlists).filter(lang => {
                        if (lang === 'JA' || lang === 'EN')
                            return false;
                        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
                    })[0];
                }
                exports.getDefaultWordlist = getDefaultWordlist;
                exports.wordlists = _wordlists_1.wordlists;

                return exports;
            })();
        </script>
        <script type="text/javascript">
            var bip32 = (() => {
                const v = valibot;

                function anumber(n) {
                    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
                }
                function afn(input) {
                    if (typeof input !== 'function') throw new Error('function expected');
                    return true;
                }
                function isArrayOf(isString, arr) {
                  if (!Array.isArray(arr)) return false;
                  if (arr.length === 0) return true;
                  if (isString) {
                    return arr.every((item) => typeof item === 'string');
                  } else {
                    return arr.every((item) => Number.isSafeInteger(item));
                  }
                }
                function astr(label, input) {
                  if (typeof input !== 'string') throw new Error(`${label}: string expected`);
                  return true;
                }
                function join(separator = '') {
                  astr('join', separator);
                  return {
                    encode: (from) => {
                      astrArr('join.decode', from);
                      return from.join(separator);
                    },
                    decode: (to) => {
                      astr('join.decode', to);
                      return to.split(separator);
                    },
                  };
                }
                function astrArr(label, input) {
                  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
                }
                function aArr(input) {
                    if (!Array.isArray(input)) throw new Error('array expected');
                }
                function anumArr(label, input) {
                    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
                }
                function isBytes(a) {
                  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
                }
                function convertRadix(data, from, to) {
                  // base 1 is impossible
                  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
                  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
                  aArr(data);
                  if (!data.length) return [];
                  let pos = 0;
                  const res = [];
                  const digits = Array.from(data, (d) => {
                    anumber(d);
                    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
                    return d;
                  });
                  const dlen = digits.length;
                  while (true) {
                    let carry = 0;
                    let done = true;
                    for (let i = pos; i < dlen; i++) {
                      const digit = digits[i];
                      const fromCarry = from * carry;
                      const digitBase = fromCarry + digit;
                      if (
                        !Number.isSafeInteger(digitBase) ||
                        fromCarry / from !== carry ||
                        digitBase - digit !== fromCarry
                      ) {
                        throw new Error('convertRadix: carry overflow');
                      }
                      const div = digitBase / to;
                      carry = digitBase % to;
                      const rounded = Math.floor(div);
                      digits[i] = rounded;
                      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                        throw new Error('convertRadix: carry overflow');
                      if (!done) continue;
                      else if (!rounded) pos = i;
                      else done = false;
                    }
                    res.push(carry);
                    if (done) break;
                  }
                  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);
                  return res.reverse();
                }
                function radix(num) {
                  anumber(num);
                  const _256 = 2 ** 8;
                  return {
                    encode: (bytes) => {
                      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
                      return convertRadix(Array.from(bytes), _256, num);
                    },
                    decode: (digits) => {
                      anumArr('radix.decode', digits);
                      return Uint8Array.from(convertRadix(digits, num, _256));
                    },
                  };
                }
                function alphabet(letters) {
                  // mapping 1 to "b"
                  const lettersA = typeof letters === 'string' ? letters.split('') : letters;
                  const len = lettersA.length;
                  astrArr('alphabet', lettersA);

                  // mapping "b" to 1
                  const indexes = new Map(lettersA.map((l, i) => [l, i]));
                  return {
                    encode: (digits) => {
                      aArr(digits);
                      return digits.map((i) => {
                        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
                          throw new Error(
                            `alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`
                          );
                        return lettersA[i];
                      });
                    },
                    decode: (input) => {
                      aArr(input);
                      return input.map((letter) => {
                        astr('alphabet.decode', letter);
                        const i = indexes.get(letter);
                        if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                        return i;
                      });
                    },
                  };
                }
                function readUInt32(buffer, offset, littleEndian) {
                    if (offset + 4 > buffer.length) {
                        throw new Error("Offset is outside the bounds of Uint8Array");
                    }
                    littleEndian = littleEndian.toUpperCase();
                    if (littleEndian === "LE") {
                        let num = 0;
                        num = ((num << 8) + buffer[offset + 3]) >>> 0;
                        num = ((num << 8) + buffer[offset + 2]) >>> 0;
                        num = ((num << 8) + buffer[offset + 1]) >>> 0;
                        num = ((num << 8) + buffer[offset]) >>> 0;
                        return num;
                    }
                    else {
                        let num = 0;
                        num = ((num << 8) + buffer[offset]) >>> 0;
                        num = ((num << 8) + buffer[offset + 1]) >>> 0;
                        num = ((num << 8) + buffer[offset + 2]) >>> 0;
                        num = ((num << 8) + buffer[offset + 3]) >>> 0;
                        return num;
                    }
                }
                function writeUInt32(buffer, offset, value, littleEndian) {
                    if (offset + 4 > buffer.length) {
                        throw new Error("Offset is outside the bounds of Uint8Array");
                    }
                    littleEndian = littleEndian.toUpperCase();
                    if (value > 0xffffffff) {
                        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffffff}. Received ${value}`);
                    }
                    if (littleEndian === "LE") {
                        buffer[offset] = value & 0xff;
                        buffer[offset + 1] = (value >> 8) & 0xff;
                        buffer[offset + 2] = (value >> 16) & 0xff;
                        buffer[offset + 3] = (value >> 24) & 0xff;
                    }
                    else {
                        buffer[offset] = (value >> 24) & 0xff;
                        buffer[offset + 1] = (value >> 16) & 0xff;
                        buffer[offset + 2] = (value >> 8) & 0xff;
                        buffer[offset + 3] = value & 0xff;
                    }
                }
                function writeUInt8(buffer, offset, value) {
                    if (offset + 1 > buffer.length) {
                        throw new Error("Offset is outside the bounds of Uint8Array");
                    }
                    if (value > 0xff) {
                        throw new Error(`The value of "value" is out of range. It must be >= 0 and <= ${0xff}. Received ${value}`);
                    }
                    buffer[offset] = value;
                }

                function chain(...args) {
                    const id = (a) => a;
                    // Wrap call in closure so JIT can inline calls
                    const wrap = (a, b) => (c) => a(b(c));
                    // Construct chain of args[-1].encode(args[-2].encode([...]))
                    const encode = args.map((x) => x.encode).reduceRight(wrap, id);
                    // Construct chain of args[0].decode(args[1].decode(...))
                    const decode = args.map((x) => x.decode).reduce(wrap, id);
                    return { encode, decode };
                }

                function fromHex(hexString) {
                    return Uint8Array.from(new TextEncoder('hex').encode(hexString || ""))//Buffer.from(hexString || "", "hex"));
                }
                const h = (hex) => fromHex(hex);
                function testEcc(ecc) {
                    assert(ecc.isPoint(h('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
                    assert(!ecc.isPoint(h('030000000000000000000000000000000000000000000000000000000000000005')));
                    assert(ecc.isPrivate(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')));
                    // order - 1
                    assert(ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')));
                    // 0
                    assert(!ecc.isPrivate(h('0000000000000000000000000000000000000000000000000000000000000000')));
                    // order
                    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141')));
                    // order + 1
                    assert(!ecc.isPrivate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142')));
                    assert(tools.compare(ecc.pointFromScalar(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99')) === 0);
                    if (ecc.xOnlyPointAddTweak) {
                        assert(ecc.xOnlyPointAddTweak(h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === null);
                        let xOnlyRes = ecc.xOnlyPointAddTweak(h('1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b'), h('a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac'));
                        assert(tools.compare(xOnlyRes.xOnlyPubkey, h('e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf')) === 0 && xOnlyRes.parity === 1);
                        xOnlyRes = ecc.xOnlyPointAddTweak(h('2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991'), h('823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47'));
                    }
                    assert(tools.compare(ecc.pointAddScalar(h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('0000000000000000000000000000000000000000000000000000000000000003')), h('02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5')) === 0);
                    assert(tools.compare(ecc.privateAdd(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e'), h('0000000000000000000000000000000000000000000000000000000000000002')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
                    if (ecc.privateNegate) {
                        assert(tools.compare(ecc.privateNegate(h('0000000000000000000000000000000000000000000000000000000000000001')), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')) === 0);
                        assert(tools.compare(ecc.privateNegate(h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e')), h('0000000000000000000000000000000000000000000000000000000000000003')) === 0);
                        assert(tools.compare(ecc.privateNegate(h('b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af')), h('4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792')) === 0);
                    }
                    assert(tools.compare(ecc.sign(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140')), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')) === 0);
                    assert(ecc.verify(h('5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed'), h('0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'), h('54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5')));
                    if (ecc.signSchnorr) {
                        assert(tools.compare(ecc.signSchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9'), h('c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906')), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')) === 0);
                    }
                    if (ecc.verifySchnorr) {
                        assert(ecc.verifySchnorr(h('7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c'), h('dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8'), h('5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7')));
                    }
                }
                function assert(bool) {
                    if (!bool)
                        throw new Error('ecc library invalid');
                }

                const Uint32Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xffffffff));
                const Uint31Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0x7fffffff));
                const Uint8Schema = v.pipe(v.number(), v.integer(), v.minValue(0), v.maxValue(0xff));
                const Buffer256Bit = v.pipe(v.instance(Uint8Array), v.length(32));
                const Buffer33Bytes = v.pipe(v.instance(Uint8Array), v.length(33));
                const NetworkSchema = v.object({
                    wif: Uint8Schema,
                    bip32: v.object({
                        public: Uint32Schema,
                        private: Uint32Schema,
                    }),
                });
                const Bip32PathSchema = v.pipe(v.string(), v.regex(/^(m\/)?(\d+'?\/)*\d+'?$/));
                function BIP32Factory(ecc) {
                    //testEcc(ecc);
                    const BITCOIN = {
                        messagePrefix: '\x18Bitcoin Signed Message:\n',
                        bech32: 'bc',
                        bip32: {
                            public: 0x0488b21e,
                            private: 0x0488ade4,
                        },
                        pubKeyHash: 0x00,
                        scriptHash: 0x05,
                        wif: 0x80,
                    };
                    const HIGHEST_BIT = 0x80000000;
                    function toXOnly(pubKey) {
                        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
                    }
                    class Bip32Signer {
                        __D;
                        __Q;
                        lowR = false;
                        constructor(__D, __Q) {
                            this.__D = __D;
                            this.__Q = __Q;
                        }
                        get publicKey() {
                            if (this.__Q === undefined)
                                this.__Q = ecc.pointFromScalar(this.__D, true);
                            return this.__Q;
                        }
                        get privateKey() {
                            return this.__D;
                        }
                        sign(hash, lowR) {
                            if (!this.privateKey)
                                throw new Error('Missing private key');
                            if (lowR === undefined)
                                lowR = this.lowR;
                            if (lowR === false) {
                                return ecc.sign(hash, this.privateKey);
                            }
                            else {
                                let sig = ecc.sign(hash, this.privateKey);
                                const extraData = new Uint8Array(32);
                                let counter = 0;
                                // if first try is lowR, skip the loop
                                // for second try and on, add extra entropy counting up
                                while (sig[0] > 0x7f) {
                                    counter++;
                                    writeUInt32(extraData, 0, counter, 'LE');
                                    sig = ecc.sign(hash, this.privateKey, extraData);
                                }
                                return sig;
                            }
                        }
                        signSchnorr(hash) {
                            if (!this.privateKey)
                                throw new Error('Missing private key');
                            if (!ecc.signSchnorr)
                                throw new Error('signSchnorr not supported by ecc library');
                            return ecc.signSchnorr(hash, this.privateKey);
                        }
                        verify(hash, signature) {
                            return ecc.verify(hash, this.publicKey, signature);
                        }
                        verifySchnorr(hash, signature) {
                            if (!ecc.verifySchnorr)
                                throw new Error('verifySchnorr not supported by ecc library');
                            return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
                        }
                    }
                    class BIP32 extends Bip32Signer {
                        chainCode;
                        network;
                        __DEPTH;
                        __INDEX;
                        __PARENT_FINGERPRINT;
                        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {
                            super(__D, __Q);
                            this.chainCode = chainCode;
                            this.network = network;
                            this.__DEPTH = __DEPTH;
                            this.__INDEX = __INDEX;
                            this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
                            v.parse(NetworkSchema, network);
                        }
                        get depth() {
                            return this.__DEPTH;
                        }
                        get index() {
                            return this.__INDEX;
                        }
                        get parentFingerprint() {
                            return this.__PARENT_FINGERPRINT;
                        }
                        get identifier() {
                            return bitcoin.crypto.ripemd160(bitcoin.crypto.sha256(this.publicKey));
                        }
                        get fingerprint() {
                            return this.identifier.slice(0, 4);
                        }
                        get compressed() {
                            return true;
                        }
                        // Private === not neutered
                        // Public === neutered
                        isNeutered() {
                            return this.__D === undefined;
                        }
                        neutered() {
                            return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
                        }
                        toBase58() {
                            const network = this.network;
                            const version = !this.isNeutered()
                                ? network.bip32.private
                                : network.bip32.public;
                            const buffer = new Uint8Array(78);
                            // 4 bytes: version bytes
                            writeUInt32(buffer, 0, version, 'BE');
                            // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....
                            writeUInt8(buffer, 4, this.depth);
                            // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
                            writeUInt32(buffer, 5, this.parentFingerprint, 'BE');
                            // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
                            // This is encoded in big endian. (0x00000000 if master key)
                            writeUInt32(buffer, 9, this.index, 'BE');
                            // 32 bytes: the chain code
                            buffer.set(this.chainCode, 13);
                            // 33 bytes: the public key or private key data
                            if (!this.isNeutered()) {
                                // 0x00 + k for private keys
                                writeUInt8(buffer, 45, 0);
                                buffer.set(this.privateKey, 46);
                                // 33 bytes: the public key
                            }
                            else {
                                // X9.62 encoding for public keys
                                buffer.set(this.publicKey, 45);
                            }
                            return bs58check.encode(buffer);
                        }
                        toWIF() {
                            if (!this.privateKey)
                                throw new TypeError('Missing private key');
                            return wif.encode({
                                version: this.network.wif,
                                privateKey: this.privateKey,
                                compressed: true,
                            });
                        }
                        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
                        derive(index) {
                            v.parse(Uint32Schema, index);
                            const isHardened = index >= HIGHEST_BIT;
                            const data = new Uint8Array(37);
                            // Hardened child
                            if (isHardened) {
                                if (this.isNeutered())
                                    throw new TypeError('Missing private key for hardened child key');
                                // data = 0x00 || ser256(kpar) || ser32(index)
                                data[0] = 0x00;
                                data.set(this.privateKey, 1);
                                writeUInt32(data, 33, index, 'BE');
                                // Normal child
                            }
                            else {
                                // data = serP(point(kpar)) || ser32(index)
                                //      = serP(Kpar) || ser32(index)
                                data.set(this.publicKey, 0);
                                writeUInt32(data, 33, index, 'BE');
                            }
                            const I = hmacSHA512(this.chainCode, data);
                            const IL = I.slice(0, 32);
                            const IR = I.slice(32);
                            // if parse256(IL) >= n, proceed with the next value for i
                            if (!ecc.isPrivate(IL))
                                return this.derive(index + 1);
                            // Private parent key -> private child key
                            let hd;
                            if (!this.isNeutered()) {
                                // ki = parse256(IL) + kpar (mod n)
                                const ki = ecc.privateAdd(this.privateKey, IL);
                                // In case ki == 0, proceed with the next value for i
                                if (ki == null)
                                    return this.derive(index + 1);
                                hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, readUInt32(this.fingerprint, 0, 'BE'));
                                // Public parent key -> public child key
                            }
                            else {
                                // Ki = point(parse256(IL)) + Kpar
                                //    = G*IL + Kpar
                                const Ki = ecc.pointAddScalar(this.publicKey, IL, true);
                                // In case Ki is the point at infinity, proceed with the next value for i
                                if (Ki === null)
                                    return this.derive(index + 1);
                                hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, readUInt32(this.fingerprint, 0, 'BE'));
                            }
                            return hd;
                        }
                        deriveHardened(index) {
                            if (typeof v.parse(Uint31Schema, index) === 'number')
                                // Only derives hardened private keys by default
                                return this.derive(index + HIGHEST_BIT);
                            throw new TypeError('Expected UInt31, got ' + index);
                        }
                        derivePath(path) {
                            v.parse(Bip32PathSchema, path);
                            let splitPath = path.split('/');
                            if (splitPath[0] === 'm') {
                                if (this.parentFingerprint)
                                    throw new TypeError('Expected master, got child');
                                splitPath = splitPath.slice(1);
                            }
                            return splitPath.reduce((prevHd, indexStr) => {
                                let index;
                                if (indexStr.slice(-1) === `'`) {
                                    index = parseInt(indexStr.slice(0, -1), 10);
                                    return prevHd.deriveHardened(index);
                                }
                                else {
                                    index = parseInt(indexStr, 10);
                                    return prevHd.derive(index);
                                }
                            }, this);
                        }
                        tweak(t) {
                            if (this.privateKey)
                                return this.tweakFromPrivateKey(t);
                            return this.tweakFromPublicKey(t);
                        }
                        tweakFromPublicKey(t) {
                            const xOnlyPubKey = toXOnly(this.publicKey);
                            if (!ecc.xOnlyPointAddTweak)
                                throw new Error('xOnlyPointAddTweak not supported by ecc library');
                            const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t);
                            if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
                                throw new Error('Cannot tweak public key!');
                            const parityByte = Uint8Array.from([
                                tweakedPublicKey.parity === 0 ? 0x02 : 0x03,
                            ]);
                            const tweakedPublicKeyCompresed = tools.concat([
                                parityByte,
                                tweakedPublicKey.xOnlyPubkey,
                            ]);
                            return new Bip32Signer(undefined, tweakedPublicKeyCompresed);
                        }
                        tweakFromPrivateKey(t) {
                            const hasOddY = this.publicKey[0] === 3 ||
                                (this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1);
                            const privateKey = (() => {
                                if (!hasOddY)
                                    return this.privateKey;
                                else if (!ecc.privateNegate)
                                    throw new Error('privateNegate not supported by ecc library');
                                else
                                    return ecc.privateNegate(this.privateKey);
                            })();
                            const tweakedPrivateKey = ecc.privateAdd(privateKey, t);
                            if (!tweakedPrivateKey)
                                throw new Error('Invalid tweaked private key!');
                            return new Bip32Signer(tweakedPrivateKey, undefined);
                        }
                    }
                    function fromBase58 (inString, network) {
                        const buffer = bs58check.decode(inString);
                        if (buffer.length !== 78)
                            throw new TypeError('Invalid buffer length');
                        network = network || BITCOIN;
                        // 4 bytes: version bytes
                        const version = readUInt32(buffer, 0, 'BE');
                        if (version !== network.bip32.private && version !== network.bip32.public)
                            throw new TypeError('Invalid network version');
                        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...
                        const depth = buffer[4];
                        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)
                        const parentFingerprint = readUInt32(buffer, 5, 'BE');
                        if (depth === 0) {
                            if (parentFingerprint !== 0x00000000)
                                throw new TypeError('Invalid parent fingerprint');
                        }
                        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.
                        // This is encoded in MSB order. (0x00000000 if master key)
                        const index = readUInt32(buffer, 9, 'BE');
                        if (depth === 0 && index !== 0)
                            throw new TypeError('Invalid index');
                        // 32 bytes: the chain code
                        const chainCode = buffer.slice(13, 45);
                        let hd;
                        // 33 bytes: private key data (0x00 + k)
                        if (version === network.bip32.private) {
                            if (buffer[45] !== 0x00)
                                throw new TypeError('Invalid private key');
                            const k = buffer.slice(46, 78);
                            hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);
                            // 33 bytes: public key data (0x02 + X or 0x03 + X)
                        }
                        else {
                            const X = buffer.slice(45, 78);
                            hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
                        }
                        return hd;
                    }
                    function fromPrivateKey(privateKey, chainCode, network) {
                        return fromPrivateKeyLocal(privateKey, chainCode, network);
                    }
                    function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
                        v.parse(Buffer256Bit, privateKey);
                        v.parse(Buffer256Bit, chainCode);
                        network = network || BITCOIN;
                        if (!ecc.isPrivate(privateKey))
                            throw new TypeError('Private key not in range [1, n)');
                        return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);
                    }
                    function fromPublicKey(publicKey, chainCode, network) {
                        return fromPublicKeyLocal(publicKey, chainCode, network);
                    }
                    function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
                        v.parse(Buffer33Bytes, publicKey);
                        v.parse(Buffer256Bit, chainCode);
                        network = network || BITCOIN;
                        // verify the X coordinate is a point on the curve
                        if (!ecc.isPoint(publicKey))
                            throw new TypeError('Point is not on the curve');
                        return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);
                    }
                    function fromSeed(seed, network) {
                        v.parse(v.instance(Uint8Array), seed);
                        if (seed.length < 16)
                            throw new TypeError('Seed should be at least 128 bits');
                        if (seed.length > 64)
                            throw new TypeError('Seed should be at most 512 bits');
                        network = network || BITCOIN;
                        const I = hmacSHA512(Uint8Array.from(Buffer.from('Bitcoin seed', 'utf8')), seed);
                        const IL = Buffer.from(I.slice(0, 32));
                        const IR = Buffer.from(I.slice(32));

                        return fromPrivateKey(IL, IR, network);
                    }
                    function hmac (Hash, key, msg, blockSize = 128) {
                        let inner, outer;
                        key = [].slice.call(key);

                        if (key.length > blockSize) key = new Hash().update(key).digest();
                        while (key.length < blockSize) key.push(0);

                        inner = new Hash().update(Buffer.from(key = key.map(k => k ^ 54)));
                        outer = new Hash().update(Buffer.from(key.map(k => k ^ 106)));

                        inner.update(msg);
                        outer.update(inner.digest());
                        return outer.digest();
                    }
                    function hmacSHA512 (key, data) {
                        return hmac(sha512, key, data, 128);
                        //return pbkdf2.hmac(sha512, key, data, 128);
                    }

                    return {
                        fromSeed,
                        fromBase58,
                        fromPublicKey,
                        fromPrivateKey,
                    };
                }

                const bip32 = BIP32Factory(ecc);
                return bip32;
            })();
        </script>
        <style>
            * { padding: 0; margin: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
            html { overflow-x: hidden; }
            body { width: 100%; min-width: 320px; margin: 0 auto; overflow-x: hidden; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;}
            .extension-mode body { width: 380px; min-height: 600px; }
            button, input, select, optgroup, textarea { font: inherit; font-feature-settings: inherit; font-variation-settings: inherit; letter-spacing: inherit; color: inherit; opacity: 1;}
            textarea { width: 100%; font-size: 0.75rem; appearance: none; resize: vertical; display: block; }
            input[type="text"], input[type="number"] { width: 100%; height: 2rem; line-height: 2rem; padding-left: 0.35rem; font-size: 0.85rem; appearance: none; border: 1px solid light-dark(rgb(118, 118, 118), rgb(133, 133, 133)); }
            input[disabled="true"] { background-color: #fbf9fa; border-color: #ebe6e7; color: #9E9E9E}
            input[type="text"]:focus {}
            button { border-radius: 0.2rem; background-color: #1447e6; color: #fff; border: 0px;  padding: .5rem 0; }
            button[disabled="true"] { background-color: #ebe6e7; color: #9E9E9E }

            header { display: flex; justify-content: space-between; background: #151821; border-bottom: 1px solid #222;}
            .logo { display: flex; padding: .5rem .75rem;  align-items: center; gap: 12px;}
            .logo h1 { margin: 0; font-size: 22px; font-weight: 600; letter-spacing: 1px; color: #f7931a;}
            footer { font-size: 0.85rem; padding: 0 .75rem .5rem .75rem; }
            .wrapper { padding: 0.5rem 0.75rem 0 .75rem; position: relative; }
            .field { margin: 1rem 0 0 0; font-size: 0.85rem;}
            .wrapper .field:last-child { margin: 0; }
            .version { font-size: .75rem; font-weight: 400; }
            .warning-banner {padding: .35rem .75rem; font-size: .75rem; background: linear-gradient(90deg, #fff4c2, #ffe58f); color: #664d03; word-break: break-word;}
            #tree, #bip32Tree { margin-left: -26px; font-size: .95rem; }
            .tree details:last-child {background-size: 1px 12px;}
            .tree>details:not(:last-child)>details:last-child {background-size: 1px 100%;}
            .tree details { padding-left: 30px; background: repeating-linear-gradient( #999 0 1px,transparent 0px 2px) 30px 0px/1px 100% no-repeat;/* background: linear-gradient(#999, #999) 40px 0px/1px 100% no-repeat; */}
            .tree>details {background: none; padding-left: 0;}
            .tree>details>summary {background: none;}
            .tree summary {display: flex; align-items: center; white-space: nowrap; min-width: 0; width: calc(100% - 1rem); height:1.5rem; line-height: 1.5rem; cursor: default; outline: 0; padding-left: 20px; overflow: hidden;text-overflow: ellipsis; white-space: nowrap; list-style: none;
                background: repeating-linear-gradient(90deg, #999 0 1px,transparent 0px 2px) 0px 50%/25px 1px no-repeat;/* background: linear-gradient(#999,#999) 0px 50%/20px 1px no-repeat; */}
            .tree summary::after {content: ''; width: calc(100% - 1.5rem); position: absolute; left: 10px; right: 0px; height: 28px; background: #EEF2FF; z-index: -1; opacity: 0; transition: .2s;}
            .tree summary:hover::after {opacity: 1;}
            .tree summary:not(:only-child)::before {content: ''; width: 8px; height: 8px; flex-shrink: 0; margin: 0 4px 0 6px;border: 1px solid #999; background: linear-gradient(#999, #999) 50%/1px 5px no-repeat,linear-gradient(#999, #999) 50%/5px 1px no-repeat;}
            .tree details[open]>summary::before {background: linear-gradient(#999, #999) 50%/4px 1px no-repeat;}
            .tree summary:last-child {background-size: 18px 1px;}
            #bip32Tree .tree-leaf summary { line-height: normal; font-size: 0.85rem; white-space: normal; overflow-wrap: break-word; word-break: break-word; word-break: break-all; }
            #utxos { }
            #signBtn { width: 100%; color: #fff; }
            #useMaxAmount { color: #2196F3 }
            #privateKey { padding: 0.25rem 0 0 0.25rem; }
            .select-all-on-touch { -webkit-user-select: all; user-select: all; }
            .field label {font-weight: 500;}
            .field > p { margin-bottom: 0.25rem; }
            .verify::after { color: #F44336; content: ' ✘'; }
            .wrapper.privateKey .field:has(#privateKey) .verify::after {content: ' ✔'; color: #009688;}
            .wrapper.utxos .field:has(#utxos) .verify::after {content: ' ✔'; color: #009688;}
            .wrapper.tree .field:has(#tree) .verify::after {content: ' ✔'; color: #009688;}
            .wrapper.fromAddress .field:has(#fromAddress) .verify::after {content: ' ✔'; color: #009688;}
            .wrapper.toAddress .field:has(#toAddress) .verify::after {content: ' ✔'; color: #009688;}
            #txTree { padding: .5rem 0; }

            #tx { word-break: break-word; }
            .purple-4 {color: #c084fc}
            .gray-4 {color: #a1a1aa}
            .lime-4 {color: #a3e635}
            .orange-4 {color: #fb923c}
            .rose-4 {color: #fb7185}
            /* ===== 移动端优化 ===== */
            @media (max-width: 480px) {
                textarea { /*font-size: 16px;*/ }
                #tree, #bip32Tree { font-size: .8rem; }
                #bip32Tree .tree-leaf summary { font-size: .7rem;  }
            }
        </style>
    </head>
    <body>
        <header>
            <div class="logo">
                <svg width="42" height="42" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">
                    <!-- Outer circle -->
                    <circle cx="32" cy="32" r="30" stroke="#f7931a" stroke-width="4" fill="none"/>
                    <!-- Air wave signal -->
                    <path d="M18 32 Q32 18 46 32" stroke="#f7931a" stroke-width="3" fill="none"/>
                    <path d="M22 32 Q32 22 42 32" stroke="#f7931a" stroke-width="2" fill="none"/>

                    <!-- Bitcoin B -->
                    <text x="32" y="40" text-anchor="middle" font-size="24" font-family="Arial, sans-serif" fill="#f7931a" font-weight="bold">
                    ₿
                    </text>
                </svg>
                <h1>AirBTC<span class="version">@1.1.0</span></h1>
            </div>
        </header>
        <p class="warning-banner">Client-side Bitcoin Transaction Signer — Fully offline. No server. No storage. Use at your own risk.</p>
        <div class="wrapper">
            <div class="field">
                <p class="verify">
                    <input type="radio" id="typeMnemonic" name="keyType" value="" checked />
                    <label for="typeMnemonic">Mnemonic (BIP39)</label>
                    <input type="radio" id="typeWif" name="keyType" value="" />
                    <label for="typeWif">Private Key (WIF)</label>
                </p>
                <textarea id="privateKey" onfocus="this.select();" rows="2" placeholder="letter advice cage absurd amount doctor acoustic avoid letter advice cage above"></textarea>
                <div id="bip32Tree"></div>
            </div>
            <div class="field">
                <p class="verify"><label for="utxos">UTXOs</label></p>
                <textarea id="utxos" rows="4" placeholder='{"from": "1Mcjtx...7Wmub", "to": "1EdGFM...DC6R", "utxos": []}'></textarea>
                <div id="tree"></div>
            </div>
            <div class="field">
                <p class="verify"><label for="fromAddress">From Address</label></p>
                <input type="text" id="fromAddress" name="fromAddress" value="" disabled="true" />
            </div>
            <div class="field">
                <p class="verify"><label for="toAddress">To Address</label></p>
                <input type="text" id="toAddress" name="toAddress" value="" disabled="true" />
            </div>
            <div class="field">
                <p><label for="amount">Amount (sats)</label> · Fee (sats) ~<span id="fee">0</span> · <a href="javascript:void(0);" id="useMaxAmount">Use max (<b>0</b> sats)</a></p>
                <input type="number" id="amount" name="amount" onfocus="this.select();" value="0" />
            </div>
            <div class="field"><button id="signBtn" disabled="true">SIGN TRANSACTION</button></div>
            <div class="field" id="tx">
                <div id="txTree"></div>
            </div>
        </div>
        <footer>
            <p class="footer-note"><font color="red">⚠</font> Use at your own risk. This tool does not store, transmit, or track keys or transactions.</p>
            <p><font>🔗</font> Click to download this page as a standalone <a href="javascript:void(0);" id="downloadPage" class="link-btn" title="const htmlContent = document.documentElement.outerHTML;
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'airbtc.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);">HTML file(<b>airbtc.html</b>)</a> so you can run it fully offline, or visit the repository to see the full source code, download the ZIP, and check version history: <a href="https://github.com/lflyend/airbtc" target="_blank" rel="noopener" class="link-anchor">View Source on GitHub</a></p>
        </footer>
        <script type="text/javascript">
            const runtime = (function moduleBootstrap (moduleTable, moduleCache, entryList) {
                function requireModule (moduleId, isFallback) {
                    if (!moduleCache[moduleId]) {
                        if (!moduleTable[moduleId]) {
                            const nativeRequire = typeof require === 'function' && require;

                            if (!isFallback && nativeRequire) return nativeRequire(moduleId, true);

                            if (previousRequire) return previousRequire(moduleId, true);

                            const error = new Error(`Cannot find module '${moduleId}'`);
                            error.code = 'MODULE_NOT_FOUND';
                            throw error;
                        }

                        const moduleRecord = moduleCache[moduleId] = { exports: {} };

                        moduleTable[moduleId][0].call(
                            moduleRecord.exports,
                            function resolveDependency(depName) {
                                const mappedId = moduleTable[moduleId][1][depName];
                                return requireModule(mappedId ? mappedId : depName);
                            },
                            moduleRecord,
                            moduleRecord.exports,
                            moduleBootstrap,
                            moduleTable,
                            moduleCache,
                            entryList
                        );
                    }

                    return moduleCache[moduleId].exports;
                }

                const previousRequire = typeof require === 'function' && require;

                for (let i = 0; i < entryList.length; i++) requireModule(entryList[i]);

                return requireModule;
            });
            runtime({
                'bitcoin@v6.js': [function (require, module, exports) {
                    module.exports = window.bitcoin;
                }, {}],
                'global.var': [function (require, module, exports) {
                    const attributeFilter = {
                        network: bitcoin.networks.bitcoin,
                        privateKey: 'letter advice cage absurd amount doctor acoustic avoid letter advice cage above',
                        utxos: `{"from": "1McjtxpqQQYR59v2cDp5HtjgbjrAr7Wmub", "to": "1EdGFMCzz2fUkoET5YTb4uRWDEfBNyDC6R", "utxos": []}`,
                        fromAddress: '',
                        toAddress: '',
                        amount: 0,
                        maxAmount: 0,
                        fee: 0
                    };
                    const ecPair = ECPairFactory(ecc);
                    //const qrcode = new QRCode(document.querySelector('#tx .tx-qrcode'));

                    bitcoin.initEccLib(ecc);

                    module.exports = {
                        attributeFilter,
                        ecPair
                    };
                }, {}],
                'bytes': [function (require, module, exports) {
                    const u32LE = n => Buffer.from([n & 0xff, (n >>> 8) & 0xff, (n >>> 16) & 0xff, (n >>> 24) & 0xff]);
                    const u64LE = (n, v = BigInt(n)) => Buffer.from(Array.from({ length: 8 }, (_, i) => Number((v >> BigInt(i << 3)) & 0xffn)));

                    module.exports = { u32LE, u64LE };
                }, {}],
                'selection.SelectionUTXOs': [function(require, module, exports) {
                    const detectType = require('detectType');
                    /*91 只是 P2SH-P2WPKH纯 P2SH， 多签可能是 296+，detectType() 只按前缀判断，这在实际多签钱包会出错。*/
                    const INPUT_VBYTES = { legacy: 148, segwit: 68, taproot: 57.5, p2sh: 91 };
                    const OUTPUT_VBYTES = { legacy: 34, segwit: 31, taproot: 43, p2sh: 32 };
                    const TX_OVERHEAD = 10.5;

                    class SelectionUTXOs {
                        constructor (data, feeRate = 5) {
                            this.init(data);
                            this.feeRate = feeRate;
                        }
                        init (data) {
                            this.utxos = data?.utxos ?? [];
                            this.fromAddress = data?.from ?? '';
                            this.toAddress = data?.to ?? '';
                            this.inputType = this.fromAddress ? detectType(this.fromAddress) : '';
                            this.outputType = this.toAddress ? detectType(this.toAddress) : '';
                        }
                        estimateFee (inputCount, outputCount) {
                            const utxos = this.utxos;
                            let vbytes = TX_OVERHEAD;

                            if (!this.inputType || !this.outputType) throw new Error('Address type not initialized');
                
                            for (let i = 0; i < inputCount; i++) vbytes += INPUT_VBYTES[this.inputType]; // inputs
                            for (let i = 0; i < outputCount; i++) vbytes += OUTPUT_VBYTES[this.outputType]; // outputs

                            return Math.ceil(vbytes * this.feeRate);
                        }
                        dustThreshold () {
                            const vb = OUTPUT_VBYTES[this.outputType];
                            return Math.ceil(vb * 3 * this.feeRate);
                        }
                        totalBalance () {
                            return this.utxos.reduce((a, b) => a + b.value, 0);
                        }
                        amountMax () {
                            const inputCount  = this.utxos.length;
                            const outputCount = 1;

                            const fee = this.estimateFee(inputCount, outputCount);
                            const total = this.totalBalance();

                            return Math.max(0, total - fee);
                        }
                        buildMax () {
                            const amount = this.amountMax();
                            
                            if (amount <= 0) throw new Error('Insufficient balance');

                            const fee = this.estimateFee(this.utxos.length, 1);

                            return {
                                selected: [...this.utxos],
                                amount,
                                fee,
                                change: 0
                            };
                        }
                        select (amount) {
                            if (amount <= 0) throw new Error('Invalid amount.');

                            const dust = this.dustThreshold();
                            const sorted = [...this.utxos].sort((a, b) => b.value - a.value);

                            let selected = [];
                            let sum = 0;

                            for (let i = 0; i < sorted.length; i++) {
                                selected.push(sorted[i]);
                                sum += sorted[i].value;

                                // 先假设有 change → 2 outputs
                                let fee = this.estimateFee(selected.length, 2);
                                let change = sum - amount - fee;

                                // 如果 change 为 dust 或 0 → 切换为 1 output
                                if (change <= dust) {
                                    fee = this.estimateFee(selected.length, 1);
                                    change = sum - amount - fee;

                                    if (change < 0) continue;

                                    return { selected, amount, fee, change: 0 };
                                }

                                if (change >= 0) return { selected, amount, fee, change };
                            }

                            throw new Error('Insufficient balance.');
                        }
                    }
                    
                    module.exports = SelectionUTXOs;
                }, {
                    'detectType': 'address.detectType'
                }],
                'btc.Transfer': [function(require, module, exports) {
                    const { ecPair } = require('global');

                    const isP2PKH = script => script.length === 25 &&
                        script[0] === 0x76 &&
                        script[1] === 0xa9 &&
                        script[2] === 0x14 &&
                        script[23] === 0x88 &&
                        script[24] === 0xac;
                    const isP2SH = script => script.length === 23 &&
                        script[0] === 0xa9 &&
                        script[1] === 0x14 &&
                        script[22] === 0x87;
                    const isP2WPKH = script => script.length === 22 &&
                        script[0] === 0x00 && script[1] === 0x14;
                    const isP2TR = script => script.length === 34 &&
                        script[0] === 0x51 && script[1] === 0x20;

                    function taggedHash (tag, data) {
                        const tagHash = bitcoin.crypto.sha256(Buffer.from(tag));
                        return bitcoin.crypto.sha256(Buffer.concat([tagHash, tagHash, data]));
                    }

                    function calcTweakedPrivateKey (privateKey, publicKey) {
                        const xOnly = publicKey.slice(1);

                        if (publicKey[0] === 0x03) {
                            privateKey = ecc.privateNegate(privateKey);
                        }

                        const tweak = taggedHash('TapTweak', xOnly);

                        const tweaked = ecc.privateAdd(privateKey, tweak);

                        if (!tweaked) throw new Error('Invalid tweak');

                        return tweaked;
                    }

                    class AdaptivePsbtBuilder {
                        constructor (network) {
                            this.network = network;
                            this.psbt = new bitcoin.Psbt({ network });
                            this.signers = new Map();
                        }
                        addInput (utxo, privateKey) {
                            const network = this.network;
                            const psbt = this.psbt;
                            const inputIndex = this.psbt.data.inputs.length;

                            const parentTx = bitcoin.Transaction.fromHex(utxo.tx);
                            const output = parentTx.outs[utxo.vout];
                            const script = output.script;

                            const base = { hash: utxo.txid, index: utxo.vout };
                            const witnessUtxo = { script, value: utxo.value };

                            let keyPair = ecPair.fromPrivateKey(privateKey, { network });

                            if (isP2PKH(script)) {
                                psbt.addInput({
                                    ...base,
                                    nonWitnessUtxo: Buffer.from(utxo.tx, 'hex')
                                });
                            }
                            else if (isP2WPKH(script)) {
                                psbt.addInput({ ...base, witnessUtxo });
                            }
                            else if (isP2SH(script)) {
                                const redeem = bitcoin.payments.p2wpkh({ pubkey: keyPair.publicKey, network }).output;
                                psbt.addInput({ ...base, witnessUtxo, redeemScript: redeem });
                            }
                            else if (isP2TR(script)) {
                                const pubkey = ecc.pointFromScalar(privateKey, true);
                                // const pubkey = ecc.secp256k1.getPublicKey(privateKey, true);
                                const internalPubkey = Buffer.from(pubkey.slice(1));
                                psbt.addInput({ ...base, witnessUtxo, tapInternalKey: internalPubkey });

                                const tweakedPrivkey = calcTweakedPrivateKey(privateKey, pubkey);
                                keyPair = {
                                    publicKey: Buffer.from(ecc.pointFromScalar(tweakedPrivkey, true)),
                                    signSchnorr: hash => {
                                        return Buffer.from(ecc.signSchnorr(hash, tweakedPrivkey));
                                    }
                                };
                            }
                            else {
                                throw new Error('Unsupported script type');
                            }

                            this.signers.set(inputIndex, keyPair);
                        }

                        addOutput (address, value) {
                            this.psbt.addOutput({ address, value });
                        }
                        signAll () {
                            for (const [index, signer] of this.signers.entries()) {
                                this.psbt.signInput(index, signer);
                            }
                        }
                        finalize () {
                            this.psbt.finalizeAllInputs();
                            return this.psbt.extractTransaction().toHex();
                        }
                    }

                    class Transfer {
                        constructor (utxo, selection) {
                            this.utxo = utxo;
                            this.selection = selection;
                        }
                        init (state) {
                            const utxo = this.utxo;
                            const selection = this.selection;

                            if (utxo) {
                                state.utxos = JSON.stringify(utxo);
                                state.fromAddress = utxo?.from;
                                state.toAddress = utxo.to;
                                state.maxAmount = selection.amountMax();
                            }
                            else {
                                state.utxos = '';
                            }
                            state.privateKey = '';
                            state.amount = 0;
                        }
                        async send (privateKey, amountSats, network) {
                            const selection = this.selection;
                            const { from: fromAddress, to: toAddress, utxos } = this.utxo;
                            const priv = wif.decode(privateKey);
                            const { selected, fee, change } = selection.select(amountSats);
                            
                            const builder = new AdaptivePsbtBuilder(network);

                            for (const utxo of selected) {
                                builder.addInput(utxo, priv.privateKey);
                            }

                            builder.addOutput(toAddress, amountSats);

                            if (change >= 546) {
                                builder.addOutput(fromAddress, change);
                            }

                            builder.signAll();

                            const txHex = builder.finalize();
                            return txHex;
                        }
                    }

                    module.exports = Transfer;
                }, {
                    'global': 'global.var',
                    'detectType': 'address.detectType'
                }],
                'address.BIP32': [function(require, module, exports) {
                    const bitcoin = require('bitcoin');
                    // letter advice cage absurd amount doctor acoustic avoid letter advice cage above
                    module.exports = async function (mnemonic, path, network) {
                        mnemonic = mnemonic.trim().toLowerCase();//.split(/\s+/);

                        if (!bip39.validateMnemonic(mnemonic)) return [];

                        const seed = await bip39.mnemonicToSeed(mnemonic);
                        const masterKey = bip32.fromSeed(seed, network);
                        const purpose = path.split('/')[1];
                        const nodes = [];

                        for (let i = 0; i < 5; i++) {
                            const node = masterKey.derivePath(path + '/' + i);
                            const priv = Buffer.from(node.privateKey);
                            const xpub = node.publicKey; // ecc.secp256k1.getPublicKey(priv, true);
                            const privWIF = wif.encode({
                                version: network.wif,
                                privateKey: priv,
                                compressed: true
                            });
                            let address = '';
                            if (purpose.startsWith('44')) {
                                address = bitcoin.payments.p2pkh({ pubkey: Buffer.from(xpub), network }).address;
                            }
                            else if (purpose.startsWith('49')) {
                                const redeemScript = [0x00, 0x14, ...bitcoin.crypto.hash160(xpub)];
                                const scriptHash = bitcoin.crypto.hash160(redeemScript);
                                address = bs58check.encode([network.scriptHash/*version*/, ...scriptHash]);
                            }
                            else if (purpose.startsWith('84')) {
                                address = bitcoin.payments.p2wpkh({ pubkey: Buffer.from(xpub), network }).address;
                            }
                            else if (purpose.startsWith('86')) {
                                address = bitcoin.payments.p2tr({ internalPubkey: Buffer.from(xpub.slice(1)), network }).address;
                            }

                            nodes.push({
                                text: address,
                                nodes: [{ text: privWIF }]
                            });
                        }

                        return nodes;
                    };
                }, {
                    'global': 'global.var',
                    bitcoin: 'bitcoin@v6.js'
                }],
                'object.watcher': [function (require, module, exports) {
                    const { attributeFilter } = require('global');
                    const attributeGetter = [];

                    function observe (attributeFilter = {}, attributeGetter = [], options) {
                        let observer;
                        let setter = (options = options || {}).set;

                        observer = {
                            get: function (target, key, receiver) {
                                if (target == null) return;
                                if (!attributeGetter.includes(key) && ({}).toString.call(target[key]) === "[object Object]") {
                                    return new Proxy(target[key], observer);
                                }
                                return target[key];// Reflect.get(target, key, receiver);
                            },
                            set: function (target, key, value, receiver) {
                                let oldValue, setted;

                                if (key in attributeFilter) {
                                    oldValue = Object.assign({}, target);
                                    setted = Reflect.set(target, key, value, receiver);
                                    setter && setter.call(target, target, oldValue, key, value);
                                    return setted;
                                }
                                return Reflect.set(target, key, value, receiver);
                            }
                        };

                        return observer;
                    }
                    function copyWatcher (data, attributeFilter) {
                        const copyData = Object.create(null);

                        for (const [key, val] of Object.entries(data)) {
                            // copyData[key] = Object.assign({}, attributeFilter, val);
                            copyData[key] = val;
                        }

                        return copyData;
                    }
                    function createWatcher (data, dispatch) {
                        const proxy = dispatch === false ? createNowatcher(data) : new Proxy(copyWatcher(data, attributeFilter), observe(attributeFilter, attributeGetter, {
                            set: function (newValue, oldValue, key, value) {
                                dispatch && dispatch(newValue, oldValue, key);
                            }
                        }));

                        return proxy;
                    }
                    function createMultipleWatcher () {
                        const state = {};
                        const effects = [];
                        const queue = new Set();
                        let flushing = false;

                        function schedule (effect, context) {
                            return new Promise(resolve => {
                                queue.add({ effect, context, resolve });

                                if (!flushing) {
                                    flushing = true;
                                    Promise.resolve().then(async () => {
                                        const jobs = Array.from(queue);
                                        queue.clear();
                                        flushing = false;

                                        for (const { effect, context, resolve } of jobs) {
                                            await runEffect(effect, context);
                                            resolve();
                                        }
                                    });
                                    /*Promise.resolve().then(() => {
                                        queue.forEach(({ effect, context, resolve }) => {
                                            runEffect(effect, context);
                                            resolve();
                                        });
                                        queue.clear();
                                        flushing = false;
                                    });*/
                                }
                            });
                        }

                        function watch (deps, fn) {
                            effects.push({ deps, fn, version: 0 });
                        }

                        function runEffect (effect, context) {
                            const currentVersion = ++effect.version;
                            const isLatest = () => currentVersion === effect.version;

                            return Promise.resolve(effect.fn(state, context, isLatest));
                        }
                        async function setState (key, value, context) {
                            state[key] = value;

                            const tasks = [];

                            for (const effect of effects) {
                                if (effect.deps.includes(key)) {
                                    tasks.push(schedule(effect, context));
                                }
                            }

                            await Promise.all(tasks);
                        }

                        return {
                            set: setState,
                            watch,
                            getState: () => state
                        };
                    }
                    function createObserver (targets, state, dispatch) {
                        targets.forEach(({ target, type, key }) => {
                            target.addEventListener(type, () => {
                                state[key] = target.value;
                            });
                        });
                    }

                    function keyBoolFilter (objects, keyOf, isBoolean = true) {
                        const result = Object.create(null);

                        for (const [key, value] of Object.entries(objects)) {
                            if (keyOf != null && value[keyOf] === isBoolean) result[key] = value;
                            else if (value === isBoolean) result[key] = value;
                        }

                        return result;
                    }

                    module.exports = { createWatcher, createMultipleWatcher, createObserver };
                }, {
                    'global': 'global.var'
                }],
                'dom.createTree': [function (require, module, exports) {
                    module.exports = function (data, el) {
                        const root = {
                            text: data.text ?? '',
                            open: 1,
                            nodes: data.nodes ?? [{ text: '' }]
                        };
                        
                        function dfs (root) {
                            (root || []).forEach((node, i) => {
                                const nodes = node.nodes;
                                html += `<details${node.open ? ' open' : ''}${!nodes || !nodes.length ? ' class="tree-leaf"' : ''}><summary>${node.text ?? i}</summary>`;
                                if (nodes) dfs(nodes);
                                html += `</details>`;
                            });
                        }

                        if (data.from != null || data.to != null) {
                            root.nodes = [{ text: `<b>from</b>: ${data.from}`, open: 1 }, { text: `<b>to</b>: ${data.to}`, open: 1 }];
                        }
                        //if (data.to != null) root.nodes.push({ text: `<b>to</b>: ${data.to}`, open: 1 });
                        if (data?.utxos?.length) {
                            //root.text = '<font color="#009688">✔</font>';
                            if (data.from == null && data.to == null) {
                                root.nodes = [{ text: `<b>from</b>: ${data.from}`, open: 1 }, { text: `<b>to</b>: ${data.to}`, open: 1 }];
                            }
                            root.nodes.push({
                                text: 'utxos',
                                nodes: data.utxos.map((d, i) => ({
                                    text: i,
                                    nodes: [{ text: `txid: ${d.txid}` }, { text: `vout: ${d.vout}` }, { text: `value: ${d.value}` }, { text: `tx: <span title="${d.tx}">${d.tx}</span>` }]
                                }))
                            });
                        }
                        
                        let html = '';
                        dfs([root]);
                        el.innerHTML = `<div class="tree">${html}</div>`;
                    };
                }, {}],
                'address.detectType': [function (require, module, exports) {
                    function detectType (address) {
                        if (!address) throw new Error('Invalid address');

                        if (address.startsWith('1') || address.startsWith('m') || address.startsWith('n')) return 'legacy';
                        if (address.startsWith('3') || address.startsWith('2')) return 'p2sh';
                        if (address.startsWith('bc1q') || address.startsWith('tb1q')) return 'segwit';
                        if (address.startsWith('bc1p') || address.startsWith('tb1p')) return 'taproot';

                        throw new Error('Unknown address type');
                    }
                    module.exports = detectType;
                }, {}],
                'address.detectNetwork': [function (require, module, exports) {
                    const networks = bitcoin.networks;

                    function detectNetwork (addr) {
                        if (!addr || typeof addr !== 'string') return networks.bitcoin;
                        const prefix = addr[0];
                        if (prefix === 'm' || prefix === 'n') return networks.testnet;
                        if (prefix === '2') return networks.testnet; // P2SH
                        if (addr.startsWith('bcrt')) return networks.regtest;
                        if (prefix === '1' || prefix === '3' || addr.startsWith('bc1')) return networks.bitcoin;
                        return networks.bitcoin;
                    }
                    module.exports = detectNetwork;
                }, {}],
                'address.verify': [function (require, module, exports) {
                    const { ecPair } = require('global');
                    const calcAddress = require('calcAddress');
                    const createTree = require('createTree');
                    const detectType = require('detectType');
                    // Legacy P2PKH                 1    BIP-44
                    // Nested SegWit P2WPKH-in-P2SH 3    BIP-49
                    // Native SegWit Bech32/P2WPKH  bc1q BIP-84
                    // Taproot Bech32m/P2TR         bc1p BIP-86
                    const addressType = { legacy: 44, segwit: 84, taproot: 86, p2sh: 49 }

                    module.exports = async function (privateKey, fromAddress, network) {
                        const addrType = fromAddress ? detectType(fromAddress) : 'legacy';
                        const selectedRadio = document.querySelector('input[name="keyType"]:checked');
                        let id = '';

                        if (selectedRadio) {
                            id = selectedRadio.getAttribute('id');
                            selectedRadio.value = privateKey;
                        }
                        
                        if (id === 'typeMnemonic') {
                            const path = `m/${addressType[addrType] ?? 44}'/0'/0'/0`;
                            const nodes = await calcAddress(privateKey, path, network);
                            const bip32Tree = document.querySelector('#bip32Tree');

                            if (nodes.length === 0) {
                                createTree({
                                    text: `BIP32(${path})`,
                                    nodes: [{ text: '' }]
                                }, bip32Tree);
                                return null;
                            }
                            
                            let existsAddress = null;

                            createTree({
                                text: `BIP32(${path})`,
                                nodes: nodes.map((d, i) => {
                                    const isExists = d.text === fromAddress;
                                    existsAddress = existsAddress || (isExists ? d.nodes[0].text : null);
                                    return {
                                        text: `<b>/${i}</b>: ${isExists ? `<b>${d.text}</b>` : d.text}`,
                                        nodes: d.nodes
                                    };
                                })
                            }, bip32Tree);

                            return existsAddress;
                        }
                        else {
                            const keyPair = ecPair.fromWIF(privateKey, network);
                            const xpub = keyPair.publicKey;
                            let address;

                            if (addrType === 'legacy') {
                                address = bitcoin.payments.p2pkh({ pubkey: Buffer.from(xpub), network }).address;
                            }
                            else if (addrType === 'p2sh') {
                                const redeemScript = [0x00, 0x14, ...bitcoin.crypto.hash160(xpub)];
                                const scriptHash = bitcoin.crypto.hash160(redeemScript);
                                address = bs58check.encode([network.scriptHash/*version*/, ...scriptHash]);
                            }
                            else if (addrType === 'segwit') {
                                address = bitcoin.payments.p2wpkh({ pubkey: Buffer.from(xpub), network }).address;
                            }
                            else if (addrType === 'taproot') {
                                address = bitcoin.payments.p2tr({ internalPubkey: Buffer.from(xpub.slice(1)), network }).address;
                            }

                            return keyPair.privateKey.length !== 32 || address !== fromAddress ? null : privateKey;
                        }

                        return null;
                    };
                }, {
                    'global': 'global.var',
                    'calcAddress': 'address.BIP32',
                    'createTree': 'dom.createTree',
                    'detectType': 'address.detectType'
                }],
                'verify': [function (require, module, exports) {
                    const SelectionUTXOs = require('SelectionUTXOs');
                    const createTree = require('createTree');
                    const addressVerify = require('addressVerify');
                    const detectNetwork = require('detectNetwork');
                    const { createMultipleWatcher } = require('object.watcher');
                    const watcher = createMultipleWatcher();
                    const classList = { privateKey: 0, utxos: 0, fromAddress: 0, toAddress: 0 };

                    watcher.watch(['privateKey', 'fromAddress'], async (state, context, isLatest) => {
                        const { privateKey, fromAddress } = state;
                        // console.log(privateKey, fromAddress)
                        classList.fromAddress = classList.privateKey = 0; // “变量提升 + 局部计算 ⇒ 必须先清责任域”

                        if (!privateKey || !fromAddress) {
                            classList.fromAddress = classList.privateKey = 1;
                            return;
                        }
                        if (!isLatest()) return;

                        try {
                            const privWIF = await addressVerify(privateKey, fromAddress, context.network);
                            context.__privateKeyWIF = privWIF; // TODO
                            //console.log(privWIF)
                            classList.privateKey = privWIF === null;
                            classList.fromAddress |= classList.privateKey;
                        } catch (_) {
                            classList.fromAddress = classList.privateKey = 1;
                        }
                    });

                    async function verify (state, key, selection) {
                        const amount = parseInt(state.amount ?? 0, 10);
                        const fromAddress = document.querySelector('#fromAddress');

                        if (key === 'privateKey' || key === 'amount' || key === 'fromAddress' || key === 'toAddress' || key === 'utxos') {
                            document.querySelector(`#${key}`).value = state[key];
                        }
                        else if (key === 'maxAmount') {
                            document.querySelector('#useMaxAmount b').innerHTML = state.maxAmount;
                        }
                        if (key === 'amount' && amount <= state.maxAmount) {
                            const fee = amount > 0 ? selection.select(amount).fee : 0;
                            state.fee = fee;
                        }
                        if (key === 'amount' || key === 'fee') {
                            document.querySelector('#fee').innerHTML = state.fee;
                        }
                        if (key === 'utxos') {
                            const utxos = state.utxos;
                            let data = null;
                            
                            try {
                                data = JSON.parse(utxos);
                                
                                classList.utxos = data.from == null || data.to == null || (data.utxos == null || data.utxos.length === 0);
                                classList.fromAddress = classList.utxos && data.from == null;
                                classList.toAddress = classList.utxos && data.to == null;
                            }
                            catch (_) {
                                state.maxAmount = document.querySelector('#useMaxAmount b').innerHTML = 0;
                                state.amount = document.querySelector(`#amount`).value = 0;
                                state.fee = document.querySelector('#fee').innerHTML = 0;
                                state.network = bitcoin.networks.bitcoin;
                                classList.utxos = classList.fromAddress = classList.toAddress = classList.privateKey = 1;
                            }
                            /*state.fromAddress = */document.querySelector('#fromAddress').value = classList.fromAddress ? '' : data.from;
                            /*state.toAddress = */document.querySelector('#toAddress').value = classList.toAddress ? '' : data.to;
                            
                            if (data && Array.isArray(data.utxos)) {
                                selection.init(data);
                                state.maxAmount = document.querySelector('#useMaxAmount b').innerHTML = selection.amountMax();
                            }
                            else {
                                state.maxAmount = 0;
                            }

                            if (data && data.from != null) {
                                state.network = detectNetwork(data.from);
                            }
                            createTree(Object.assign({ text: 'JSON' + (state.network.bech32 === 'tb' ? '<font color="#f7931a">🌐Detected Testnet address. Network switched automatically.</font>' : '')}, data ?? {}), document.querySelector('#tree'));
                            // 多重依赖
                            await watcher.set('fromAddress', data?.from ?? '', state);
                        }
                        if (key === 'privateKey') {
                            if (!state.privateKey || state.privateKey.length === 0) {
                                createTree({
                                    text: `BIP32`,
                                    nodes: [{ text: '' }]
                                }, bip32Tree);
                            }
                            await watcher.set('privateKey', state.privateKey, state);
                        }

                        const wrapper = document.querySelector('.wrapper');
                        let success = false;
                        for (const [key, val] of Object.entries(classList)) {
                            success = success || !!val;
                            wrapper.classList[val ? 'remove' : 'add'](key);
                        }

                        success = success || amount <= 0 || amount > state.maxAmount;

                        document.getElementById('signBtn').setAttribute('disabled', 'true');
                        if (!success) {
                            document.getElementById('signBtn').removeAttribute('disabled');
                        }

                        return success;
                    }
                    module.exports = verify;
                }, {
                    SelectionUTXOs: 'selection.SelectionUTXOs',
                    'createTree': 'dom.createTree',
                    'addressVerify': 'address.verify',
                    'watcher': 'object.watcher',
                    'detectNetwork': 'address.detectNetwork'
                }],
                'init': [function(require, module, exports) {
                    module.exports = function init () {
                        
                    };
                }, {}],
                main: [function (require, module, exports) {
                    const { qrcode, attributeFilter } = require('global');
                    const SelectionUTXOs = require('SelectionUTXOs');
                    const Transfer = require('btc.Transfer');
                    const { createWatcher, createObserver } = require('object.watcher');
                    const verify = require('verify');
                    const createTree = require('createTree');
                    const inputPriv = document.querySelector('#privateKey');

                    const watcher = createWatcher(attributeFilter/*initial*/, async (newValue, oldValue, key) => await verify(newValue, key, selection));
                    const observer = createObserver([
                        { target: inputPriv, type: 'input', key: 'privateKey' },
                        { target: document.querySelector('#utxos'), type: 'input', key: 'utxos' },
                        { target: document.querySelector('#amount'), type: 'input', key: 'amount' }
                    ], watcher);

                    require('init')();
                    const selection = new SelectionUTXOs(null);
                    const transfer = new Transfer(null, selection);
                    transfer.init(watcher);

                    document.querySelector('#useMaxAmount').addEventListener('click', () => {
                        const amount = parseInt(watcher.maxAmount, 10);
                        const fee = amount > 0 ? selection.select(Math.min(amount, watcher.maxAmount)).fee : 0;
                        watcher.amount = amount;
                        watcher.fee = fee;
                    });
                    document.querySelectorAll('input[name="keyType"]').forEach(radio => {
                        radio.addEventListener('change', function () {
                            const id = this.getAttribute('id');
                            const isMnemonic = id === 'typeMnemonic';
                            document.querySelector('#bip32Tree').style.display = isMnemonic ? 'block' : 'none';
                            watcher.privateKey = inputPriv.value = this.value;
                            inputPriv.select();
                            inputPriv.placeholder = isMnemonic ? attributeFilter.privateKey : 'L4f4YfvuKBNndszc5jMEg24D56Ahd1FN57RK9TiALQBAkQY6PNXx';
                        });
                    });

                    document.querySelector('#signBtn').addEventListener('click', async function () {
                        if (watcher.__privateKeyWIF !== null) {
                            transfer.utxo = JSON.parse(watcher.utxos);
                            let txHex = '';
                            try {
                                txHex = await transfer.send(watcher.__privateKeyWIF, parseInt(watcher.amount, 10), watcher.network);
                            }
                            catch (_) {
                                txHex = 'Invalid signature tx';
                            }
                            document.querySelector('#txTree').innerHTML = `<p>${txHex}</p>`;
                        }
                    });
                    
                    const isExtension = typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id;
                    if (isExtension) document.documentElement.classList.add('extension-mode');

                    document.querySelector('#downloadPage').addEventListener('click', () => {
                        const htmlContent = document.documentElement.outerHTML;
                        const blob = new Blob([htmlContent], { type: 'text/html' });
                        const url = URL.createObjectURL(blob);

                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'airbtc.html';
                        document.body.appendChild(a);
                        a.click();

                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    });
                }, {
                    SelectionUTXOs: 'selection.SelectionUTXOs',
                    Legacy: 'address.Legacy',
                    'init': 'init',
                    'global': 'global.var',
                    'watcher': 'object.watcher',
                    'createTree': 'dom.createTree',
                    'verify': 'verify'
                }]
            }, {}, ['main']);
        </script>
        <!--script type="module" src="./index.js"></script-->
    </body>
</html>